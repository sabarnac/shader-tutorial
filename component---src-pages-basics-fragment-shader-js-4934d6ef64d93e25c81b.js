"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[675],{8129:function(e,t,r){r.r(t),r.d(t,{default:function(){return W}});var a=r(4794),n=r(2532),i=r(6540),o=(r(6449),r(3514),r(7684)),l=r(3461),s=r(6417),c=r(782);const m="void main() {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",h={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{mvpMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{}}},f=o.vt();var d=(0,s.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]]},{0:t,1:r}=(0,i.useState)(null),{0:a,1:n}=(0,i.useState)(null),{0:s,1:d}=(0,i.useState)(null),{0:u,1:p}=(0,i.useState)({vertices:null}),g=(0,i.useRef)();return(0,i.useEffect)((()=>{if(null!==g.current){const e=new c.A(g.current,f);return r(e),()=>{r(null),e.destroy()}}}),[g]),(0,i.useEffect)((0,l.sT)(null!==t,(()=>{n(t.createShaderProgram("attribute vec4 vertexPosition;\n\nuniform mat4 mvpMatrix;\n\nvoid main() {\n  gl_Position = mvpMatrix * vertexPosition;\n}",m))})),[t]),(0,i.useEffect)((0,l.sT)(null!==a,(()=>{d(t.getDataLocations(a,h))})),[a]),(0,i.useEffect)((0,l.sT)(null!==s,(()=>{p({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),u.vertices)})})),[s]),(0,i.useEffect)((0,l.sT)(null!==u.vertices,(()=>{let r=!0;const n=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:l,viewMatrix:c,modelMatrix:m}=t;if(!r)return;const h=o.vt();o.lw(h,c,m),o.lw(h,l,h),i.bindBuffer(i.ARRAY_BUFFER,u.vertices),i.vertexAttribPointer(s.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(s.vertex.attributeLocations.vertexPosition),i.useProgram(a),i.uniformMatrix4fv(s.vertex.uniformLocations.mvpMatrix,!1,h),i.drawArrays(i.TRIANGLES,0,e.vertices.length),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[u]),i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:g},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nTriangle Vertices:\n    Vertex 1: "+(0,l.NW)(e.vertices[0])+"\n    Vertex 2: "+(0,l.NW)(e.vertices[1])+"\n    Vertex 3: "+(0,l.NW)(e.vertices[2])+"\n").trim()))})),u="attribute vec4 vertexPosition;\nattribute vec3 vertexColor;\n\nuniform mat4 mvpMatrix;\n\nvarying highp vec3 color;\n\nvoid main() {\n  gl_Position = mvpMatrix * vertexPosition;\n  color = vertexColor;\n}";const p=u,g="varying lowp vec3 color;\n\nvoid main() {\n  gl_FragColor = vec4(color, 1);\n}",v={vertex:{attributeLocations:{vertexPosition:"vec4",vertexColor:"vec3"},uniformLocations:{mvpMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{}}},b=o.vt();var x=(0,s.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]],colors:[[1,0,0],[0,1,0],[0,0,1]]},{0:t,1:r}=(0,i.useState)(null),{0:a,1:n}=(0,i.useState)(null),{0:s,1:m}=(0,i.useState)(null),{0:h,1:f}=(0,i.useState)({vertices:null,colors:null}),d=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==d.current){const e=new c.A(d.current,b);return r(e),()=>{r(null),e.destroy()}}}),[d]),(0,i.useEffect)((0,l.sT)(null!==t,(()=>{n(t.createShaderProgram(p,g))})),[t]),(0,i.useEffect)((0,l.sT)(null!==a,(()=>{m(t.getDataLocations(a,v))})),[a]),(0,i.useEffect)((0,l.sT)(null!==s,(()=>{f({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),h.vertices),colors:t.createStaticDrawArrayBuffer(e.colors.flat(),h.colors)})})),[s]),(0,i.useEffect)((0,l.sT)(null!==h.vertices&&null!==h.colors,(()=>{let r=!0;const n=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:l,viewMatrix:c,modelMatrix:m}=t;if(!r)return;const f=o.vt();o.lw(f,c,m),o.lw(f,l,f),i.bindBuffer(i.ARRAY_BUFFER,h.vertices),i.vertexAttribPointer(s.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(s.vertex.attributeLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,h.colors),i.vertexAttribPointer(s.vertex.attributeLocations.vertexColor,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(s.vertex.attributeLocations.vertexColor),i.useProgram(a),i.uniformMatrix4fv(s.vertex.uniformLocations.mvpMatrix,!1,f),i.drawArrays(i.TRIANGLES,0,e.vertices.length),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[h]);const u={x:"r",y:"g",z:"b"};return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:d},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nTriangle Vertices:\n    Vertex 1: "+(0,l.NW)(e.vertices[0])+"\n    Vertex 2: "+(0,l.NW)(e.vertices[1])+"\n    Vertex 3: "+(0,l.NW)(e.vertices[2])+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nVertex Colors:\n    Vertex 1: "+(0,l.NW)(e.colors[0],u)+"\n    Vertex 2: "+(0,l.NW)(e.colors[1],u)+"\n    Vertex 3: "+(0,l.NW)(e.colors[2],u)+"\n").trim()))}));const w=u,E="varying highp vec3 color;\n\nuniform highp float time;\n\nvoid main() {\n  highp float colorShift = cos(time / 500.0);\n  gl_FragColor = vec4(clamp(color - colorShift, 0.0, 1.0), 1.0);\n}",y={vertex:{attributeLocations:{vertexPosition:"vec4",vertexColor:"vec3"},uniformLocations:{mvpMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{time:"float"}}},A=o.vt();var S=(0,s.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]],colors:[[1,0,0],[0,1,0],[0,0,1]]},{0:t,1:r}=(0,i.useState)(null),{0:a,1:n}=(0,i.useState)(null),{0:s,1:m}=(0,i.useState)(null),{0:h,1:f}=(0,i.useState)({vertices:null,colors:null}),{0:d,1:u}=(0,i.useState)("undefined"!=typeof performance?performance.now():0),p=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==p.current){const e=new c.A(p.current,A);return r(e),()=>{r(null),e.destroy()}}}),[p]),(0,i.useEffect)((0,l.sT)(null!==t,(()=>{n(t.createShaderProgram(w,E))})),[t]),(0,i.useEffect)((0,l.sT)(null!==a,(()=>{m(t.getDataLocations(a,y))})),[a]),(0,i.useEffect)((0,l.sT)(null!==s,(()=>{f({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),h.vertices),colors:t.createStaticDrawArrayBuffer(e.colors.flat(),h.colors)})})),[s]),(0,i.useEffect)((0,l.sT)(null!==h.vertices,(()=>{let r=!0,n=parseInt("undefined"!=typeof performance?performance.now():(0).toString());const i=()=>{t.renderScene((t=>{let{gl:l,projectionMatrix:c,viewMatrix:m,modelMatrix:f}=t;if(!r)return;const d=parseInt("undefined"!=typeof performance?performance.now():(0).toString());d-n>100&&(n=d,u(d));const p=o.vt();o.lw(p,m,f),o.lw(p,c,p),l.bindBuffer(l.ARRAY_BUFFER,h.vertices),l.vertexAttribPointer(s.vertex.attributeLocations.vertexPosition,3,l.FLOAT,!1,0,0),l.enableVertexAttribArray(s.vertex.attributeLocations.vertexPosition),l.bindBuffer(l.ARRAY_BUFFER,h.colors),l.vertexAttribPointer(s.vertex.attributeLocations.vertexColor,3,l.FLOAT,!1,0,0),l.enableVertexAttribArray(s.vertex.attributeLocations.vertexColor),l.useProgram(a),l.uniformMatrix4fv(s.vertex.uniformLocations.mvpMatrix,!1,p),l.uniform1f(s.fragment.uniformLocations.time,d),l.drawArrays(l.TRIANGLES,0,e.vertices.length),requestAnimationFrame(i)}))};return requestAnimationFrame(i),()=>{r=!1}})),[h]);const g={x:"r",y:"g",z:"b"};return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:p},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nTriangle Vertices:\n    Vertex 1: "+(0,l.NW)(e.vertices[0])+"\n    Vertex 2: "+(0,l.NW)(e.vertices[1])+"\n    Vertex 3: "+(0,l.NW)(e.vertices[2])+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nVertex Colors:\n    Vertex 1: "+(0,l.NW)(e.colors[0],g)+"\n    Vertex 2: "+(0,l.NW)(e.colors[1],g)+"\n    Vertex 3: "+(0,l.NW)(e.colors[2],g)+"\n").trim()),i.createElement("pre",{className:"util text-left"},"Time: ",d))})),k=r(9460),L=r(7154),T=r(6042),F=r(7570),P=r(2007),N=r(2269);var W=e=>{let{location:{pathname:t}}=e;return i.createElement(F.A,null,i.createElement(N.A,{pathname:t,title:"Shader Basics - Fragment Shader",description:"A look into the basics of a GPU fragment shader.",keywords:["fragment","shader","basics"]}),i.createElement(k.A,null,i.createElement("h1",null,"Shader Basics - Fragment Shader"),i.createElement(T.A,{type:"h2"},"What is a fragment shader"),i.createElement("p",null,'Similar to how a vertex shader operates on vertices of an object, a fragment shader operates on a "fragment" of an object and tells what the color of that fragment is supposed to be.'),i.createElement("p",null,"Since it is executed per fragment on all fragments generated by the GPU pipeline, any operation that requires modification of the color of the fragment (like brightening due to lights or darkening due to shadows) can be done through the fragment shader."),i.createElement(T.A,{type:"h2"},"What is a fragment"),i.createElement("p",null,"As previously mentioned in the"," ",i.createElement(a.Link,{to:"/basics/render-pipeline/"},"render pipeline overview"),", a fragment is a sample of a primitive that contains certain information required for coloring a pixel."),i.createElement("p",null,"A pixel can consist of multiple fragments, because, depending upon what area of the primitive the pixel covers, there can be multiple values present within the pixel, which have to either be combined, or just one selected at random."),i.createElement("p",null,"As an example, take a circle that is to be rendered on a screen of size 8x8 pixels (total of 64 pixels), as shown by the image below:"),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/basics/fragment-1.png",alt:"Fragment Example Part 1",style:{maxWidth:"65%"},__imageData:r(2355)})),i.createElement("p",null,"After splitting the circle into 16 equal parts, a decision on what the color of each pixel should be needs to be made. For pixels with just a single color, they just adopt that color."),i.createElement("p",null,"However, the other pixels contain two colors, as they contain both the circle and the background. This requires a decision needs to be made as to what the final color of the pixel should be."),i.createElement("p",null,'In order to do this, a sample can be taken from somewhere in the area the pixel covers, and fix that as the final color of the pixel. This sample is what is considered a "fragment".'),i.createElement("p",null,'If only one "fragment" is requuired per pixel, then a sample from the center of each pixel can be taken, resulting in the render below:'),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/basics/fragment-2.png",alt:"Fragment Example Part 2",style:{maxWidth:"65%"},__imageData:r(1172)})),i.createElement("p",null,"Instead, if multiple fragments are taken, a final color value for the pixel can be interpolated based on what the color of each fragment is."),i.createElement("p",null,'In the case of the circle, by taking 4 "fragments" (one from approximately each corner), the final color would be a reddish-pink, since two of these fragments would have the color red, and the other two would have the color white:'),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/basics/fragment-3.png",alt:"Fragment Example Part 3",style:{maxWidth:"65%"},__imageData:r(4103)})),i.createElement("p",null,"While not as accurate as our initial image, it is still closer to reality compared to the first result. If you're not sure how, let's see how these images look at 30px width and height."),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/basics/fragment-2.png",alt:"Fragment Example Part 2 Mini",style:{maxWidth:"30px"},__imageData:r(1172)}),i.createElement("br",null),i.createElement(n.S,{src:"../../images/basics/fragment-3.png",alt:"Fragment Example Part 3 Mini",style:{maxWidth:"30px"},__imageData:r(4103)})),i.createElement("p",null,"At a much smaller scale, the second result looks considerably more like a circle than the first result. This is how certain anti-aliasing methods works."),i.createElement("p",null,"Along with this case, primitives can also overlap other primitives, which means fragments can overlap other fragments. This requires fragments to be discarded if they are covered, or combined with other fragments if some of them are not opaque (a fragment from a translucent glass over an object)."),i.createElement("p",null,"Do note that in DirectX, fragments are called pixels (and by extension, fragment shaders are called pixel shaders), but that name isn't technically accurate."),i.createElement(T.A,{type:"h2"},"An example - The triangle returns"),i.createElement("p",null,"Let's go back to our standard triangle example. Previously, we only had the edges of the triangle drawn to provide an explanation on how vertex shaders work. This time we'll be coloring the entire triangle."),i.createElement(d,null),i.createElement(T.A,{type:"h3"},"How it works"),i.createElement(L.A,{code:m.trim(),type:"Fragment"}),i.createElement("p",null,"Looking at the code, you'll see the fragment shader is extremely simple, it just generates a ",i.createElement("code",null,"vec4")," of ",i.createElement("code",null,"1.0, 0.0, 0.0, 0.0"),", which corresponds to R, G, B, and A values respectively. The color is then assigned to the special output variable defined in WebGL called"," ",i.createElement("code",null,"gl_FragColor")," (WebGL Fragment Color)"),i.createElement("p",null,"In the vertex shader examples, WebGL was told that the three vertices provided were part of a line loop, meaning they are coordinates that define a line that loops back around to the start."),i.createElement("p",null,"So when WebGL would call the fragment shader, it would color the fragments of the lines that joined the first and second vertex, then the line connecting the second and third vertex, and (since it was defined to be a loop), the line connecting third and first vertex."),i.createElement("p",null,"In this case, since WebGL is told the vertices belong to a triangle, the 3 vertices are taken and used to create a triangle, and that triangle is then split into fragments, with each fragment then colored by the fragment shader."),i.createElement(T.A,{type:"h2"},"Another example - A triangular color wheel"),i.createElement("p",null,"What if we wanted to define our own color values that should be used to color the pixels? Just like with the vertex shader, we can pass our own needed values to the fragment shader."),i.createElement("p",null,"These values have to be passed through the vertex shader, meaning that when the vertex shader receives the value, it has to set that value to another variable, which is then received by the fragment shader."),i.createElement("p",null,"One very important note is that you can only define the color values of each vertex, and not each fragment or pixel, since their number is an unknown (you won't know how many fragments may be generated, or pixels that the object may cover)."),i.createElement("p",null,"So if we can only define color values for each vertex, how will the fragment shader know what color it should receive for pixels that are inside the triangle not defined by any vertex? Let's take a look at an example."),i.createElement(x,null),i.createElement(T.A,{type:"h3"},"How it works"),i.createElement("p",null,"As is visible from the result, since we set the colors of each vertex have been set to red, green, and blue, those corners of the triangles have been colored appropriately."),i.createElement("p",null,"However, the rest of the triangle seems to be a color mixture of all these colors in specific ratios. This is done through interpolation."),i.createElement("p",null,"When we set the colors of the vertices, and then the object/primitive is set into fragments, the fragments covering the vertices automatically get the color of that vertex, since that is what that fragment represents."),i.createElement("p",null,"The color of other fragments is determined by checking its position and distance relative to every vertex, and interpolating what its color value should be based upon the distance."),i.createElement("p",null,"So, for example, as a fragment moves further away from vertex 2 and moves closer to vertex 3, the green color component slowly fades away and is slowly overtaken by the blue component."),i.createElement("p",null,"Let's look at the code for the shaders in this example:"),i.createElement(L.A,{code:p.trim(),type:"Vertex"}),i.createElement(L.A,{code:g.trim(),type:"Fragment"}),i.createElement("p",null,"We pass the color of the vertices to their respective vertex shader by passing the color values as an attribute (since the color is different per vertex)."),i.createElement("p",null,"The vertex shader then passes this on to the fragment shader through the"," ",i.createElement("code",null,"vec3")," varying named ",i.createElement("code",null,"color"),"."),i.createElement("p",null,"The ",i.createElement("code",null,"color")," is defined as a varying is because while it is fixed per vertex, it will need to be interpolated when passed to fragments, depending on their position relative to the vertices."),i.createElement("p",null,"It is also defined as ",i.createElement("code",null,"lowp")," which just means the precision of it's value is low (we can ignore these sorts of qualifiers)."),i.createElement("p",null,"As a result, when we pass the color of the vertices down to the fragment shaders, the value is interpolated based on the position of the fragment, and then passed to the fragment."),i.createElement("p",null,"Just as attributes are read-only for the vertex shader and can differ per vertex, varyings are read-only for the fragment shader and can differ per fragment (they are write only for the vertex shader)."),i.createElement(T.A,{type:"h2"},"A final example - A pulsing triangle color wheel"),i.createElement(S,null),i.createElement(T.A,{type:"h3"},"How it works"),i.createElement("p",null,"Similar to how we did the rotating triangle in the previous chapter, we determine how much to shift the color by relative to the current timestamp."),i.createElement("p",null,"By subtracting the calculated color shift from the interpolated fragment color, we can have the color of the triangle oscillate from pure black, to the standard triangle color wheel, to pure white, and back again."),i.createElement(L.A,{code:E.trim(),type:"Fragment"}),i.createElement("p",null,"The color shift is calculated in the shader by taking the time elapsed since the start of the animation as an input, dividing it by 500 so that the animation runs slower, and then finding the cosine of the elapsed time."),i.createElement("p",null,"The time is passed in milliseconds, and the ",i.createElement("code",null,"cos")," function in glsl takes time in radians. So the animation depends on every half second passed."),i.createElement("p",null,"Since the division results in a floating point number, this number does change every frame, which results in the color shift value also updating accordingly."),i.createElement("p",null,i.createElement("em",null,i.createElement("code",null,"clamp")," is a function that takes a specific value (",i.createElement("code",null,"color - colorShift"),") and makes sure it doesn't go outside of a certain range (",i.createElement("code",null,"0.0")," and ",i.createElement("code",null,"1.0"),'), "clamping" it to either end depending on if it is too large or too small. It also works with both vector (',i.createElement("code",null,"vec2"),", ",i.createElement("code",null,"vec3"),","," ",i.createElement("code",null,"vec4"),") and scalar values (",i.createElement("code",null,"float"),","," ",i.createElement("code",null,"int"),")")),i.createElement(T.A,{type:"h2"},"Summary"),i.createElement("ul",null,i.createElement("li",null,"The fragment shader receives a fragment from a list of fragments and sets the appropriate color value for that fragment."),i.createElement("li",null,"At least one fragment that comes under a pixel is used when determining the color of that pixel."),i.createElement("li",null,"The fragment shader requires certain values in order to determine what the final color of the fragment should be.",i.createElement("ul",null,i.createElement("li",null,"If this data is passed through the vertex shader, its actual value will be interpolated by the GPU based on the distance of the fragment from each vertex of the primitive."),i.createElement("li",null,"If the data is passed as a uniform, then the GPU will not interpolate its actual value, since it is supposed to be uniform among all fragments."))))),i.createElement(P.A,{previous:"/basics/color/",next:"/basics/end/"}))}},4103:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f80808","images":{"fallback":{"src":"/static/5b2f6adfed7c5047c8ed485b0738b0f4/c1caf/fragment-3.png","srcSet":"/static/5b2f6adfed7c5047c8ed485b0738b0f4/de391/fragment-3.png 250w,\\n/static/5b2f6adfed7c5047c8ed485b0738b0f4/82c11/fragment-3.png 500w,\\n/static/5b2f6adfed7c5047c8ed485b0738b0f4/c1caf/fragment-3.png 999w","sizes":"(min-width: 999px) 999px, 100vw"},"sources":[{"srcSet":"/static/5b2f6adfed7c5047c8ed485b0738b0f4/e7160/fragment-3.webp 250w,\\n/static/5b2f6adfed7c5047c8ed485b0738b0f4/5f169/fragment-3.webp 500w,\\n/static/5b2f6adfed7c5047c8ed485b0738b0f4/ce154/fragment-3.webp 999w","type":"image/webp","sizes":"(min-width: 999px) 999px, 100vw"}]},"width":999,"height":999}')},1172:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f80808","images":{"fallback":{"src":"/static/906b5f59c240d739f3c0570b6ba98006/c1caf/fragment-2.png","srcSet":"/static/906b5f59c240d739f3c0570b6ba98006/de391/fragment-2.png 250w,\\n/static/906b5f59c240d739f3c0570b6ba98006/82c11/fragment-2.png 500w,\\n/static/906b5f59c240d739f3c0570b6ba98006/c1caf/fragment-2.png 999w","sizes":"(min-width: 999px) 999px, 100vw"},"sources":[{"srcSet":"/static/906b5f59c240d739f3c0570b6ba98006/e7160/fragment-2.webp 250w,\\n/static/906b5f59c240d739f3c0570b6ba98006/5f169/fragment-2.webp 500w,\\n/static/906b5f59c240d739f3c0570b6ba98006/ce154/fragment-2.webp 999w","type":"image/webp","sizes":"(min-width: 999px) 999px, 100vw"}]},"width":999,"height":999}')},2355:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f80808","images":{"fallback":{"src":"/static/46ed11f9cd51e2fde0c49bc9e2f24c80/c1caf/fragment-1.png","srcSet":"/static/46ed11f9cd51e2fde0c49bc9e2f24c80/de391/fragment-1.png 250w,\\n/static/46ed11f9cd51e2fde0c49bc9e2f24c80/82c11/fragment-1.png 500w,\\n/static/46ed11f9cd51e2fde0c49bc9e2f24c80/c1caf/fragment-1.png 999w","sizes":"(min-width: 999px) 999px, 100vw"},"sources":[{"srcSet":"/static/46ed11f9cd51e2fde0c49bc9e2f24c80/e7160/fragment-1.webp 250w,\\n/static/46ed11f9cd51e2fde0c49bc9e2f24c80/5f169/fragment-1.webp 500w,\\n/static/46ed11f9cd51e2fde0c49bc9e2f24c80/ce154/fragment-1.webp 999w","type":"image/webp","sizes":"(min-width: 999px) 999px, 100vw"}]},"width":999,"height":999}')}}]);
//# sourceMappingURL=component---src-pages-basics-fragment-shader-js-4934d6ef64d93e25c81b.js.map