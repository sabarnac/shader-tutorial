"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[438],{3819:function(e,t,r){r.r(t),r.d(t,{default:function(){return q}});var n=r(6540);const a="attribute vec4 vertexPosition;\nattribute vec3 vertexColor;\n\nuniform mat4 mvpMatrix;\n\nvarying highp vec3 color;\n\nvoid main() {\n  gl_Position = mvpMatrix * vertexPosition;\n  color = vertexColor;\n}",o="varying highp vec3 color;\n\nvoid main() {\n  gl_FragColor = vec4(color, 0.5);\n}";r(6449),r(3514);var i=r(7684),l=r(3461),s=r(6417),c=r(782);const u={vertex:{attributeLocations:{vertexPosition:"vec4",vertexColor:"vec3"},uniformLocations:{mvpMatrix:"mat4"}}},h=i.vt();var d=(0,s.A)((()=>{const e={vertices:[[1.5,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[-1,-1,-1],[-1.5,-1.5,1],[-1.5,1,1],[1,-1.5,1],[-1.5,1,1],[1,-1.5,1],[1,1,1]],colors:[[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11]]},{0:t,1:r}=(0,n.useState)(null),{0:s,1:d}=(0,n.useState)(null),{0:m,1:f}=(0,n.useState)(null),{0:p,1:g}=(0,n.useState)({vertices:null,colors:null,indices:null}),v=(0,n.useRef)();return(0,n.useEffect)((()=>{if(null!==v.current){const e=new c.A(v.current,h,!0);return r(e),()=>{r(null),e.destroy()}}}),[v]),(0,n.useEffect)((0,l.sT)(null!==t,(()=>{d(t.createShaderProgram(a,o))})),[t]),(0,n.useEffect)((0,l.sT)(null!==s,(()=>{f(t.getDataLocations(s,u))})),[s]),(0,n.useEffect)((0,l.sT)(null!==m,(()=>{g({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),p.vertices),colors:t.createStaticDrawArrayBuffer(e.colors.flat(),p.colors),indices:t.createElementArrayBuffer(e.indices.flat(),p.indices)})})),[m]),(0,n.useEffect)((0,l.sT)(null!==p.vertices,(()=>{let r=!0;const n=()=>{t.renderSceneOrtho((t=>{let{gl:a,orthoMatrix:o,viewMatrix:l,modelMatrix:c}=t;if(!r)return;const u=i.vt();i.lw(u,l,c),i.lw(u,o,u),a.bindBuffer(a.ARRAY_BUFFER,p.vertices),a.vertexAttribPointer(m.vertex.attributeLocations.vertexPosition.reverse,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(m.vertex.attributeLocations.vertexPosition),a.bindBuffer(a.ARRAY_BUFFER,p.colors),a.vertexAttribPointer(m.vertex.attributeLocations.vertexColor,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(m.vertex.attributeLocations.vertexColor),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,p.indices),a.useProgram(s),a.uniformMatrix4fv(m.vertex.uniformLocations.mvpMatrix,!1,u),a.drawElements(a.TRIANGLES,e.indices.length*e.indices[0].length,a.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[p]),n.createElement("div",{className:"util text-center",style:{padding:"1rem"}},n.createElement("canvas",{width:"640",height:"480",ref:v},"Cannot run WebGL examples (not supported)"),n.createElement("pre",{className:"util text-left"},"\nOrder of Faces:\n    Depth-wise:\n        Red Square (Front)\n        Green Square (Back)\n    Passed to GPU:\n        Green Square (First)\n        Red Square (Second)\n".trim()))}));const m={vertex:{attributeLocations:{vertexPosition:"vec4",vertexColor:"vec3"},uniformLocations:{mvpMatrix:"mat4"}}},f=i.vt();var p=(0,s.A)((()=>{const e={vertices:[[-1.5,-1.5,1],[-1.5,1,1],[1,-1.5,1],[-1.5,1,1],[1,-1.5,1],[1,1,1],[1.5,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[-1,-1,-1]],colors:[[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11]]},{0:t,1:r}=(0,n.useState)(null),{0:s,1:u}=(0,n.useState)(null),{0:h,1:d}=(0,n.useState)(null),{0:p,1:g}=(0,n.useState)({vertices:null,colors:null,indices:null}),v=(0,n.useRef)();return(0,n.useEffect)((()=>{if(null!==v.current){const e=new c.A(v.current,f,!0);return r(e),()=>{r(null),e.destroy()}}}),[v]),(0,n.useEffect)((0,l.sT)(null!==t,(()=>{u(t.createShaderProgram(a,o))})),[t]),(0,n.useEffect)((0,l.sT)(null!==s,(()=>{d(t.getDataLocations(s,m))})),[s]),(0,n.useEffect)((0,l.sT)(null!==h,(()=>{g({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),p.vertices),colors:t.createStaticDrawArrayBuffer(e.colors.flat(),p.colors),indices:t.createElementArrayBuffer(e.indices.flat(),p.indices)})})),[h]),(0,n.useEffect)((0,l.sT)(null!==p.vertices,(()=>{let r=!0;const n=()=>{t.renderSceneOrtho((t=>{let{gl:a,orthoMatrix:o,viewMatrix:l,modelMatrix:c}=t;if(!r)return;const u=i.vt();i.lw(u,l,c),i.lw(u,o,u),a.bindBuffer(a.ARRAY_BUFFER,p.vertices),a.vertexAttribPointer(h.vertex.attributeLocations.vertexPosition.reverse,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(h.vertex.attributeLocations.vertexPosition),a.bindBuffer(a.ARRAY_BUFFER,p.colors),a.vertexAttribPointer(h.vertex.attributeLocations.vertexColor,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(h.vertex.attributeLocations.vertexColor),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,p.indices),a.useProgram(s),a.uniformMatrix4fv(h.vertex.uniformLocations.mvpMatrix,!1,u),a.drawElements(a.TRIANGLES,e.indices.length*e.indices[0].length,a.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[p]),n.createElement("div",{className:"util text-center",style:{padding:"1rem"}},n.createElement("canvas",{width:"640",height:"480",ref:v},"Cannot run WebGL examples (not supported)"),n.createElement("pre",{className:"util text-left"},"\nOrder of Faces:\n    Depth-wise:\n        Green Square (Front)\n        Red Square (Back)\n    Passed to GPU:\n        Green Square (First)\n        Red Square (Second)\n".trim()))}));const g={vertex:{attributeLocations:{vertexPosition:"vec4",vertexColor:"vec3"},uniformLocations:{mvpMatrix:"mat4"}}},v=i.vt();var b=(0,s.A)((()=>{const e={vertices:[[1.5,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[1.5,-1,-1],[-1,1.5,-1],[-1,-1,-1],[-1.5,-1.5,1],[-1.5,1,1],[1,-1.5,1],[-1.5,1,1],[1,-1.5,1],[1,1,1]],colors:[[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11]]},{0:t,1:r}=(0,n.useState)(null),{0:s,1:u}=(0,n.useState)(null),{0:h,1:d}=(0,n.useState)(null),{0:m,1:f}=(0,n.useState)({vertices:null,colors:null,indices:null}),p=(0,n.useRef)();return(0,n.useEffect)((()=>{if(null!==p.current){const e=new c.A(p.current,v,!0);return r(e),()=>{r(null),e.destroy()}}}),[p]),(0,n.useEffect)((0,l.sT)(null!==t,(()=>{u(t.createShaderProgram(a,o))})),[t]),(0,n.useEffect)((0,l.sT)(null!==s,(()=>{d(t.getDataLocations(s,g))})),[s]),(0,n.useEffect)((0,l.sT)(null!==h,(()=>{f({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),m.vertices),colors:t.createStaticDrawArrayBuffer(e.colors.flat(),m.colors),indices:t.createElementArrayBuffer(e.indices.flat(),m.indices)})})),[h]),(0,n.useEffect)((0,l.sT)(null!==m.vertices,(()=>{let r=!0;const n=()=>{t.renderSceneOrtho((t=>{let{gl:a,orthoMatrix:o,viewMatrix:l,modelMatrix:c}=t;if(!r)return;const u=i.vt();i.lw(u,l,c),i.lw(u,o,u),a.bindBuffer(a.ARRAY_BUFFER,m.vertices),a.vertexAttribPointer(h.vertex.attributeLocations.vertexPosition.reverse,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(h.vertex.attributeLocations.vertexPosition),a.bindBuffer(a.ARRAY_BUFFER,m.colors),a.vertexAttribPointer(h.vertex.attributeLocations.vertexColor,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(h.vertex.attributeLocations.vertexColor),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,m.indices),a.useProgram(s),a.uniformMatrix4fv(h.vertex.uniformLocations.mvpMatrix,!1,u),a.drawElements(a.TRIANGLES,e.indices.length*e.indices[0].length,a.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[m]),n.createElement("div",{className:"util text-center",style:{padding:"1rem"}},n.createElement("canvas",{width:"640",height:"480",ref:p},"Cannot run WebGL examples (not supported)"),n.createElement("pre",{className:"util text-left"},"\nOrder of Faces:\n    Depth-wise:\n        Green Square (Front)\n        Red Square (Back)\n    Passed to GPU:\n        Red Square (First)\n        Green Square (Second)\n".trim()))}));var w=r(9460),E=r(5024),x=r(7154),A=r(6042),y=r(7570),S=r(2007),L=r(2269);var q=e=>{let{location:{pathname:t}}=e;return n.createElement(y.A,null,n.createElement(L.A,{pathname:t,title:"Shader Advanced - Transparency",description:"A look into the implementing transparency and certain quirks about it.",keywords:["shader","advanced","transparency","transparent","transluscent"]}),n.createElement(w.A,null,n.createElement("h1",null,"Shader Advanced - Transparency"),n.createElement("p",null,"Implementing support for transparency in shader code is not a complex task. The fragment shader returns a color vector of 4 components, with the 4th component representing opaqueness of the color."),n.createElement("p",null,"By setting the opaqueness value of the color of the fragments, you can make fragments transparent. The GPU can be told how transluscent colors returned by the fragment shader should be blended, and based upon that get a final result."),n.createElement(x.A,{code:o.trim(),type:"Fragment"}),n.createElement("p",null,"As seen in this fragment shader code, the color of the fragment is set using whatever color value is received, and the alpha value of the color is set to 0.5. This means that the fragment is 50% opaque."),n.createElement("p",null,"However, just setting the alpha value isn't enough. You will have to explicitly tell the graphics API you use to enable color/alpha blending."),n.createElement("p",null,"Color blending is an operation that the GPU can perform where it blends the colors of multiple fragments into a final output color."),n.createElement("p",null,"Alpha blending is a type of color blending where the colors from different fragments are blended together depending on the alpha component of each color."),n.createElement("p",null,"GPUs can blend colors in multiple ways, each using their own specific formula for how colors are mixed. However, while some can be used with no issues, there are certain blending algorithms that have caveats attached to them."),n.createElement("p",null,"For the examples we'll be showing, the WebGL color blending configuration is:"),n.createElement(E.A,{code:"\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n".trim(),type:"WebGL",language:"js"}),n.createElement("p",null,"The equivalent OpenGL and DirectX color blending configurations are:"),n.createElement(E.A,{code:"\nvoid enableBlending() {\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n}\n".trim(),type:"OpenGL",language:"cpp"}),n.createElement(E.A,{code:"\nvoid enableBlending() {\n  d3dDevice->SetRenderState(D3DRS_ALPHABLENDENABL, TRUE);\n  d3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR);\n  d3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);\n}\n".trim(),type:"DirectX",language:"cpp"}),n.createElement("p",null,"While this configuration is recommended for blending transparent colors, it has a requirement that can severly impact performance. Let's look at an example to see the limitations of the chosen color blending algorithm."),n.createElement(A.A,{type:"h2"},"Example - Red Square and Green Square"),n.createElement(d,null),n.createElement("p",null,"Here, we're drawing two squares, one in red, and one in green. In this image, the red square is placed in front of the green square, but the green square is passed to the GPU first for rendering."),n.createElement("p",null,"The GPU first draws the green square onto the image. Once the green square is drawn, it begins drawing the red square on top. When the red square is being drawn, the parts of the red square that overlay on top of the green square require the colors of both to be blended together."),n.createElement("p",null,"The blending configuration that is being used, and was shown previously, tells the GPU to blend the colors in such a way that the new fragment color being added to the image should dominate over the color already present in the image."),n.createElement("p",null,"Since the red square is drawn after the green square, its color will dominate over the green, making the color of the overlay section skew more towards red."),n.createElement("p",null,"This is in line with our expectations, since the red square is also in front of the green square depth-wise, which should result in the common area looking red with a green hue."),n.createElement("p",null,"However, what if we wish to draw the image with the green square in front? If we swap the vertex positions of the two squares, we get the following result."),n.createElement(p,null),n.createElement("p",null,"This result is completely inaccurate. The color of the green square should be dominating over the red, but it is in fact the same as the first example, giving the impression that the red square is still in front."),n.createElement("p",null,"Why is this the case? Because the blending operation has a major requirement that we have failed to satisfy with the second example."),n.createElement("p",null,"In the first image, the green square was drawn onto the image first, and followed by the red square. The chosen blending operation operates in such a way that new objects being drawn will have their colors dominate over already existing colors in the image."),n.createElement("p",null,"This means that the algorithm operates under the assumption that an object already drawn onto the image is present behind the object that is being drawn next."),n.createElement("p",null,"Since the red square is being drawn second, its colors will dominate over the green due to the blending operation selected - the operation assumes that the red square is actually in front of the green square due to it being drawn second."),n.createElement("p",null,"In order to fix this result, the order in which the squares are passed to the GPU should be sorted by the depth of the squares. Squares further away from the camera should be drawn before squares closer to the camera."),n.createElement(b,null),n.createElement("p",null,"Since the red square is now behind, by passing it first to the GPU to be drawn, the error in our result is now fixed. The color of the green square now dominates over the red, as it should have been."),n.createElement("p",null,"In our example, the issue was very simple to fix since we were only drawing two squares that are completely separated and can be sorted with ease."),n.createElement("p",null,"However, in cases of objects with multiple polygons that connect or cross-over each other, each polygon needs to be sorted in the correct order."),n.createElement("p",null,"This issue can further be aggravated by a moving camera. Since all transparent polygons have to be sorted by depth w.r.t. the camera, a moving camera requires sorting each polygon in model-view-space, which is expensive."),n.createElement("p",null,"As we can see, the scope of transparency becomes exponentially more difficulty with increasing complexity. This is why transparent objects aren't abundantly found in video games, where real-time rendering is crucial for a good experience."),n.createElement("p",null,"The"," ",n.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/",target:"_blank",rel:"noopener noreferrer"},"transparency chapter")," ","of"," ",n.createElement("a",{href:"https://www.opengl-tutorial.org/",target:"_blank",rel:"noopener noreferrer"},"OpenGL Tutorial")," ","does provide possible steps that can be taken to reduce the performance impact, and also provides links on order-independent transparency techniques that can achieve the same effect, although they are not simple to implement."),n.createElement("p",null,"There are also other possible configuration options to use that don't have such performance degrading requirements, but each blending algorithm produces a different output, so we recommend experimenting to see which configuration works best for your use-case."),n.createElement(A.A,{type:"h2"},"Summary"),n.createElement("ul",null,n.createElement("li",null,"Transparency on the shader side is simple to add, through the use of the 4th component of the color value, which represents the alpha (or opacity) of the color."),n.createElement("li",null,"The GPU needs to be told how colors should be blended together to form a final color. This is required for color transparency, since translucent colors need to be blended to form a resultant."),n.createElement("li",null,"While graphics APIs have multiple functions to blend colors in various ways, some of these have caveats that can cause significant performance degregation if an accurate result is required."),n.createElement("li",null,"To learn more about how transparency in various graphics APIs, check out the links below:",n.createElement("ul",null,n.createElement("li",null,n.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/",target:"_blank",rel:"noopener noreferrer"},"OpenGL/WebGL"),"."),n.createElement("li",null,n.createElement("a",{href:"http://www.directxtutorial.com/Lesson.aspx?lessonid=9-4-10",target:"_blank",rel:"noopener noreferrer"},"DirectX"),"."))))),n.createElement(S.A,{previous:"/advanced/color-banding-dithering/",next:"/advanced/shadow-mapping/"}))}}}]);
//# sourceMappingURL=component---src-pages-advanced-transparency-js-e021338a2ee4192d4a2e.js.map