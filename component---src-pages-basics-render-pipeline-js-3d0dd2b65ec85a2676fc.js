"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[572],{6042:function(e,t,i){i.d(t,{A:function(){return n}});var a=i(6540);var n=e=>{let{type:t,children:i}=e;const n=t,r=t[1]+"-"+i.toString().trim().toLowerCase().replace(/\s+/g,"-").replace(/[^\w\-]+/g,"").replace(/\-\-+/g,"-").replace(/^-+/,"").replace(/-+$/,"");return a.createElement(n,{id:r},i,a.createElement("a",{href:"#"+r,"aria-label":'Link to section "'+i+'"'},a.createElement("img",{alt:"",role:"presentation",src:"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"})))}},2007:function(e,t,i){var a=i(4794),n=i(6540);const r=e=>{let{previous:t,next:i}=e;return n.createElement("div",{className:"page-change"},t?n.createElement("div",{className:"page-previous util text-left"},n.createElement(a.Link,{to:t},"← Previous Chapter")):null,i?n.createElement("div",{className:"page-next util text-right"},n.createElement(a.Link,{to:i},"Next Chapter →")):null)};r.defaultProps={previous:"",next:""},t.A=r},1806:function(e,t,i){i.r(t);var a=i(2532),n=i(6540),r=i(9460),l=i(6042),s=i(7570),o=i(2007),h=i(2269);t.default=e=>{let{location:{pathname:t}}=e;return n.createElement(s.A,null,n.createElement(h.A,{pathname:t,title:"Shader Basics - The GPU Render Pipeline",description:"A look into the GPU render pipeline and how it renders images.",keywords:["shader","basics","gpu","render","pipeline"]}),n.createElement(r.A,null,n.createElement("h1",null,"Shader Basics - The GPU Render Pipeline"),n.createElement("p",null,"GPUs, when rendering images, primarily work on a set of vertex data. If we have an object (for example, a teapot) that we wish to render an image of, the teapot first needs to be divided into small components called primitives."),n.createElement("p",null,"Primitives are basic shapes that can, when combined together, form objects. Like how atoms are the building blocks of physical objects, primitives can be considered the building blocks of digital objects."),n.createElement("p",null,"A primitive can be described by the vertices of that primitive, along with certain other information."),n.createElement("p",null,"So in order to tell the GPU to render an object, we have to provide the GPU the set of vertices that describe the primitives forming that object, along with what kind of primitives do the vertices form."),n.createElement("p",null,"Only one kind of primitive is generally used to form objects, although multiple can technically be used."),n.createElement("p",null,"Along with this, the GPU is also provided with a shader program that will aid the GPU in interpreting this data and visualizing it."),n.createElement("p",null,"The GPU is then told to perform an operation. It goes through a render pipeline, starting multiple instances of the shader program to process the data in parallel, processing the data during intermediate stages as required, and finally outputting a rendered image."),n.createElement("p",null,"Below is an overview of the render pipeline, showing the stages the GPU goes through to render the final image (note that stages in blue are programmable, stages in yellow are not):"),n.createElement("div",{className:"util text-center"},n.createElement(a.S,{src:"../../images/basics/render-pipeline-1.png",alt:"Render Pipeline Visual",style:{maxWidth:"65%"},__imageData:i(7474)}),n.createElement("br",null),n.createElement("a",{href:"https://www.khronos.org/opengl/wiki/File:RenderingPipeline.png",target:"_blank",rel:"noopener noreferrer"},"Source")),n.createElement("p",null,"This may seem a little daunting at first, but let's walk through it step by step:"),n.createElement("dl",null,n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Vertex Specification")),n.createElement("dd",null,n.createElement("p",null,"This is the set of data that the GPU will be working with. For rendering, the GPU primarily works with a set of vertices."),n.createElement("p",null,"Additional data can be be sent as well, but they have to be constant for all vertices passed to the GPU, or need to have a 1-to-1 relation with the vertices (each piece of data should relate to a vertex and vice-versa).")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Vertex Shader")),n.createElement("dd",null,n.createElement("p",null,'This is the first shader that is executed on the data provided to the GPU. It receives a single vertex as an input and provides a coordinate in "clip-space" as an output. More of this will be discussed in the chapter on the basics of the vertex shader.')),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Tesellation")),n.createElement("dd",null,n.createElement("p",null,'Tessellation is an optional stage that can be performed on the resultant vertices with their coordinates to determine and "tessellate" the object being rendered. Tessellation is the process of splitting a primitive into sub-primitives in order to improve detail.'),n.createElement("p",null,"The tessellation stage consists of two shaders, one that determines if a primitive needs to be tessellated, and one that performs the actual tessellation.")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Geometry Shader")),n.createElement("dd",null,n.createElement("p",null,"This is an optional shader that can receive a set of primitives, and outputs a set of primitives that can be same or different to the ones received by it."),n.createElement("p",null,"This is useful for a variety of tasks, from"," ",n.createElement("a",{href:"https://upvoid.com/devblog/2013/02/prototype-grass/",rel:"noopener noreferrer",target:"_blank"},"generating grass on terrain geometry")," ","to creating"," ",n.createElement("a",{href:"https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch11.html",rel:"noopener noreferrer",target:"_blank"},"volumetric shadows"),".")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Vertex Post-Processing")),n.createElement("dd",null,n.createElement("p",null,"In this stage, the results from the processing done in the previous stages is saved in a separate buffer, allowing the results to be operated on by the initial stages as a feedback loop, or letting the CPU read the results."),n.createElement("p",null,"The data of the output from the previous stages is in the same order as the input data provided to it, so that the input data and output result can be related easily."),n.createElement("p",null,"The output undergoes clipping after the previous step, where every primitive completely outside the view of the screen is removed, every primitive completely inside is kept, and primitives in between are subdivided in such a way that they split into primitives that are completely outside and inside, allowing for the unneeded parts of the primitive to be removed.")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Primitive Assembly")),n.createElement("dd",null,n.createElement("p",null,"This stages takes the primitives that have to be rendered and splits them up into simple/base primitives (points, lines, or triangles). The reason for this is because these are the simplest and sets of primitives that the GPU can work with, as well as being the smallest type (they cannot be represented by shapes with fewer vertices)."),n.createElement("p",null,"Culling is performed during this stage as well, to remove base primitives that won't be rendered onto the screen.")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Rasterization")),n.createElement("dd",null,n.createElement("p",null,"The final primitives are broken down into small samples called fragments, which contain information that is used to color the pixels of the rendered image. More of this will be discussed in the chapter on the basics of the fragment shader.")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Fragment Shader")),n.createElement("dd",null,n.createElement("p",null,"This shader processes the fragments generated by the rasterization process and determines what the color of each fragment is, which contributes to the final color of the pixel the fragment is under. More of this will be discussed in the chapter on the basics of the fragment shader."),n.createElement("p",null,"This stage is ",n.createElement("em",null,"*technically*")," optional, but it is required if you want to render an actual image with some color.")),n.createElement("dt",null,n.createElement(l.A,{type:"h3"},"Per-Sample Operations")),n.createElement("dd",null,n.createElement("p",null,"This the final stage that consists of multiple tests in order to remove fragments that are not part of the final image. The tests are:"),n.createElement("ul",null,n.createElement("li",null,n.createElement("strong",null,"Pixel ownership test"),': Tests if the pixel the fragment is under is "owned" by the renderer (applicable in cases where a window is overlapping the view).'),n.createElement("li",null,n.createElement("strong",null,"Scissor test"),": Tests if the fragment lies within a specific section of the screen."),n.createElement("li",null,n.createElement("strong",null,"Stencil test"),": An optional test that, when enabled, checks if the fragment is blocked by a stencil image/mask."),n.createElement("li",null,n.createElement("strong",null,"Depth test"),": Tests if the fragment's is below or above certain fragments, and whether they need to be discarded accordingly.")),n.createElement("p",null,"A certain number of these steps can be performed before running the fragment shader under certain conditions to improve performance."),n.createElement("p",null,"After the tests are completed, the final color of the pixel is determined by blending the colors of all fragments part of the pixel that passed the tests."),n.createElement("p",null,"The result is then copied to a framebuffer, which is a buffer of the generated image, and can either be copied from the GPU by the CPU, or sent to the monitor to show to the user."))),n.createElement("p",null,"The flow of the pipeline also allows for data to be passed from certain shaders to others, which can be used in interesting ways, which will be explored later."),n.createElement("p",null,"Understanding how a GPU renders is important, since this helps understand the purpose of each type of shader and why they perform the operations that they do."),n.createElement("p",null,"To learn about the graphics rendering pipeline in a lot more detail, check out"," ",n.createElement("a",{href:"https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/",rel:"noopener noreferrer",target:"_blank"},"A trip through the Graphics Pipeline 2011"),"."),n.createElement("p",null,"The basics section will be focusing primarily on vertex shaders and fragment shaders, which are vital for rendering an image on to the screen, or onto a buffer for use later. The next chapter will begin with the vertex shader.")),n.createElement(o.A,{previous:"/basics/introduction/",next:"/basics/mathematics/"}))}},7474:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/9ee5b6351feed1e3d4dae3e84ab1e993/4ee37/render-pipeline-1.png","srcSet":"/static/9ee5b6351feed1e3d4dae3e84ab1e993/3f327/render-pipeline-1.png 68w,\\n/static/9ee5b6351feed1e3d4dae3e84ab1e993/38f02/render-pipeline-1.png 136w,\\n/static/9ee5b6351feed1e3d4dae3e84ab1e993/4ee37/render-pipeline-1.png 271w","sizes":"(min-width: 271px) 271px, 100vw"},"sources":[{"srcSet":"/static/9ee5b6351feed1e3d4dae3e84ab1e993/28d95/render-pipeline-1.webp 68w,\\n/static/9ee5b6351feed1e3d4dae3e84ab1e993/5bfa6/render-pipeline-1.webp 136w,\\n/static/9ee5b6351feed1e3d4dae3e84ab1e993/a3d06/render-pipeline-1.webp 271w","type":"image/webp","sizes":"(min-width: 271px) 271px, 100vw"}]},"width":271,"height":602}')}}]);
//# sourceMappingURL=component---src-pages-basics-render-pipeline-js-3d0dd2b65ec85a2676fc.js.map