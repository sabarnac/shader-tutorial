{"version":3,"file":"component---src-pages-basics-vertex-shader-js-20b0689037b79db2d450.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/basics/vertex-shader/common/fragment.glsl","webpack://shader-tutorial/./src/components/basics/vertex-shader/first-example-shaders.js","webpack://shader-tutorial/./src/components/basics/vertex-shader/first-example/vertex.glsl","webpack://shader-tutorial/./src/components/basics/vertex-shader/first-example.js","webpack://shader-tutorial/./src/components/basics/vertex-shader/second-example-shaders.js","webpack://shader-tutorial/./src/components/basics/vertex-shader/second-example/vertex.glsl","webpack://shader-tutorial/./src/components/basics/vertex-shader/second-example.js","webpack://shader-tutorial/./src/pages/basics/vertex-shader.js"],"sourcesContent":["export default \"void main() {\\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\\n}\";","import fragmentShader from \"!raw-loader!./common/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./first-example/vertex.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst triangleModelPosition = mat4.create();\n\nconst VertexShaderFirstExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [triangleBuffer, updateTriangleBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        triangleModelPosition,\n        true,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateTriangleBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          triangleBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(triangleBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              modelMatrix,\n            );\n\n            gl.drawArrays(gl.LINE_LOOP, 0, triangle.vertices.length);\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [triangleBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nTriangle Vertices:\n    Vertex 1: ${coordArrToString(triangle.vertices[0])}\n    Vertex 2: ${coordArrToString(triangle.vertices[1])}\n    Vertex 3: ${coordArrToString(triangle.vertices[2])}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(VertexShaderFirstExample);\n","import fragmentShader from \"!raw-loader!./common/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./second-example/vertex.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float time;\\n\\nconst float PI = 3.1415926535897932384626433832795;\\n\\nmat4 rotateZ(float angle) {\\n  mat4 rotationMatrix;\\n  rotationMatrix[0] = vec4(cos(angle), sin(angle), 0, 0);\\n  rotationMatrix[1] = vec4(-sin(angle), cos(angle), 0, 0);\\n  rotationMatrix[2] = vec4(0, 0, 1, 0);\\n  rotationMatrix[3] = vec4(0, 0, 0, 1);\\n  return rotationMatrix;\\n}\\n\\nvoid main() {\\n  float angleRadians = (time / 30.0) * PI / 180.0;\\n  mat4 rotatedModelMatrix = rotateZ(angleRadians) * modelMatrix;\\n  gl_Position = projectionMatrix * viewMatrix * rotatedModelMatrix * vertexPosition;\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n      time: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst triangleModelPosition = mat4.create();\n\nconst VertexShaderSecondExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [triangleBuffer, updateTriangleBuffer] = useState({ vertices: null });\n\n  const [time, updateTime] = useState(\n    typeof performance !== \"undefined\" ? performance.now() : 0.0,\n  );\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        triangleModelPosition,\n        true,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateTriangleBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          triangleBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(triangleBuffer.vertices !== null, () => {\n      let shouldRender = true;\n      let then = parseInt(\n        typeof performance !== \"undefined\"\n          ? performance.now()\n          : (0.0).toString(),\n      );\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const currentTime = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            if (currentTime - then > 100) {\n              then = currentTime;\n              updateTime(currentTime);\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              modelMatrix,\n            );\n            gl.uniform1f(shaderInfo.vertex.uniformLocations.time, currentTime);\n\n            gl.drawArrays(gl.LINE_LOOP, 0, triangle.vertices.length);\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [triangleBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nTriangle Vertices:\n    Vertex 1: ${coordArrToString(triangle.vertices[0])}\n    Vertex 2: ${coordArrToString(triangle.vertices[1])}\n    Vertex 3: ${coordArrToString(triangle.vertices[2])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">Time: {time}</pre>\n    </div>\n  );\n};\n\nexport default wrapExample(VertexShaderSecondExample);\n","import { Link } from \"gatsby\";\nimport React from \"react\";\n\nimport VertexShaderFirstExample from \"../../components/basics/vertex-shader/first-example\";\nimport { firstVertexShaderSource } from \"../../components/basics/vertex-shader/first-example-shaders\";\nimport VertexShaderSecondExample from \"../../components/basics/vertex-shader/second-example\";\nimport { secondVertexShaderSource } from \"../../components/basics/vertex-shader/second-example-shaders\";\nimport Content from \"../../components/content\";\nimport Equation from \"../../components/equation/equation\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst VertexShaderPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Basics - Vertex Shader\"\n      description=\"A look into the basics of a GPU vertex shader.\"\n      keywords={[\"vertex\", \"shader\", \"basics\"]}\n    />\n    <Content>\n      <h1>Shader Basics - Vertex Shader</h1>\n      <Heading type=\"h2\">What is a vertex shader</Heading>\n      <p>\n        Vertex shaders process vertices and tells what their coordinates are in\n        \"clip-space\", which is a space that makes it easy for computers to\n        understand which vertices are visible to the camera and which are not\n        and have to be cut or \"clipped\" out.\n      </p>\n      <p>\n        This makes it faster for GPUs during later stages since they have less\n        data to work with.\n      </p>\n      <p>\n        They perform this process by receiving a single vertex from the list of\n        vertices as input, and return a result that determines where the vertex\n        should be present within clip-space,\n      </p>\n      <p>\n        Since this shader is executed per vertex on all vertices passed to the\n        GPU pipeline, any operation that requires modifications to the vertex\n        can be performed during in this shader, as long as the final output is\n        where the vertex is to be placed in the clip-space.\n      </p>\n      <Heading type=\"h2\">An example - A triangle</Heading>\n      <p>Below is an example of the work simple vertex shader:</p>\n      <VertexShaderFirstExample />\n      <p>\n        We can see that, for a provided set of vertex positions, a shape is\n        drawn. The points on the canvas where the vertices are placed is\n        determined by the vertex shader (in part).\n      </p>\n      <Heading type=\"h3\">How it works</Heading>\n      <p>Let's look at the code for the vertex shader</p>\n      <GlslCodeHighlight\n        code={firstVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <p>\n        Even though this is WebGL (which is similar to OpenGL), the concepts\n        applied here can be mapped across other languages as well.\n      </p>\n      <p>\n        The <code>void main</code> function is the primary function that is\n        executed when the vertex shader (and any shader for that matter) is to\n        executed, and should contain the primary shader code to be executed.\n        This is similar to C/C++, where the <code>main</code> function in the\n        primary entry is the one that is executed when starting the application.\n      </p>\n      <p>\n        The <code>vertexPosition</code> attribute is a property that receives\n        the initial coordinates of vertex as it's primary input, the one that it\n        should transform into the final clip-space coordinates.\n      </p>\n      <p>\n        It is defined as an attribute as it is a description of a certain\n        \"attribute\" of the vertex (in this case, its position), can change based\n        on which vertex is being operated on, and are always read-only.\n      </p>\n      <p>\n        Do note that the type of it is set to <code>vec4</code>, which means\n        it's a vector of size 4, but vertices passed to the vertex shader need\n        not be limited to just this type, but a <code>vec4</code> type would\n        provide the most detail about the coordinates of a vertex.\n      </p>\n      <p>\n        The <code>modelMatrix</code>, <code>viewMatrix</code>, and{\" \"}\n        <code>projectionMatrix</code> uniforms are additional properties passed\n        separately to the vertex shader. Unlike the <code>vertexPosition</code>{\" \"}\n        attribute, these values need to be the same for every vertex of the\n        object/primitive operated on, which is why it's defined as uniform (it's\n        uniform/same for every data being operated on by shaders).\n      </p>\n      <p>\n        Similar to the <code>vertexPosition</code> attribute, the types of these\n        uniforms is <code>mat4</code>, which means a matrix of size 4x4. Again,\n        they need not be limited to this type, and can be a matrix of size upto\n        4x4, or even a vector of size upto 4.\n      </p>\n      <p>Here's a simple explanation of the uniform variables being used:</p>\n      <dl>\n        <dt>\n          1. <strong>modelMatrix</strong>\n        </dt>\n        <dd>\n          <p>\n            This matrix is used to represent where the vertex exists within the\n            world. It represents the center of the model being drawn by the\n            shader, which has been translated, rotated, and/or scaled into the\n            necessary position in the world.\n          </p>\n          <p>\n            Multiplying the vertex coordinate with this matrix will provide the\n            result of where the vertex exists in the world w.r.t. to the center\n            of the model it belongs to.\n          </p>\n        </dd>\n        <dt>\n          2. <strong>viewMatrix</strong>\n        </dt>\n        <dd>\n          <p>\n            This matrix is used to represent where the vertex exists relative to\n            your view, or more specifically the cameras view. Once the vertex\n            position is known in the world (by multiplying it with the{\" \"}\n            <code>modelMatrix</code>), it's position relative to the camera can\n            be determined by multiplying it with this matrix.\n          </p>\n        </dd>\n        <dt>\n          3. <strong>projectionMatrix</strong>\n        </dt>\n        <dd>\n          <p>\n            This matrix is used to represent the perspective of the camera.\n            Things like field-of-view, aspect ratio, and others can distort and\n            affect the way objects look. Likewise, the scale of objects can\n            differ depending on distance, which needs to be accounted for.\n          </p>\n          <p>\n            By multiplying the projection matrix onto the result of the previous\n            calculations, we are able to map the vertex onto the perspective of\n            the camera, taking into account it's aspect ratio, field-of-view,\n            and the farthest and closest it can see.\n          </p>\n          <p>\n            This final calculation provides us the coordinates of the vertex in\n            clip-space.\n          </p>\n        </dd>\n      </dl>\n      <p>\n        From the above explanation, it should be more obvious why the operation\n        on line 8 in the vertex shader is performed.\n      </p>\n      <ol>\n        <li>\n          The vertex position is taken and multiplied with the model matrix to\n          determine where that vertex lies w.r.t the center of the model in the\n          world.\n        </li>\n        <li>\n          The result is then multiplied with the view matrix to determine where\n          the vertex is positioned w.r.t the camera\n        </li>\n        <li>\n          Finally the result of the second operation is multiplied with the\n          projection matrix to determine where the vertex is located within the\n          perspective of the camera.\n        </li>\n      </ol>\n      <p>\n        This final result is the output of the vertex shader, which, in WebGL,\n        is stored in the special variable <code>gl_Position</code>.\n      </p>\n      <Heading type=\"h2\">Another example - A rotating triangle</Heading>\n      <p>\n        Since the vertex shader determines where each vertex is w.r.t the\n        perspective-space of the screen, by passing it the necessary\n        transformations to apply to the vertices, it can move their positions as\n        required.\n      </p>\n      <VertexShaderSecondExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={secondVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <p>\n        The time elapsed since the start of the animation is passed to the\n        vertex shader. From this, the angle is calculated by dividing the\n        elapsed time by 30, so that a degree turn occurs every 30ms.\n      </p>\n      <p>\n        This angle is calculated in degrees, which needs to be converted to\n        radians, which is done by mulitplying the angle by{\" \"}\n        <Equation text={`pi`} /> and dividing the product by 180.\n      </p>\n      <p>\n        By keeping the calculations in float, we don't round of the decimals,\n        ensuring that the angle always changes (primarily in the fractional\n        part) with every frame. The function\n      </p>\n      <p>\n        This angle is then used to create a rotation matrix. The function{\" \"}\n        <code>rotateZ</code> creates a rotation matrix that rotates around the\n        Z-axis. The details about this matrix is in the reference link provided\n        in the matrix mathematics section of the{\" \"}\n        <Link to=\"/basics/mathematics/\">mathematics primer</Link> chapter.\n      </p>\n      <p>\n        The rotation matrix is multiplied with the model matrix to rotate the\n        entire model according to the time elapsed. Then the same process as\n        with the previous example is followed to calculate the final coordinates\n        of the vertex.\n      </p>\n      <Heading type=\"h2\">Additional Notes</Heading>\n      <p>\n        This rotation matrix can be more easily created outside the shader since\n        there are utility libraries that provide helper functions for performing\n        such operations (OpenGL has the GLM library for such tasks).\n      </p>\n      <p>\n        However, for the sake of understanding how the rotation works, it is\n        shown within the shader.\n      </p>\n      <p>\n        We also calculate the multiplication of the model, view, and projection\n        matrix within the vertex shader itself. This is a calculation whose\n        result never changes for any vertex.\n      </p>\n      <p>\n        Since the result of the calculation is a constant, it can be done once\n        outside the GPU and then passed as a <code>uniform</code> to the vertex\n        shader. This optimization will be done in future examples and chapters.\n      </p>\n      <p>\n        This will be visible in vertex shaders where we pass an{\" \"}\n        <code>uniform</code> called <code>mvpMatrix</code>, which is the\n        multiplication product of the model, view, and projection matrices. Any\n        additional transformations (like rotations) will also be calculated\n        beforehand and then passed through this uniform.\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          The vertex shader receives a vertex from a list of vertices and plots\n          it onto a space known as the clip-space.\n        </li>\n        <li>\n          The vertex shader requires certain values provided to it about the\n          model, view, and projection, in order to be able to determine where\n          the final position of the vertex is.\n        </li>\n        <li>\n          Since the shader determines where the vertex is present within this\n          space, it can manipulate and transform the vertex to be placed\n          wherever required.\n        </li>\n      </ul>\n    </Content>\n    <PageChange previous=\"/basics/mathematics/\" next=\"/basics/color/\" />\n  </Layout>\n);\n\nexport default VertexShaderPage;\n"],"names":["firstVertexShaderSource","firstFragmentShaderSource","fragmentShader","shaderProgramInfo","vertex","attributeLocations","vertexPosition","uniformLocations","modelMatrix","viewMatrix","projectionMatrix","fragment","triangleModelPosition","mat4","wrapExample","VertexShaderFirstExample","triangle","vertices","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","triangleBuffer","updateTriangleBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","shouldRender","renderScene","_ref","gl","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","useProgram","uniformMatrix4fv","drawArrays","LINE_LOOP","length","requestAnimationFrame","React","className","style","padding","width","height","ref","coordArrToString","trim","secondVertexShaderSource","secondFragmentShaderSource","time","VertexShaderSecondExample","updateTime","performance","now","then","parseInt","toString","currentTime","uniform1f","location","pathname","Layout","Seo","title","description","keywords","Content","Heading","type","GlslCodeHighlight","code","Equation","text","Link","to","PageChange","previous","next"],"sourceRoot":""}