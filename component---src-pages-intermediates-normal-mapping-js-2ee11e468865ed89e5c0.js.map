{"version":3,"file":"component---src-pages-intermediates-normal-mapping-js-2ee11e468865ed89e5c0.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/intermediates/normal-mapping/first-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/first-example.js","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/first-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/first-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/second-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/second-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/second-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/second-example.js","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/third-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/third-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/third-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/normal-mapping/third-example.js","webpack://shader-tutorial/./src/pages/intermediates/normal-mapping.js","webpack://shader-tutorial/./src/images/intermediates/normal.png","webpack://shader-tutorial/./src/images/intermediates/texture-2.png"],"sourcesContent":["import vertexShader from \"!raw-loader!./first-example/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./first-example/fragment.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture-2.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec3\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n      specularLobeFactor: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      specularReflectivity: \"float\",\n      diffuseTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 0.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(1.0, 1.0, 1.0);\nconst lightIntensity = 50.0;\n\nconst squareModelPosition = mat4.create();\n\nconst NormalMappingFirstExample = () => {\n  const square = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n    uvs: [\n      [0.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [1.0, 0.0],\n    ],\n    normals: [\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n    ],\n    indices: [[0, 1, 2, 3, 4, 5]],\n    texture: texture,\n    specularReflectivity: 0.3,\n    specularLobeFactor: 5.0,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [squareBuffer, updatesquareBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        squareModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updatesquareBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          square.vertices.flat(),\n          squareBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          square.uvs.flat(),\n          squareBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          square.normals.flat(),\n          squareBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          square.indices.flat(),\n          squareBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(\n          square.texture,\n          squareBuffer.texture,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(squareBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (30 * Math.PI) / 180;\n            mat4.translate(rotatedModelMatrix, modelMatrix, [0.0, 0.0, 2.0]);\n            mat4.rotateY(rotatedModelMatrix, rotatedModelMatrix, rotationAngle);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.specularReflectivity,\n              square.specularReflectivity,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.specularLobeFactor,\n              square.specularLobeFactor,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, squareBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.diffuseTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              square.indices.length * square.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [squareBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nSquare:\n    World Position: ${coordArrToString([0.0, 0.0, 0.0])}\n    Lighting:\n        Specular Reflectivity: ${square.specularReflectivity}\n        Lobe Density: ${square.specularLobeFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(NormalMappingFirstExample);\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\n\\nvarying highp vec2 uv;\\nvarying highp vec4 fragmentPosition_viewSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n  \\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\\n  fragmentNormal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  uv = vertexUv;\\n}\";","export default \"varying highp vec2 uv;\\nvarying highp vec4 fragmentPosition_viewSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\n\\nuniform highp mat4 viewMatrix;\\nuniform highp vec4 lightPosition_worldSpace;\\n\\nuniform highp vec3 lightColor;\\nuniform highp float lightIntensity;\\n\\nuniform highp float specularLobeFactor;\\nuniform highp float specularReflectivity;\\n\\nuniform sampler2D diffuseTextureSampler;\\n\\nvoid main() {\\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\\n\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - cameraPosition_viewSpace);\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\\n\\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, fragmentNormal_viewSpace);\\n\\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\\n\\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\\n  gl_FragColor.a = diffuseColor.a;\\n}\";","import vertexShader from \"!raw-loader!./second-example/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./second-example/fragment.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\nattribute vec3 vertexTangent;\\nattribute vec3 vertexBiTangent;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying highp vec2 uv;\\nvarying highp mat3 tbnMatrix_viewSpace;\\nvarying highp vec4 fragmentPosition_viewSpace;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\\n  uv = vertexUv;\\n\\n  highp mat3 modelViewMatrix_3x3 = mat3(viewMatrix * modelMatrix);\\n  highp vec3 vertexTangent = normalize(vertexTangent);\\n  highp vec3 vertexBiTangent = normalize(vertexBiTangent);\\n  highp vec3 vertexNormal = normalize(vertexNormal);\\n\\n  tbnMatrix_viewSpace = modelViewMatrix_3x3 * mat3(\\n    vertexTangent,\\n    vertexBiTangent,\\n    vertexNormal\\n  );\\n}\";","export default \"varying highp vec2 uv;\\nvarying highp mat3 tbnMatrix_viewSpace;\\nvarying highp vec4 fragmentPosition_viewSpace;\\n\\nuniform highp mat4 viewMatrix;\\nuniform highp vec4 lightPosition_worldSpace;\\n\\nuniform highp vec3 lightColor;\\nuniform highp float lightIntensity;\\n\\nuniform highp float specularLobeFactor;\\nuniform highp float specularReflectivity;\\n\\nuniform sampler2D diffuseTextureSampler;\\nuniform sampler2D normalTextureSampler;\\n\\nvoid main() {\\n  highp vec4 normalColor = texture2D(normalTextureSampler, uv);\\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\\n\\n  highp vec3 normal_viewSpace = tbnMatrix_viewSpace * normalize((normalColor.xyz * 2.0) - 1.0);\\n\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - cameraPosition_viewSpace);\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\\n\\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  highp vec3 diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, normal_viewSpace);\\n\\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\\n\\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\\n  gl_FragColor.a = diffuseColor.a;\\n}\";","import { mat4, vec2, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport normalTexture from \"../../../images/intermediates/normal.png\"\nimport texture from \"../../../images/intermediates/texture-2.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec3\",\n      vertexTangent: \"vec3\",\n      vertexBiTangent: \"vec3\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n      specularLobeFactor: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      specularReflectivity: \"float\",\n      diffuseTextureSampler: \"sampler2D\",\n      normalTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 0.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(1.0, 1.0, 1.0);\nconst lightIntensity = 50.0;\n\nconst squareModelPosition = mat4.create();\n\nconst NormalMappingSecondExample = () => {\n  const square = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n    uvs: [\n      [0.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [1.0, 0.0],\n    ],\n    normals: [\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n    ],\n    tangents: [],\n    biTangents: [],\n    indices: [[0, 1, 2, 3, 4, 5]],\n    texture: texture,\n    normalTexture: normalTexture,\n    specularReflectivity: 0.3,\n    specularLobeFactor: 5.0,\n  };\n  for (let i = 0; i < square.vertices.length; i += 3) {\n    const v0 = vec3.clone(square.vertices[i + 0]);\n    const v1 = vec3.clone(square.vertices[i + 1]);\n    const v2 = vec3.clone(square.vertices[i + 2]);\n\n    const uv0 = vec2.clone(square.uvs[i + 0]);\n    const uv1 = vec2.clone(square.uvs[i + 1]);\n    const uv2 = vec2.clone(square.uvs[i + 2]);\n\n    const deltaPos1 = vec3.subtract(vec3.create(), v1, v0);\n    const deltaPos2 = vec3.subtract(vec3.create(), v2, v0);\n\n    const deltaUv1 = vec2.subtract(vec2.create(), uv1, uv0);\n    const deltaUv2 = vec2.subtract(vec2.create(), uv2, uv0);\n\n    const r = 1.0 / (deltaUv1[0] * deltaUv2[1] - deltaUv1[1] * deltaUv2[0]);\n    const tangent = Array.from(\n      vec3.multiply(\n        vec3.create(),\n        vec3.subtract(\n          vec3.create(),\n          vec3.multiply(vec3.create(), deltaPos1, [\n            deltaUv2[1],\n            deltaUv2[1],\n            deltaUv2[1],\n          ]),\n          vec3.multiply(vec3.create(), deltaPos2, [\n            deltaUv1[1],\n            deltaUv1[1],\n            deltaUv1[1],\n          ]),\n        ),\n        [r, r, r],\n      ),\n    );\n    const biTangent = Array.from(\n      vec3.multiply(\n        vec3.create(),\n        vec3.subtract(\n          vec3.create(),\n          vec3.multiply(vec3.create(), deltaPos2, [\n            deltaUv1[0],\n            deltaUv1[0],\n            deltaUv1[0],\n          ]),\n          vec3.multiply(vec3.create(), deltaPos1, [\n            deltaUv2[0],\n            deltaUv2[0],\n            deltaUv2[0],\n          ]),\n        ),\n        [r, r, r],\n      ),\n    );\n\n    square.tangents.push(tangent, tangent, tangent);\n    square.biTangents.push(biTangent, biTangent, biTangent);\n  }\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [squareBuffer, updatesquareBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    tangents: null,\n    biTangents: null,\n    indices: null,\n    texture: null,\n    normalTexture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        squareModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updatesquareBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          square.vertices.flat(),\n          squareBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          square.uvs.flat(),\n          squareBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          square.normals.flat(),\n          squareBuffer.normals,\n        ),\n        tangents: webGlRef.createStaticDrawArrayBuffer(\n          square.tangents.flat(),\n          squareBuffer.tangents,\n        ),\n        biTangents: webGlRef.createStaticDrawArrayBuffer(\n          square.biTangents.flat(),\n          squareBuffer.biTangents,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          square.indices.flat(),\n          squareBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(\n          square.texture,\n          squareBuffer.texture,\n        ),\n        normalTexture: webGlRef.createImageTexture(\n          square.normalTexture,\n          squareBuffer.normalTexture,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(squareBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (30 * Math.PI) / 180;\n            mat4.translate(rotatedModelMatrix, modelMatrix, [0.0, 0.0, 2.0]);\n            mat4.rotateY(rotatedModelMatrix, rotatedModelMatrix, rotationAngle);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.tangents);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexTangent,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexTangent,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.biTangents);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexBiTangent,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexBiTangent,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.specularReflectivity,\n              square.specularReflectivity,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.specularLobeFactor,\n              square.specularLobeFactor,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, squareBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.diffuseTextureSampler,\n              0,\n            );\n\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, squareBuffer.normalTexture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.normalTextureSampler,\n              1,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              square.indices.length * square.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [squareBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nSquare:\n    World Position: ${coordArrToString([0.0, 0.0, 0.0])}\n    Lighting:\n        Specular Reflectivity: ${square.specularReflectivity}\n        Lobe Density: ${square.specularLobeFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(NormalMappingSecondExample);\n","import vertexShader from \"!raw-loader!./third-example/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./third-example/fragment.glsl\";\n\nexport const thirdVertexShaderSource = vertexShader;\nexport const thirdFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\nattribute vec3 vertexTangent;\\nattribute vec3 vertexBiTangent;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying highp vec2 uv;\\nvarying highp mat3 tbnMatrix_tangentSpace;\\nvarying highp vec3 fragmentPosition_tangentSpace;\\n\\nmat3 transpose(mat3 m) {\\n  return mat3(m[0][0], m[1][0], m[2][0],\\n              m[0][1], m[1][1], m[2][1],\\n              m[0][2], m[1][2], m[2][2]);\\n}\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  uv = vertexUv;\\n\\n  highp mat3 modelViewMatrix_3x3 = mat3(viewMatrix * modelMatrix);\\n  highp vec3 vertexTangent = normalize(vertexTangent);\\n  highp vec3 vertexBiTangent = normalize(vertexBiTangent);\\n  highp vec3 vertexNormal = normalize(vertexNormal);\\n\\n  tbnMatrix_tangentSpace = transpose(modelViewMatrix_3x3 * mat3(\\n    vertexTangent,\\n    vertexBiTangent,\\n    vertexNormal\\n  ));\\n\\n  fragmentPosition_tangentSpace = tbnMatrix_tangentSpace * (viewMatrix * vertexPosition_worldSpace).xyz;\\n}\";","export default \"varying highp vec2 uv;\\n\\nvarying highp mat3 tbnMatrix_tangentSpace;\\nvarying highp vec3 fragmentPosition_tangentSpace;\\n\\nuniform highp mat4 modelMatrix;\\nuniform highp mat4 viewMatrix;\\nuniform highp vec4 lightPosition_worldSpace;\\n\\nuniform highp vec3 lightColor;\\nuniform highp float lightIntensity;\\nuniform highp float specularReflectivity;\\nuniform highp float specularLobeFactor;\\n\\nuniform sampler2D diffuseTextureSampler;\\nuniform sampler2D normalTextureSampler;\\n\\nvoid main() {\\n  highp vec4 normalColor = texture2D(normalTextureSampler, uv);\\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\\n\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightPosition_tangentSpace = tbnMatrix_tangentSpace * lightPosition_viewSpace.xyz;\\n  highp vec3 lightDirection_tangentSpace = normalize(lightPosition_tangentSpace - fragmentPosition_tangentSpace);\\n\\n  highp vec3 normal_tangentSpace = normalize((normalColor.xyz * 2.0) - 1.0);\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(fragmentPosition_tangentSpace, lightPosition_tangentSpace);\\n\\n  highp float diffuseStrength = clamp(dot(normal_tangentSpace, lightDirection_tangentSpace), 0.0, 1.0);\\n  highp vec3 diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\\n  highp vec3 viewDirection_tangentSpace = normalize(fragmentPosition_tangentSpace.xyz - cameraPosition_viewSpace);\\n  highp vec3 lightReflection_tangentSpace = reflect(lightDirection_tangentSpace, normal_tangentSpace);\\n\\n  highp float specularStrength = clamp(dot(viewDirection_tangentSpace, lightReflection_tangentSpace), 0.0, 1.0);\\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\\n  \\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\\n  gl_FragColor.a = diffuseColor.a;\\n}\";","import { mat4, vec2, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport normalTexture from \"../../../images/intermediates/normal.png\"\nimport texture from \"../../../images/intermediates/texture-2.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { thirdFragmentShaderSource, thirdVertexShaderSource } from \"./third-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec3\",\n      vertexTangent: \"vec3\",\n      vertexBiTangent: \"vec3\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n      specularLobeFactor: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      specularReflectivity: \"float\",\n      diffuseTextureSampler: \"sampler2D\",\n      normalTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 0.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(1.0, 1.0, 1.0);\nconst lightIntensity = 50.0;\n\nconst squareModelPosition = mat4.create();\n\nconst NormalMappingThirdExample = () => {\n  const square = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n    uvs: [\n      [0.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [0.0, 0.0],\n      [1.0, 1.0],\n      [1.0, 0.0],\n    ],\n    normals: [\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n    ],\n    tangents: [],\n    biTangents: [],\n    indices: [[0, 1, 2, 3, 4, 5]],\n    texture: texture,\n    normalTexture: normalTexture,\n    specularReflectivity: 0.3,\n    specularLobeFactor: 5.0,\n  };\n  for (let i = 0; i < square.vertices.length; i += 3) {\n    const v0 = vec3.clone(square.vertices[i + 0]);\n    const v1 = vec3.clone(square.vertices[i + 1]);\n    const v2 = vec3.clone(square.vertices[i + 2]);\n\n    const uv0 = vec2.clone(square.uvs[i + 0]);\n    const uv1 = vec2.clone(square.uvs[i + 1]);\n    const uv2 = vec2.clone(square.uvs[i + 2]);\n\n    const deltaPos1 = vec3.subtract(vec3.create(), v1, v0);\n    const deltaPos2 = vec3.subtract(vec3.create(), v2, v0);\n\n    const deltaUv1 = vec2.subtract(vec2.create(), uv1, uv0);\n    const deltaUv2 = vec2.subtract(vec2.create(), uv2, uv0);\n\n    const r = 1.0 / (deltaUv1[0] * deltaUv2[1] - deltaUv1[1] * deltaUv2[0]);\n    const tangent = Array.from(\n      vec3.multiply(\n        vec3.create(),\n        vec3.subtract(\n          vec3.create(),\n          vec3.multiply(vec3.create(), deltaPos1, [\n            deltaUv2[1],\n            deltaUv2[1],\n            deltaUv2[1],\n          ]),\n          vec3.multiply(vec3.create(), deltaPos2, [\n            deltaUv1[1],\n            deltaUv1[1],\n            deltaUv1[1],\n          ]),\n        ),\n        [r, r, r],\n      ),\n    );\n    const biTangent = Array.from(\n      vec3.multiply(\n        vec3.create(),\n        vec3.subtract(\n          vec3.create(),\n          vec3.multiply(vec3.create(), deltaPos2, [\n            deltaUv1[0],\n            deltaUv1[0],\n            deltaUv1[0],\n          ]),\n          vec3.multiply(vec3.create(), deltaPos1, [\n            deltaUv2[0],\n            deltaUv2[0],\n            deltaUv2[0],\n          ]),\n        ),\n        [r, r, r],\n      ),\n    );\n\n    square.tangents.push(tangent, tangent, tangent);\n    square.biTangents.push(biTangent, biTangent, biTangent);\n  }\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [squareBuffer, updatesquareBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    tangents: null,\n    biTangents: null,\n    indices: null,\n    texture: null,\n    normalTexture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        squareModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          thirdVertexShaderSource,\n          thirdFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updatesquareBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          square.vertices.flat(),\n          squareBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          square.uvs.flat(),\n          squareBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          square.normals.flat(),\n          squareBuffer.normals,\n        ),\n        tangents: webGlRef.createStaticDrawArrayBuffer(\n          square.tangents.flat(),\n          squareBuffer.tangents,\n        ),\n        biTangents: webGlRef.createStaticDrawArrayBuffer(\n          square.biTangents.flat(),\n          squareBuffer.biTangents,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          square.indices.flat(),\n          squareBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(\n          square.texture,\n          squareBuffer.texture,\n        ),\n        normalTexture: webGlRef.createImageTexture(\n          square.normalTexture,\n          squareBuffer.normalTexture,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(squareBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (30 * Math.PI) / 180;\n            mat4.translate(rotatedModelMatrix, modelMatrix, [0.0, 0.0, 2.0]);\n            mat4.rotateY(rotatedModelMatrix, rotatedModelMatrix, rotationAngle);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.tangents);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexTangent,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexTangent,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.biTangents);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexBiTangent,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexBiTangent,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.specularReflectivity,\n              square.specularReflectivity,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.specularLobeFactor,\n              square.specularLobeFactor,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, squareBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.diffuseTextureSampler,\n              0,\n            );\n\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, squareBuffer.normalTexture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.normalTextureSampler,\n              1,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              square.indices.length * square.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [squareBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nSquare:\n    World Position: ${coordArrToString([0.0, 0.0, 0.0])}\n    Lighting:\n        Specular Reflectivity: ${square.specularReflectivity}\n        Lobe Density: ${square.specularLobeFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(NormalMappingThirdExample);\n","import { Link } from \"gatsby\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport Content from \"../../components/content\";\nimport Equation from \"../../components/equation/equation\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport NormalMappingFirstExample from \"../../components/intermediates/normal-mapping/first-example\";\nimport NormalMappingSecondExample from \"../../components/intermediates/normal-mapping/second-example\";\nimport {\n  secondFragmentShaderSource,\n  secondVertexShaderSource,\n} from \"../../components/intermediates/normal-mapping/second-example-shaders\";\nimport NormalMappingThirdExample from \"../../components/intermediates/normal-mapping/third-example\";\nimport {\n  thirdFragmentShaderSource,\n  thirdVertexShaderSource,\n} from \"../../components/intermediates/normal-mapping/third-example-shaders\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst NormalMappingPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Intermediates - Normal Mapping\"\n      description=\"A look into the how normal map textures are used to add lighting detail to objects.\"\n      keywords={[\"normal\", \"mapping\", \"texturing\", \"shader\", \"intermediates\"]}\n    />\n    <Content>\n      <h1>Shader Intermediates - Normal Mapping</h1>\n      <p>\n        An issue with the lighting examples seen in the{\" \"}\n        <Link to=\"/intermediates/lighting/\">previous chapter on lighting</Link>{\" \"}\n        is that the entire surface of the object has a uniform appearance,\n        making it appear flat.\n      </p>\n      <Heading type=\"h2\">Example - Stone wall</Heading>\n      <NormalMappingFirstExample />\n      <p>\n        In the above example of the stone wall, we've applied our naive approach\n        to lighting the surface of the wall. The result is the appearance of a\n        wall with detailed color, but looking very flat due to the simple form\n        of lighting.\n      </p>\n      <p>\n        The wall shouldn't appear as flat since it has bumps, scratches,\n        grooves, etc. These interact with light in different ways resulting in a\n        surface that highlights the roughness and imperfections on it, giving it\n        \"depth\".\n      </p>\n      <p>\n        A similar situation was discussed and solved in the chapter on{\" \"}\n        <Link to=\"/intermediates/color-mapping/\">color mapping</Link>, where the\n        lack of color detail from vertex data was solved by passing color\n        information using a texture.\n      </p>\n      <p>\n        The same concept of mapping can be used to add better lighting detail\n        without increasing the complexity of the object. By changing the way the\n        light interacts with the surface using a texture, the wall can be made\n        to appear rough instead of smooth and flat.\n      </p>\n      <Heading type=\"h2\">Why store normals in a map?</Heading>\n      <p>\n        If we look into the{\" \"}\n        <Link to=\"/intermediates/lighting/\">lighting chapter</Link>, we see that\n        there are three main components being used to describe the object\n        through its vertices.\n      </p>\n      <ul>\n        <li>The vertex position.</li>\n        <li>The vertex UV coordinates.</li>\n        <li>The vertex normal.</li>\n      </ul>\n      <p>\n        Among these, the main component that affects the factor of lighting on\n        an object is the vertex normal.\n      </p>\n      <p>\n        The reason for this is simple - the normal of a surface defines what\n        direction the surface is facing, which is important for lighting.\n      </p>\n      <p>\n        Since the direction of the surface determines what amount of and how\n        light will bounce and fall onto your eyes, this value can affect how a\n        surface looks.\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/surface-1.png\"\n          alt=\"Smooth Surface Light Reflection\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        With a smooth surface, all points on the surface have their normals\n        pointing in the same direction. This means that light falling on the\n        surface bounces and reflects in the exact same manner across it, giving\n        it a flat appearance, similar to the wall example seen above.\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/surface-2.png\"\n          alt=\"Rough Surface Light Reflection\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        In contrast, a rough and bumpy surface has points with normals pointing\n        towards different directions. This results in certain spots reflecting a\n        lot more light towards the users view, while other spots reflect less,\n        or completely reflect light away from the users view.\n      </p>\n      <p>\n        We can mimic the look of a rough surface by defining the normals of each\n        point through the use of a texture, similar to how the color of each\n        point of a surface was defined the same way in the{\" \"}\n        <Link to=\"/intermediates/color-mapping/\">color mappping</Link> chapter.\n      </p>\n      <p>\n        This provides the ability to generate lighting detail similar to if the\n        object was modeled with its roughness described through polygons, but\n        without the additional complexity and processing to deal with those\n        polygons.\n      </p>\n      <p>\n        Just like with a diffuse map, a texture map used to describe the normals\n        of an object is called a normal map, and the process of mapping normals\n        of a fragment from a texture is called normal mapping.\n      </p>\n      <Heading type=\"h2\">Normal Maps</Heading>\n      <p>The texture maps that will be used to color and light the wall are:</p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/texture-2.png\"\n          alt=\"Stone Wall - Diffuse Map\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        Diffuse map\n        <br />\n        <a\n          href=\"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/normal.png\"\n          alt=\"Stone Wall - Normal Map\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        Normal map\n        <br />\n        <a\n          href=\"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        The normal map is an image that contains the following information per\n        pixel:\n      </p>\n      <ul>\n        <li>\n          The value of the normals are stored in the map as their unit vectors.\n        </li>\n        <li>\n          The x-axis component of the normal is encoded as the red color of the\n          pixel, with the color values 0 to 255 (0.0 - 1.0 in float) mapping\n          into the range -1 to 1 on the x-axis.\n        </li>\n        <li>\n          The y-axis component of the normal is encoded as the green color of\n          the pixel, with the color values 0 to 255 (0.0 - 1.0 in float) mapping\n          into the range -1 to 1 on the y-axis.\n        </li>\n        <li>\n          The z-axis component of the normal is encoded as the blue color of the\n          pixel, with the color values 128 to 255 (0.5 - 1.0 in float) mapping\n          into the range 0 to 1 on the z-axis.\n        </li>\n      </ul>\n      <p>\n        The reason why the z-axis is mapped only in the positive range is\n        because any normal with a negative z-axis value is a direction that is\n        pointing away from the view of the user, meaning that it would never be\n        visible to the user anyways.\n      </p>\n      <p>\n        The values of the normals in the normal map are stored in a 2.5D space\n        called \"tangent-space\".\n      </p>\n      <Heading type=\"h3\">Tangent-Space</Heading>\n      <p>\n        Consider a sphere. A plane (a flat 2D surface) is considered \"tangent\"\n        to a point on the sphere if the plane only touches the sphere at that\n        point and not at any other neighbouring points.\n      </p>\n      <p className=\"util text-center\">\n        <img\n          src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Image_Tangent-plane.svg/2560px-Image_Tangent-plane.svg.png\"\n          alt=\"Wikipedia Tangent Plane Example\"\n          style={{ width: \"65%\" }}\n        />\n        <br />\n        <a\n          href=\"https://en.wikipedia.org/wiki/Tangent#/media/File:Image_Tangent-plane.svg\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n        <br />\n        <small>\n          The plane shown here is the plane that is tangent to the point marked\n          on the sphere. In other words, it is the tangent plane of the marked\n          point on the sphere.\n        </small>\n      </p>\n      <p>\n        This plane is what is considered as XY-axis part of the tangent-space\n        for that point of the sphere, with the Z-axis protruding outwards and\n        away from the sphere (the direction of the normal of that point on the\n        sphere).\n      </p>\n      <p>\n        In order to store the information of the normals of all points of that\n        sphere, the values of the normals have to be recorded w.r.t the\n        tangent-space of the point they belong to.\n      </p>\n      <Heading type=\"h2\">Calculating the lighting</Heading>\n      <p>\n        Since the calculations we've seen in previous chapters are done in a\n        space that is not the tangent-space, in order to use a normal map a\n        transformation of values has to occur to ensure that the calculation\n        occurs in the same \"space\" to be valid.\n      </p>\n      <p>\n        There are two potential options in order to fix calculations into a\n        specific space:\n      </p>\n      <ul>\n        <li>\n          Keep other values as is, transform the normal map values from\n          tangent-space into the other spaces, and perform the calculations in\n          the other spaces.\n        </li>\n        <li>\n          Keep the normal map values as is, transform all other values from\n          other spaces into tangent-space, and perform the calculations in\n          tangent-space.\n        </li>\n      </ul>\n      <p>\n        In order to perform either of these, we'll need a certain matrix to\n        perform the transformation. This matrix is called the\n        Tangent-Bitangent-Normal matrix (or TBN matrix).\n      </p>\n      <Heading type=\"h3\">TBN Matrix</Heading>\n      <p>\n        Just like with the model, view, and projection matrices, in order to\n        transform values either into (or out of) tangent-space, a matrix called\n        the TBN (Tangent Bi-Tangent Normal) matrix is required.\n      </p>\n      <p>\n        A TBN matrix for a vertex is calculated by generating a 3x3 matrix using\n        the tangent, bi-tangent, and normal direction values of a vertex.\n      </p>\n      <p>\n        If we represent the tangent vector as T, bi-tangent vector as B, and\n        normal vector as N, the TBN matrix would look like:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`TBN = [[T_x, B_x, N_x], [T_y, B_y, N_y], [T_z, B_z, N_z]]`}\n        />\n      </p>\n      <p>\n        Similar to how a model matrix can transform a point or direction from\n        model-space into world-space, a TBN matrix can transform a point or\n        direction from tangent-space into model-space.\n      </p>\n      <p>\n        Similarly, if the inverse of the TBN matrix is used instead, then the\n        matrix can transform a point or direction from model-space into\n        tangent-space. This is useful if you wish to keep calculations present\n        in tangent-space.\n      </p>\n      <p>\n        Since the TBN matrix is calculated for each vertex, the matrix value for\n        each fragment is interpolated from the matrix values for each vertex\n        that forms the polygon that the fragment belongs to.\n      </p>\n      <p>\n        Let's look at an example where the calculation for lighting using the\n        normal values in the normal map are done in view-space using the TBN\n        matrix.\n      </p>\n      <Heading type=\"h2\">\n        Example - Normal-mapped stone wall (in view-space)\n      </Heading>\n      <NormalMappingSecondExample />\n      <GlslCodeHighlight\n        code={secondVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={secondFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        The shaders are written similar to the final shader in the{\" \"}\n        <Link to=\"/intermediates/lighting/\">lighting chapter</Link>, but with\n        all the main lighting calculation moved to the fragment shader. The\n        reason for this is since we'd be grabbing the normal of the surface at\n        the fragment level, the lighting can only be calculated in the fragment\n        shader.\n      </p>\n      <p>\n        The first step is to calculate the TBN matrix which we need for\n        transforming the normal values from tangent-space into view-space. This\n        is done from line 22 onwards in the vertex shader.\n      </p>\n      <p>\n        The tangent, bi-tangent and normal values for each vertex in a model is\n        known beforehand. These values are in model-space, and so need to be\n        converted to view-space in order to calculate the TBN matrix in\n        view-space.\n      </p>\n      <p>\n        The tangent, bi-tangent and normal values are first normalized\n        (converted into a unit vector), and then a 3x3 matrix is constructed\n        using them, as explained previously.\n      </p>\n      <p>\n        The resultant matrix is a TBN matrix that transforms vectors from\n        tangent-space to model-space. Since we want to work in view-space\n        instead, we multiply the model-view matrix against the TBN matrix to get\n        a TBN matrix in view-space.\n      </p>\n      <p>\n        However, if you notice carefully, the TBN matrix is a 3x3 matrix,\n        whereas a model-view matrix is a 4x4 matrix.\n      </p>\n      <p>\n        To transform the TBN matrix into view-space, the last column and last\n        row of the model-view matrix can be removed in order to multiply it\n        against the TBN matrix. This is fine because those fields don't contain\n        any values that affect the calculation.\n      </p>\n      <p>\n        Alternatively, the TBN matrix can be converted into a 4x4 matrix, but\n        this wouldn't provide much benefit as the resultant matrix would be used\n        with vectors with three dimensions, not four.\n      </p>\n      <p>\n        The calculated TBN matrix in view-space is now passed to the fragment\n        shader, along with certain other values that can only be calculated in\n        the vertex shader (<code>vertexPosition_viewSpace</code>).\n      </p>\n      <p>\n        In the fragment shader, the normal value of the fragment is retrieved\n        the normal map, similar to how the color value is retrieved from tge\n        color map\n      </p>\n      <p>\n        Once the normal color value is retrieved, it needs to be converted into\n        an actual normal vector (in tangent-space). Since we know what the range\n        of the color values are supposed to represent, we can perform the\n        conversion using a simple mathematical formula.\n      </p>\n      <p className=\"util text-center\">\n        <Equation text={`\"normal\" = (\"normalColor\" * 2.0) - 1.0`} />\n      </p>\n      <p>\n        Let's take a color value of whose RGB value is{\" \"}\n        <Equation text={`\"normalColor\" = [128, 128, 128]`} />. In OpenGL, the\n        colors are represented in a range of 0 - 1 instead of 0 - 255, so the\n        RGB value would actually be{\" \"}\n        <Equation text={`\"normalColor\" = [0.5, 0.5, 0.5]`} />.\n      </p>\n      <p>\n        This color value is right in the middle of the color range, so it should\n        represent a normal vector{\" \"}\n        <Equation text={`\"normal\" = [0.0, 0.0, 0.0]`} />.\n      </p>\n      <p>\n        When we plug in the normal color value into our formula for calculating\n        the normal, we get:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`\"normal\" = ([0.5, 0.5, 0.5] * 2.0) - 1.0 = [1.0, 1.0, 1.0] - 1.0 = [0.0, 0.0, 0.0]`}\n        />\n      </p>\n      <p>Which matches perfectly with what we expect to get!</p>\n      <p>\n        Just to further verify the formula, let's take a color value{\" \"}\n        <Equation text={`\"normalColor\" = [64, 64, 192]`} />. In OpenGL, this\n        would be <Equation text={`\"normalColor\" = [0.25, 0.25, 0.75]`} />, which\n        should represent a normal{\" \"}\n        <Equation text={`\"normal\" = [-0.5, -0.5, 0.5]`} />.\n      </p>\n      <p>Plugging this color value into the formula returns:</p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`\"normal\" = ([0.25, 0.25, 0.75] * 2.0) - 1.0 = [0.5, 0.5, 1.5] - 1.0 = [-0.5, -0.5, 0.5]`}\n        />\n      </p>\n      <p>Which again equals to the expected normal vector.</p>\n      <p>\n        Once the normal vector in tangent-space is calculated, it can now be\n        transformed into view-space by multiplying the TBN matrix against it.\n      </p>\n      <p className=\"util text-center\">\n        <Equation text={`\"normal\"_\"viewSpace\" = \"TBN\" times \"normal\"`} />\n      </p>\n      <p>\n        Once this is calculated, the rest of the lighting calculations use this\n        normal value to calculate the lighting on the fragment. This is similar\n        to what was taught in the{\" \"}\n        <Link to=\"/intermediates/lighting/\">lighting chapter</Link>.\n      </p>\n      <p>\n        Now that we've seen what the calculation looks like in view-space, let's\n        now look at how the calculation would appear in tangent-space.\n      </p>\n      <Heading type=\"h2\">\n        Example - Normal-mapped stone wall (in tangent-space)\n      </Heading>\n      <NormalMappingThirdExample />\n      <GlslCodeHighlight\n        code={thirdVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={thirdFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        Since the TBN matrix we previously had transformed vectors from\n        tangent-space to view-space, in order to transform values the other way\n        we need to calculate the transpose of the TBN matrix we previously\n        calculated. This is done in line 33 of the vertex shader.\n      </p>\n      <p>\n        Once the new TBN matrix is calculated, we now transform all the values\n        we were previously using in view-space into tangent space. In the vertex\n        shader, we transform the vertex position into tangent-space, and in the\n        fragment shader we transform the light position into tangent-space.\n      </p>\n      <p>\n        Once in the fragment shader, we grab the normal vector from the normal\n        map as we did in the previous example. Since the lighting calculations\n        are being done in tangent-space, only the conversion from the color\n        value to the vector value is required.\n      </p>\n      <p>\n        Now that all the variables we require for calculating lighting are in\n        tangent-space, we can perform the lighting calculations in the exact\n        same way as in the previous example. The resultant lighting value will\n        be the same!\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          Similar to color mapping, normal mapping can be used to map normals to\n          fragments inside a polygon to add more detail to a surface.\n        </li>\n        <li>\n          Normal maps add the appearance of roughness or small bumps on the\n          surface of objects.\n        </li>\n        <li>\n          The normals of each point are stored in an image in \"tangent-space\"\n          with the X, Y, and Z coordinates represented using RGB color values.\n        </li>\n        <li>\n          The color values representing the normals for each fragment are\n          retrieved from the texture and then converted into normal vectors,\n          which are then used to perform lighting calculations.\n        </li>\n        <li>\n          Check out{\" \"}\n          <a\n            href=\"http://www.mattrittman.com/create-normal-map-photoshop/\"\n            rel=\"noopener noreferrer\"\n            target=\"_blank\"\n          >\n            this guide by Matt Rittman\n          </a>{\" \"}\n          on how to generate a normal map in Photoshop. You should find other\n          references for generating normal maps online.\n        </li>\n      </ul>\n    </Content>\n    <PageChange\n      previous=\"/intermediates/lighting/\"\n      next=\"/intermediates/specular-mapping/\"\n    />\n  </Layout>\n);\n\nexport default NormalMappingPage;\n","export default __webpack_public_path__ + \"static/normal-3d370ff1c6790eee68b4a59f5ccdc8b9.png\";","export default __webpack_public_path__ + \"static/texture-2-c11990d4afdf5ed2f0fb3c44636bccd1.png\";"],"names":["shaderProgramInfo","vertex","attributeLocations","vertexPosition","vertexUv","vertexNormal","uniformLocations","modelMatrix","viewMatrix","projectionMatrix","lightPosition_worldSpace","lightColor","lightIntensity","specularLobeFactor","fragment","specularReflectivity","diffuseTextureSampler","lightModelPosition","vec4","vec3","squareModelPosition","mat4","wrapExample","NormalMappingFirstExample","square","vertices","uvs","normals","indices","texture","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","squareBuffer","updatesquareBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","createElementArrayBuffer","createImageTexture","shouldRender","renderScene","_ref","gl","rotatedModelMatrix","rotationAngle","Math","PI","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","useProgram","uniformMatrix4fv","uniform4fv","uniform3fv","uniform1f","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","drawElements","TRIANGLES","length","UNSIGNED_SHORT","requestAnimationFrame","React","className","style","padding","width","height","ref","coordArrToString","trim","x","y","z","secondVertexShaderSource","secondFragmentShaderSource","vertexTangent","vertexBiTangent","normalTextureSampler","NormalMappingSecondExample","tangents","biTangents","normalTexture","i","v0","v1","v2","uv0","vec2","uv1","uv2","deltaPos1","deltaPos2","deltaUv1","deltaUv2","r","tangent","Array","from","biTangent","push","TEXTURE1","thirdVertexShaderSource","thirdFragmentShaderSource","NormalMappingThirdExample","location","pathname","Layout","Seo","title","description","keywords","Content","Link","to","Heading","type","StaticImage","src","alt","maxWidth","__imageData","require","href","target","rel","Equation","text","GlslCodeHighlight","code","PageChange","previous","next"],"sourceRoot":""}