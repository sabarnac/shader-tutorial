<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.14.1"/><meta data-react-helmet="true" name="description" content="A look into the how shadow maps can be generated and used to add dynamic shadows produced by objects in a scene."/><meta data-react-helmet="true" property="og:title" content="Shader Advanced - Shadow Mapping | GPU Shader Tutorial"/><meta data-react-helmet="true" property="og:url" content="https://shader-tutorial.dev/advanced/shadow-mapping/"/><meta data-react-helmet="true" property="og:description" content="A look into the how shadow maps can be generated and used to add dynamic shadows produced by objects in a scene."/><meta data-react-helmet="true" property="og:image" content="https://shader-tutorial.dev/icon.png"/><meta data-react-helmet="true" property="og:image:height" content="256"/><meta data-react-helmet="true" property="og:image:width" content="256"/><meta data-react-helmet="true" property="og:image:alt" content="GPU Shader Tutorial Icon"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Shader Advanced - Shadow Mapping | GPU Shader Tutorial"/><meta data-react-helmet="true" name="twitter:description" content="A look into the how shadow maps can be generated and used to add dynamic shadows produced by objects in a scene."/><meta data-react-helmet="true" name="twitter:image" content="https://shader-tutorial.dev/icon.png"/><meta data-react-helmet="true" name="twitter:image:alt" content="GPU Shader Tutorial Icon"/><meta data-react-helmet="true" name="keywords" content="shadow, mapping, texturing, shader, spot light, area light, point light, advanced"/><meta name="theme-color" content="#000000"/><style data-href="/styles.d57fe57b6bbdeea233b9.css" data-identity="gatsby-global-css">/*!
  * Milligram v1.4.1
  * https://milligram.io
  *
  * Copyright (c) 2020 CJ Patoilo
  * Licensed under the MIT license
 */*,:after,:before{box-sizing:inherit}html{box-sizing:border-box;font-size:62.5%}body{color:#606c76;font-family:Roboto,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:1.6em;font-weight:300;letter-spacing:.01em;line-height:1.6}blockquote{border-left:.3rem solid #d1d1d1;margin-left:0;margin-right:0;padding:1rem 1.5rem}blockquote :last-child{margin-bottom:0}.button,button,input[type=button],input[type=reset],input[type=submit]{background-color:#9b4dca;border:.1rem solid #9b4dca;border-radius:.4rem;color:#fff;cursor:pointer;display:inline-block;font-size:1.1rem;font-weight:700;height:3.8rem;letter-spacing:.1rem;line-height:3.8rem;padding:0 3rem;text-align:center;text-decoration:none;text-transform:uppercase;white-space:nowrap}.button:focus,.button:hover,button:focus,button:hover,input[type=button]:focus,input[type=button]:hover,input[type=reset]:focus,input[type=reset]:hover,input[type=submit]:focus,input[type=submit]:hover{background-color:#606c76;border-color:#606c76;color:#fff;outline:0}.button[disabled],button[disabled],input[type=button][disabled],input[type=reset][disabled],input[type=submit][disabled]{cursor:default;opacity:.5}.button[disabled]:focus,.button[disabled]:hover,button[disabled]:focus,button[disabled]:hover,input[type=button][disabled]:focus,input[type=button][disabled]:hover,input[type=reset][disabled]:focus,input[type=reset][disabled]:hover,input[type=submit][disabled]:focus,input[type=submit][disabled]:hover{background-color:#9b4dca;border-color:#9b4dca}.button.button-outline,button.button-outline,input[type=button].button-outline,input[type=reset].button-outline,input[type=submit].button-outline{background-color:transparent;color:#9b4dca}.button.button-outline:focus,.button.button-outline:hover,button.button-outline:focus,button.button-outline:hover,input[type=button].button-outline:focus,input[type=button].button-outline:hover,input[type=reset].button-outline:focus,input[type=reset].button-outline:hover,input[type=submit].button-outline:focus,input[type=submit].button-outline:hover{background-color:transparent;border-color:#606c76;color:#606c76}.button.button-outline[disabled]:focus,.button.button-outline[disabled]:hover,button.button-outline[disabled]:focus,button.button-outline[disabled]:hover,input[type=button].button-outline[disabled]:focus,input[type=button].button-outline[disabled]:hover,input[type=reset].button-outline[disabled]:focus,input[type=reset].button-outline[disabled]:hover,input[type=submit].button-outline[disabled]:focus,input[type=submit].button-outline[disabled]:hover{border-color:inherit;color:#9b4dca}.button.button-clear,button.button-clear,input[type=button].button-clear,input[type=reset].button-clear,input[type=submit].button-clear{background-color:transparent;border-color:transparent;color:#9b4dca}.button.button-clear:focus,.button.button-clear:hover,button.button-clear:focus,button.button-clear:hover,input[type=button].button-clear:focus,input[type=button].button-clear:hover,input[type=reset].button-clear:focus,input[type=reset].button-clear:hover,input[type=submit].button-clear:focus,input[type=submit].button-clear:hover{background-color:transparent;border-color:transparent;color:#606c76}.button.button-clear[disabled]:focus,.button.button-clear[disabled]:hover,button.button-clear[disabled]:focus,button.button-clear[disabled]:hover,input[type=button].button-clear[disabled]:focus,input[type=button].button-clear[disabled]:hover,input[type=reset].button-clear[disabled]:focus,input[type=reset].button-clear[disabled]:hover,input[type=submit].button-clear[disabled]:focus,input[type=submit].button-clear[disabled]:hover{color:#9b4dca}code{border-radius:.4rem;font-size:86%;margin:0 .2rem;padding:.2rem .5rem;white-space:nowrap}code,pre{background:#f4f5f6}pre{border-left:.3rem solid #9b4dca;overflow-y:hidden}pre>code{border-radius:0;display:block;padding:1rem 1.5rem;white-space:pre}hr{border:0;border-top:.1rem solid #f4f5f6;margin:3rem 0}input:not([type]),input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=month],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],input[type=week],select,textarea{-webkit-appearance:none;background-color:transparent;border:.1rem solid #d1d1d1;border-radius:.4rem;box-shadow:none;box-sizing:inherit;height:3.8rem;padding:.6rem 1rem .7rem;width:100%}input:not([type]):focus,input[type=color]:focus,input[type=date]:focus,input[type=datetime-local]:focus,input[type=datetime]:focus,input[type=email]:focus,input[type=month]:focus,input[type=number]:focus,input[type=password]:focus,input[type=search]:focus,input[type=tel]:focus,input[type=text]:focus,input[type=url]:focus,input[type=week]:focus,select:focus,textarea:focus{border-color:#9b4dca;outline:0}select{background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 8" width="30"><path fill="%23d1d1d1" d="M0,0l6,8l6-8"/></svg>') 100% no-repeat;padding-right:3rem}select:focus{background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 8" width="30"><path fill="%239b4dca" d="M0,0l6,8l6-8"/></svg>')}select[multiple]{background:none;height:auto}textarea{min-height:6.5rem}label,legend{display:block;font-size:1.6rem;font-weight:700;margin-bottom:.5rem}fieldset{border-width:0;padding:0}input[type=checkbox],input[type=radio]{display:inline}.label-inline{display:inline-block;font-weight:400;margin-left:.5rem}.container{margin:0 auto;max-width:112rem;padding:0 2rem;position:relative}.row{display:flex;flex-direction:column;width:100%}.row,.row.row-no-padding,.row.row-no-padding>.column{padding:0}.row.row-wrap{flex-wrap:wrap}.row.row-top{align-items:flex-start}.row.row-bottom{align-items:flex-end}.row.row-center{align-items:center}.row.row-stretch{align-items:stretch}.row.row-baseline{align-items:baseline}.row .column{display:block;flex:1 1 auto;margin-left:0;max-width:100%;width:100%}.row .column.column-offset-10{margin-left:10%}.row .column.column-offset-20{margin-left:20%}.row .column.column-offset-25{margin-left:25%}.row .column.column-offset-33,.row .column.column-offset-34{margin-left:33.3333%}.row .column.column-offset-40{margin-left:40%}.row .column.column-offset-50{margin-left:50%}.row .column.column-offset-60{margin-left:60%}.row .column.column-offset-66,.row .column.column-offset-67{margin-left:66.6666%}.row .column.column-offset-75{margin-left:75%}.row .column.column-offset-80{margin-left:80%}.row .column.column-offset-90{margin-left:90%}.row .column.column-10{flex:0 0 10%;max-width:10%}.row .column.column-20{flex:0 0 20%;max-width:20%}.row .column.column-25{flex:0 0 25%;max-width:25%}.row .column.column-33,.row .column.column-34{flex:0 0 33.3333%;max-width:33.3333%}.row .column.column-40{flex:0 0 40%;max-width:40%}.row .column.column-50{flex:0 0 50%;max-width:50%}.row .column.column-60{flex:0 0 60%;max-width:60%}.row .column.column-66,.row .column.column-67{flex:0 0 66.6666%;max-width:66.6666%}.row .column.column-75{flex:0 0 75%;max-width:75%}.row .column.column-80{flex:0 0 80%;max-width:80%}.row .column.column-90{flex:0 0 90%;max-width:90%}.row .column .column-top{align-self:flex-start}.row .column .column-bottom{align-self:flex-end}.row .column .column-center{align-self:center}@media (min-width:40rem){.row{flex-direction:row;margin-left:-1rem;width:calc(100% + 2rem)}.row .column{margin-bottom:inherit;padding:0 1rem}}a{color:#9b4dca;text-decoration:none}a:focus,a:hover{color:#606c76}dl,ol,ul{list-style:none;margin-top:0;padding-left:0}dl dl,dl ol,dl ul,ol dl,ol ol,ol ul,ul dl,ul ol,ul ul{font-size:90%;margin:1.5rem 0 1.5rem 3rem}ol{list-style:decimal inside}ul{list-style:circle inside}.button,button,dd,dt,li{margin-bottom:1rem}fieldset,input,select,textarea{margin-bottom:1.5rem}blockquote,dl,figure,form,ol,p,pre,table,ul{margin-bottom:2.5rem}table{border-spacing:0;display:block;overflow-x:auto;text-align:left;width:100%}td,th{border-bottom:.1rem solid #e1e1e1;padding:1.2rem 1.5rem}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}@media (min-width:40rem){table{display:table;overflow-x:initial}}b,strong{font-weight:700}p{margin-top:0}h1,h2,h3,h4,h5,h6{font-weight:300;letter-spacing:-.1rem;margin-bottom:2rem;margin-top:0}h1{font-size:4.6rem;line-height:1.2}h2{font-size:3.6rem;line-height:1.25}h3{font-size:2.8rem;line-height:1.3}h4{font-size:2.2rem;letter-spacing:-.08rem;line-height:1.35}h5{font-size:1.8rem;letter-spacing:-.05rem;line-height:1.5}h6{font-size:1.6rem;letter-spacing:0;line-height:1.4}img{max-width:100%}.clearfix:after{clear:both;content:" ";display:table}.float-left{float:left}.float-right{float:right}
/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{-webkit-text-size-adjust:100%;line-height:1.15}body{margin:0}main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}[hidden],template{display:none}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc3CsTKlA.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c88,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc-CsTKlA.woff2) format("woff2");unicode-range:u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc2CsTKlA.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc5CsTKlA.woff2) format("woff2");unicode-range:u+0370-03ff}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc1CsTKlA.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc0CsTKlA.woff2) format("woff2");unicode-range:u+0100-024f,u+0259,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TjASc6CsQ.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic3CsTKlA.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c88,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic-CsTKlA.woff2) format("woff2");unicode-range:u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic2CsTKlA.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic5CsTKlA.woff2) format("woff2");unicode-range:u+0370-03ff}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic1CsTKlA.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic0CsTKlA.woff2) format("woff2");unicode-range:u+0100-024f,u+0259,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Roboto;font-style:italic;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOjCnqEu92Fr1Mu51TzBic6CsQ.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCRc4EsA.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c88,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fABc4EsA.woff2) format("woff2");unicode-range:u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCBc4EsA.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fBxc4EsA.woff2) format("woff2");unicode-range:u+0370-03ff}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fCxc4EsA.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fChc4EsA.woff2) format("woff2");unicode-range:u+0100-024f,u+0259,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmSU5fBBc4.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCRc4EsA.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c88,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfABc4EsA.woff2) format("woff2");unicode-range:u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCBc4EsA.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfBxc4EsA.woff2) format("woff2");unicode-range:u+0370-03ff}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfCxc4EsA.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfChc4EsA.woff2) format("woff2");unicode-range:u+0100-024f,u+0259,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Roboto;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/roboto/v27/KFOlCnqEu92Fr1MmWUlfBBc4.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}*{box-sizing:border-box}body,html{background:#000;color:#ededed;margin:0;padding:0}body,html{height:100%}.title-largest{font-size:4.6rem;font-weight:300;letter-spacing:-.1rem;line-height:1.2;margin-bottom:2rem;margin-top:0;text-transform:capitalize}h2,h3,h4,h5,h6{align-items:center;display:flex}h2>a,h3>a,h4>a,h5>a,h6>a{border-bottom:none!important;margin-left:auto;padding-left:2rem}h2>a>img,h3>a>img,h4>a>img,h5>a>img,h6>a>img{background:none;border:none}h2>a>img{height:3.6rem}h3>a>img{height:2.8rem}h4>a>img{height:2.2rem}h5>a>img{height:1.8rem}h6>a>img{height:1.6rem}h1{text-transform:capitalize}h5,h6{font-weight:600}canvas{background:#ddd;border:1px solid #ddd;max-width:800px;width:100%}select{color:#ededed}select option{background:#000}button.example-view-link{background:none!important;border:none;border-radius:0;cursor:pointer;font-size:3rem;height:auto;padding:.5rem!important;text-transform:uppercase}a,a:visited,button.example-view-link{border-bottom:1px dotted #ddd;color:#ddd}a:focus,a:hover{border-bottom:1px dotted #bbb;color:#bbb}code,pre{background:#333}pre{padding:1rem}img{background:#ccc;border:1px solid #ccc}input,textarea{color:#ccc}#___gatsby,#___gatsby>div{height:100%}.container{height:100%;margin:0;max-width:none;padding:0;width:100%}.container .row.wrapper{height:auto!important;height:100%;margin:0;min-height:100%;width:100%}.container .row.wrapper header.column{border-bottom:1px solid #ccc;max-width:100%;padding:1rem}.container .row.wrapper header.column h1{text-align:center}.container .row.wrapper header.column img{border:none}.container .row.wrapper header.column nav>ul>li.skip-nav{text-align:center}.container .row.wrapper header.column nav>ul>li ul li,.container .row.wrapper header.column nav>ul>li:not(.skip-nav){font-size:2rem;padding:0 2rem}.container .row.wrapper header.column nav>ul>li ul li:first-child{margin-top:1rem}.container .row.wrapper .column.content{display:flex;flex-direction:column;max-width:100%}.container .row.wrapper .column.content .notice.column{align-items:center;background:red;border-bottom:1px solid #ccc;display:flex;font-size:2.5rem;font-weight:600;justify-content:center;padding:1rem}.container .row.wrapper .column.content main.row{align-items:center;flex-grow:1;padding:1rem}.container .row.wrapper .column.content main.row>.column{max-width:1000px;padding:1.25rem}.container .row.wrapper .column.content footer.column{align-items:center;border-top:1px solid #ccc;display:flex;justify-content:space-between;padding:2rem 1.5rem}.container .row.wrapper .column.content footer.column .social{padding-right:1rem}.container .row.wrapper .column.content footer.column .social a{align-items:center;border-bottom:none;display:flex;margin:0 1rem}.container .row.wrapper .column.content footer.column .social *{background:none;border:none}div.image{margin-bottom:2.5rem}.page-change{display:flex;flex-wrap:wrap;justify-content:space-between}.page-change .page-next,.page-change .page-previous{flex-grow:1;padding:1rem}.toc{font-size:2rem}dl.faq-list dt:before{content:"Q. ";font-weight:600}nav ul{list-style:none;margin:0;padding:0}@media (min-width:40rem){.container .row.wrapper .column.content,.container .row.wrapper header.column{max-width:inherit}.container .row.wrapper header.column{border-bottom:none;border-right:1px solid #ccc}.container .row.wrapper .column.content main.row{align-items:normal;justify-content:center}}.util.text-center{text-align:center}.util.text-left{text-align:left}.util.text-right{text-align:right}.row.page-change{border-top:1px dashed #ccc;padding:1rem}</style><title data-react-helmet="true">Shader Advanced - Shadow Mapping | GPU Shader Tutorial</title><link data-react-helmet="true" rel="preconnect" href="https://fonts.gstatic.com"/><link rel="sitemap" type="application/xml" href="/sitemap-index.xml"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){const t=e.target;if(void 0===t.dataset.mainImage)return;if(void 0===t.dataset.gatsbyImageSsr)return;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="/favicon-32x32.png?v=00550955413b0eb5e957bab4c949741d" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=00550955413b0eb5e957bab4c949741d"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=00550955413b0eb5e957bab4c949741d"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container"><div class="row wrapper"><header class="column column-25"><div style="display:flex;justify-content:center"><picture><img src="data:image/png;base64,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" alt="GPU Shader Tutorial Logo" height="256" width="256" style="width:256px;height:100%"/></picture></div><div id="site-title" class="title-largest" style="text-align:center">GPU Shader Tutorial</div><nav><ul><li class="skip-nav"><a href="#main" tabindex="0">Skip Navigation</a></li><li><a href="/">Home</a></li><li><hr/></li><li><a href="/basics/">Basics</a><ul><li><a href="/basics/introduction/">Introduction</a></li><li><a href="/basics/render-pipeline/">Render Pipeline</a></li><li><a href="/basics/mathematics/">Mathematics</a></li><li><a href="/basics/vertex-shader/">Vertex Shader</a></li><li><a href="/basics/color/">Color</a></li><li><a href="/basics/fragment-shader/">Fragment Shader</a></li></ul></li><li><hr/></li><li><a href="/intermediates/">Intermediates</a><ul><li><a href="/intermediates/color-2/">Color Part 2</a></li><li><a href="/intermediates/image-generation/">Image Generation</a></li><li><a href="/intermediates/mapping/">Mapping</a></li><li><a href="/intermediates/color-mapping/">Color Mapping</a></li><li><a href="/intermediates/lighting/">Lighting</a></li><li><a href="/intermediates/normal-mapping/">Normal Mapping</a></li><li><a href="/intermediates/specular-mapping/">Specular Mapping</a></li></ul></li><li><hr/></li><li><a href="/advanced/">Advanced</a><ul><li><a href="/advanced/branching/">Branching</a></li><li><a href="/advanced/color-banding-dithering/">Color Banding and Dithering</a></li><li><a href="/advanced/transparency/">Transparency</a></li><li><a aria-current="page" class="" href="/advanced/shadow-mapping/">Shadow Mapping</a></li><li>More Coming Soon...</li></ul></li><li><hr/></li><li><a href="/faq/">FAQ</a></li></ul></nav></header><div class="column column-75 content"><div class="row"><div class="column notice">This tutorial is currently a work in progress. Content may be added, updated, or removed at any time.</div></div><main class="row main" id="main"><div class="column"><h1>Shader Advanced - Shadow Mapping</h1><p>In the <a href="/intermediates/lighting/">lighting chapter</a>, we&#x27;ve learnt how to color an object based on the light falling on it, and the various components that make up the lighting of an object.</p><p>However, we&#x27;re still missing an important component of lighting an object - the shadows that they create. While light can increase the visibility of an object, it also allows an object to cast shadows on other objects, reducing their visibility.</p><p>Without shadows being considered when shading an object based on the sources of light in the world, the world will not look accurate.</p><p>Let&#x27;s take a look at an example where we only have lighting in the world, but no shadows being cast by objects.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    World Position: { x: -9.000, y: 27.000, z: -18.000 }
    Color: { r: 0.300, g: 0.300, b: 0.300 }
    Intensity: 2500</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p>From the example, it becomes apparent why the lighting looks very odd.</p><p>If each object in the scene is looked at individually, the lighting on them looks accurate, with how much each part is lit based on where they are respective to the light. However, since the objects aren&#x27;t casting a shadow on each other, the scene feels incomplete.</p><p>Depending on the type of light being used, the shadows they cast, and the techniques used to create them can differ slightly. Let&#x27;s go through various types of lights that one may add to their scene and see how shadow mapping is done for each of them.</p><h2 id="2-directional-light">Directional light<a href="#2-directional-light" aria-label="Link to section &quot;Directional light&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><p>Directional lights represent a light where the rays all travel in the same direction and don&#x27;t have their intensity decrease with increase in distance.</p><p>Directional lights are typically to light up areas uniformly with no reduction in light intensity, like light from the Sun.</p><p>Directional lights are a very good representation of lighting by then Sun because the Sun is far enough for the rays of light being emitted by it being effectively parallel, and the intensity of the light always being uniform across an entire scene.</p><p>The first step for creating shadows is to determine what parts of the scene are visible to the light source and which parts are not.</p><p>Since any part of a scene that is visible to the light would have rays from it fall on it, any parts that are not visible from the perspective of the light should not be lit by it, as they would be blocked by the visible parts of the scene.</p><p>If we position the camera to be in the same position and facing the same direction as the light source, we can capture which parts of the scene are visible under the light source. This can allow us to determine which parts of the scenen are visible and not visible from the perspective of the light.</p><p>To go about doing this, we create a texture that we will render the scene to from the perspective of the light source, where we capture the depth of each object visible to the light source in the scene (how far away the object is from the light source).</p><p>This image that is rendered to the texture is called a depth map, because it is an image map that shows the depth of various parts of the scene that are visible to the camera.</p><p>However, the depth map we&#x27;ve rendered is specially called a shadow map, because it determines which parts of the scene are visible to the light source, and hence can also be used to determine which parts are not visible to the light source and are hence in shadow.</p><p>Do note that since we&#x27;re only recording a single value (the depth), shadow maps are grayscale as a result.</p><p>Let&#x27;s look at an example for creating a shadow map for a directional light.</p><h3 id="3-rendering-a-shadow-map">Rendering a shadow map<a href="#3-rendering-a-shadow-map" aria-label="Link to section &quot;Rendering a shadow map&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>Rendering a shadow map is very simple. We just need to adjust our view and projection matrices to match how the light source would view the world.</p><ul><li>The view matrix is updated to change the camera position and direction to be the same as that of the light source.</li><li>The projection matrix is updated to reflect how the light source views the world. For the case of directional lights, since they generate light rays that travel in parallel, an orthogonal projection would best fit it.</li></ul><p>Note that the camera would have to positioned and projected using the view and projection matrices in such a way that the area that is supposed to be lit by the light source is rendered into the shadow map. This may require some testing to figure out correctly.</p><p>Once the camera is placed correctly, the rest of the process is very simple - render the scene into the texture, with the fragment shader returning the depth of the fragment it is rendering as the color of that fragment.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Shadow Map Vertex Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span></code><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> modelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> viewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> projectionMatrix;
</span>
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#e6c07b">gl_Position</span><span> = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;
</span>}</code></pre><p><strong>Shadow Map Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span></code><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span> = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">vec3</span><span>(</span><span style="color:#e6c07b">gl_FragCoord</span><span>.z), </span><span style="color:#d19a66">1.0</span><span>);
</span>}</code></pre><p>Looking at the example above, we can see that the vertex shader is extremely simple and something we&#x27;ve already seen before in previous chapters. We just position the vertex using the model-view-projection matrix, with the view-projection matrix based on the light source.</p><p>In the fragment shader, we need to return the depth of the fragment being rendered to be stored in the texture. Since it&#x27;s just a single value, we can return it as a simple grayscale color value.</p><p>In order to determine the depth of the fragment from the light source, we can calculate the depths of each vertex and pass that to the fragment shader, letting the GPU interpolate that into the depth value for the fragment.</p><p>However, the GPU already provides us with the position of the fragment w.r.t. the camera&#x27;s origin (which is in the same position as the light source). In OpenGL/WebGL, this value is available through the<!-- --> <code>gl_FragCoord</code> variable, with the <code>gl_FragCoord.z</code> <!-- -->telling us the depth of the fragment.</p><p>If the shader language you&#x27;re using doesn&#x27;t provide this data already, as mentioned before you can just calculate the depth of each vertex and pass that to the fragment shader, letting the GPU interpolate the depth value for each fragment as a result.</p><p>With the depth of the fragment known, the fragment color is set to the same value, and the final shadow map is saved to a texture. This lets us use it in the next step for drawing the shadows as part of the main render.</p><p>Next, let&#x27;s look at how we use the shadow map when rendering the actual scene.</p><h3 id="3-utilizing-the-shadow-map">Utilizing the shadow map<a href="#3-utilizing-the-shadow-map" aria-label="Link to section &quot;Utilizing the shadow map&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>With the shadow map generated, now we need to use it during the main render of the scene.</p><p>The shadow map contains the depth of all the parts of the scene that are visible to the light source, with the map being rendered from the light sources&#x27; perspective.</p><p>When performing the final render of the scene in the fragment shader, we can calculate the position of the fragment being rendered relative to the light source to get the depth of the fragment that was closest and visible to it.</p><p>Using this value, we can then check if the depth of the current fragment from the light source is less than or equal to the depth of the fragment in the shadow map.</p><p>If it is, that means the current fragment has to be visible to the light source and should be lit by it. If not, that means the current fragment is covered by another fragment from the view of the light source, and hence is in shadow.</p><p>Let&#x27;s look at how this would be implemented in the shader.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Vertex Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span></code><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition;
</span><span></span><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec3</span><span> vertexNormal;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> modelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> viewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> projectionMatrix;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightModelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightViewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightProjectionMatrix;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition_worldSpace = modelMatrix * vertexPosition;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;
</span>  
<span>  </span><span style="color:#e6c07b">gl_Position</span><span> = projectionMatrix * vertexPosition_viewSpace;
</span>
<!-- -->  fragmentPosition_worldSpace = vertexPosition_worldSpace;
<!-- -->  fragmentPositionFromLight = lightProjectionMatrix * lightViewMatrix * lightModelMatrix * vertexPosition;
<!-- -->  
<span>  fragmentNormal_viewSpace = (viewMatrix * modelMatrix * </span><span style="color:#d19a66">vec4</span><span>(vertexNormal, </span><span style="color:#d19a66">0.0</span><span>)).xyz;
</span>  lightDirection_viewSpace = (viewMatrix * lightDirection_worldSpace).xyz;
<!-- -->}</code></pre><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// Since we&#x27;re rendering a directional light, the strength of the light doesn&#x27;t drop with distance,</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// so leave out the distance calculation part.</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// return (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> lightColorIntensity * diffuseStrength;
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy).z;
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = currentDepth &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>The vertex shader now calculates two additional values that are forwarded to the fragment shader - the position of the fragment relative to the light source (which is passed as<!-- --> <code>vertexPositionFromLight</code>), and the direction of the light from the light source in view-space (which is passed as<!-- --> <code>lightDirection_viewSpace</code>).</p><p>Note that since we&#x27;re not using normal maps, the vertex shader looks like the one we&#x27;ve learn about in the<!-- --> <a href="/intermediates/lighting/">lighting</a> chapter.</p><p>In the fragment shader is where the shadow map is utilized. We first need to calculate what the depth of the current fragment is relative to the light source, which can be done using the<!-- --> <code>vertexPositionFromLight</code> value provided by the vertex shader.</p><p>The coordinates provided by the vertex shader first need to be corrected for perspective-division and adjusting the range of the value.</p><p>When we set the position of the vertex in the vertex shader using the<!-- --> <code>gl_Position</code> variable, the GPU performs some additional operations on the position value to transform it from clip-space to screen-space. This operation is a perspective-division operation.</p><p>The reason for this is that the clip-space coordinates the vertex shader calculates are still coordinates that represent the point in 3D space. However, the screens we render to are a 2D plane. This means that the coordinates need to be adjusted to transform them from the 3D space into the 2D plane while correcting for the perspective the vertex is shown in.</p><p>This operation is done by GPUs automatically when the clip-space coordinates are provided through the <code>gl_Position</code> variable. But if we&#x27;re passing any clip-space coordinate from the vertex to the fragment shader (in our case, the clip-space coordinates of the vertex relative to the light source), it will interpolate the clip-space coordinates for that fragment correctly, but it won&#x27;t perform the perspective-division correction.</p><p>The shadow map we rendered is also in screen-space, not clip-space, so we cannot use the clip-space coordinates of the fragment directly. Instead, we would also need to perform the same correction that the GPU does for the vertex position automatically to get the screen-space coordinates of the fragment relative to the light source.</p><p>The second step is to adjust the range we get from the resulting screen-space coordinates to be in the same range as the values from the shadow map.</p><p>The range of the screen-space coordinates is from<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(-1, -1, -1)</code> to <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(1, 1, 1)</code>. However, the range of the depth values in the shadow map are from<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(0, 0, 0)</code> to <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(1, 1, 1)</code>.</p><p>If we divide the screen-space coordinates of our current fragment by 2, the range gets transformed to <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(-0.5, -0.5, -0.5)</code> -<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(0.5, 0.5, 0.5)</code>. We can then add<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->0.5</code> to the coordinates to get them into the range of <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(0, 0, 0)</code> to <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(1, 1, 1)</code>, which now matches the range of depth values from the shadow map, as well as the range of texel values of the shadow map texture (which ranges from <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(0, 0)</code> to <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->(1, 1)</code>).</p><p>This is what is done in line 25 in the fragment shader. The<!-- --> <code>xyz</code> coordinates are divided by the <code>w</code> <!-- -->coordinate of the fragment to perform the perspective division correction of the coordinates.</p><p>The <code>w</code> coordinate determines how much the coordinate needs to be adjusted by based on how the vertex is projected onto the screen, and dividing the coordinates by the value transforms the coordinates into screen-space based on the perspective of the projection matrix (orthogonal or 3D perspective).</p><p>The result is then multiplied by <code>0.5</code> to divide the coordinates by <code>2</code>, and then <code>0.5</code> is added to transform the coordinates into the right range.</p><p>Once done, the transformed coordinates (hereby referred to as shadow map coordinates) can now be used with the shadow map to check if the current fragment is visible to the light source or not.</p><p>The <code>xy</code> coordinates of the shadow map coordinates are used to sample the depth of the fragment closest to the light source at the position the current fragment is from the shadow map. This is done on line 26.</p><p>This depth value can then be compared against the <code>z</code> <!-- -->coordinate of the shadow map coordinates representing the depth value of the current fragment. If the depth value of the current fragment is greater than the depth value sampled from the shadow map, then the current fragment is in shadow and it&#x27;s visibility is set to<!-- --> <code>0</code>. Otherwise, the fragment is lit by the light source and it&#x27;s visibility is set to <code>1</code>. This is done on line 29.</p><p>The fragment visibility factor is then applied on the diffuse and specular lighting components that the light source contributes to, to apply the lighting only if the fragment is visible to the light source. In our case, we only have diffuse lighting, so it&#x27;s only applied to that.</p><p>While we do see the shadows are being rendered, there are some bad artifacts that are also being rendered into the scene. Let&#x27;s explore the common artifacts you would face when rendering shadows and how to overcome each of them.</p><h3 id="3-shadow-acne">Shadow acne<a href="#3-shadow-acne" aria-label="Link to section &quot;Shadow acne&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>The most obvious artifact present is the dark shadow stripes in the scene. This shadow artifact is called &quot;shadow acne&quot;. This artifact is caused by the imprecision from generating the shadow map. We can look at it more closely here:</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p>Shadow acne occurs due how the shadow map is rendered, with two main causes:</p><h4 id="4-1-shadow-map-resolution">1. Shadow map resolution<a href="#4-1-shadow-map-resolution" aria-label="Link to section &quot;1. Shadow map resolution&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h4><p>The shadow map can only contain as much detail as is allowed by its resolution.</p><p>If a fragment exists in the final rendered scene but not in the shadow map, and if the depth of the fragment it sampled from the map happened to be lower than it, then it will be incorrectly rendered to be in shadow even when it is visible to the light source.</p><p>This can be solved by increasing the resolution of the shadow to ensure as much detail of the scene from the perspective of the light source is captured.</p><p>However, increasing the resolution of the shadow map also means that you&#x27;re taxing the GPU more to render it as well, which is not ideal, especially for real-time performance scenarios.</p><p>This solution will also never fully fix shadow acne, which is the second (and primary) cause for shadow acne.</p><h4 id="4-2-precision-per-pixel-of-shadow-map">2. Precision per pixel of shadow map<a href="#4-2-precision-per-pixel-of-shadow-map" aria-label="Link to section &quot;2. Precision per pixel of shadow map&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h4><p>Each pixel in the shadow map is also limited by the number of bits used to store them. If we are storing high precision values in a low precision format, that loss of information can introduce errors result in fragments being rendered to be in shadow even if they are visible to the light soruce.</p><p>If we store the shadow map as a typical 32-bit color map, then each pixel can store 32 bits of information.</p><p>In our case, we were storing the entire depth value in each RGBA component of the shadow map separately. Since each color would have 8-bits of information, we were effectively storing the depth of the fragment as an 8-bit value, when it&#x27;s originally a 32-bit float.</p><p>Since we are converting a 32-bit value to 8 bits, we have lost a lot of precision. As a result when rendering the final scene and comparing the depth of the fragment to the stored value in, the inaccuracy of the depth of the stored fragment can result in some fragments being considered to be in shadow, even if they actually aren&#x27;t.</p><p>We could fix this in a few ways.</p><h5 id="5-i-better-fit-the-depth-value-into-the-resultant-pixel">i. Better fit the depth value into the resultant pixel<a href="#5-i-better-fit-the-depth-value-into-the-resultant-pixel" aria-label="Link to section &quot;i. Better fit the depth value into the resultant pixel&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h5><p>We could fix this in a few ways. Since we have a 32-bit float, instead of storing it in an 8-bit format in each component of the RGBA value, we can split the 32 bits into four 8 bit chunks, and store those as the final RGBA values instead.</p><p>This allows us to fully utlize the entire 32-bit range of the pixel data without losing any precision, and making comparisons accurate.</p><p>However, it may not always be possible to store the depth value at full precision. In such cases, we can make sure we utilize as much of the data value range as we possibly can to reduce shadow acne to a certain degree.</p><p>How does one utilize the full range of values possible to store in a pixel? We know that the depth coordinate we&#x27;re storing is a homogenous coordinate (where the value is between 0 and 1), with 0 representing being at the near plane of the light source&#x27;s &quot;camera&quot;, and 1 representing being at the far plane of the light source&#x27;s &quot;camera&quot;.</p><p>If we adjust this near and far plane such that the entire scene that we want to render into the shadow map just barely fits within those planes, then the depth values that will be stored in the shadow map will be more widely spread across that range, improving accuracy and reducing shadow acne.</p><p>We can see these two approaches implemented in the shadow map and final rendered scene below:</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Near Plane: 25.0
    Far Plane: 40.0</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75
    Near Plane: 25.0
    Far Plane: 40.0</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Shadow Map Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span></code><span style="color:#5c6370;font-style:italic">// Float to RGBA encoder from https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl</span><span>
</span><span></span><span style="color:#5c6370;font-style:italic">// which is based from https://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/</span><span>
</span><span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> encodeFloatToRgba (</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> v) {
</span><span>  </span><span style="color:#5c6370;font-style:italic">// We need to store the 32-bit float as four 8-bit float chunks (which we store as a vec4).</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// To do this, we first need to be able to shift the float number such that we can get each</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// 8-bit float chunk under each component.</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// Since we don&#x27;t have access to bit shift operators, we can instead use multiplication.</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// If we multiple a number by 0xff (255.0), we will have shifted that number 8 bits to the left.</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// Using this, for each component of the vec4, we can bit shift the 8-bits we need from the original</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// float value, subtract any additional precision we don&#x27;t need to store under that component,</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// and then store that as the final RGBA value.</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// First we generate an encoding vector that will shift the float by the appropriate bits for each</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// vector component.</span><span>
</span><span>  </span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> bitsToEncode = </span><span style="color:#d19a66">vec4</span><span>(
</span><span>    </span><span style="color:#d19a66">1.0</span><span>,       </span><span style="color:#5c6370;font-style:italic">// Shifting the number  0 [255.0 ^ 0] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">255.0</span><span>,     </span><span style="color:#5c6370;font-style:italic">// Shifting the number  8 [255.0 ^ 1] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">65025.0</span><span>,   </span><span style="color:#5c6370;font-style:italic">// Shifting the number 16 [255.0 ^ 2] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">16581375.0</span><span> </span><span style="color:#5c6370;font-style:italic">// Shifting the number 24 [255.0 ^ 3] bits for this component.</span><span>
</span>  );
<!-- -->
<span>  </span><span style="color:#5c6370;font-style:italic">// We multiply the float against the encoder vector above to get the appropriate number of bit-shifts</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// for each component. But for each of them we don&#x27;t care about the integer parts, just the fractional</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// parts, so we use the `fract` function to discard the integer parts from each component.</span><span>
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> enc = </span><span style="color:#e6c07b">fract</span><span>(bitsToEncode * v);
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// Now each component doesn&#x27;t just contain the bits of data for their respective positions, but also</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// the bits of data for each component after it. This needs to be subtracted so that each component</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// only contains the 8-bits of information of for its own component, discarding that additional data away</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// We do this by getting the vector for each succeeding component, dividing it by 255 so that the result</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// value now equals how it is actually stored in the current component, and then just subtract that result</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// from the original value to get the final vec4 where each component contains just the 8-bit chunk that</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// it represents.</span><span>
</span><span>  enc -= enc.yzww * </span><span style="color:#d19a66">vec2</span><span>(</span><span style="color:#d19a66">1.0</span><span> / </span><span style="color:#d19a66">255.0</span><span>, </span><span style="color:#d19a66">0.0</span><span>).xxxy;
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// Now we can return our final calculated RGBA vector.</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> enc;
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span> = encodeFloatToRgba(</span><span style="color:#e6c07b">gl_FragCoord</span><span>.z);
</span>}</code></pre><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span><span class="react-syntax-highlighter-line-number">49
</span><span class="react-syntax-highlighter-line-number">50
</span><span class="react-syntax-highlighter-line-number">51
</span><span class="react-syntax-highlighter-line-number">52
</span><span class="react-syntax-highlighter-line-number">53
</span><span class="react-syntax-highlighter-line-number">54
</span><span class="react-syntax-highlighter-line-number">55
</span><span class="react-syntax-highlighter-line-number">56
</span><span class="react-syntax-highlighter-line-number">57
</span><span class="react-syntax-highlighter-line-number">58
</span><span class="react-syntax-highlighter-line-number">59
</span><span class="react-syntax-highlighter-line-number">60
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#5c6370;font-style:italic">// Float to RGBA encoder from https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl</span><span>
</span><span></span><span style="color:#5c6370;font-style:italic">// which is based from https://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/</span><span>
</span><span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> decodeFloatFromRgba(</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> v) {
</span><span>  </span><span style="color:#5c6370;font-style:italic">// We need to convert our RGBA vec4 value back to the 32-bit float it represents.</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// To do this, we just need to reverse the process we did originally. Since each component represents</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// an 8-bit chunk of the original float, we just need to shift each component the appropriate number of</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// bits and then just add them all up together to get the original float back.</span><span>
</span>
<span>  </span><span style="color:#5c6370;font-style:italic">// First we generate a decoding vector that will shift the float by the appropriate bits for each</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// vector component.</span><span>
</span><span>  </span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> bitsToDecode = </span><span style="color:#d19a66">vec4</span><span>(
</span><span>    </span><span style="color:#d19a66">1.0</span><span> / </span><span style="color:#d19a66">1.0</span><span>,       </span><span style="color:#5c6370;font-style:italic">// Shifting the number  0 [255.0 ^ 0] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">1.0</span><span> / </span><span style="color:#d19a66">255.0</span><span>,     </span><span style="color:#5c6370;font-style:italic">// Shifting the number  8 [255.0 ^ 1] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">1.0</span><span> / </span><span style="color:#d19a66">65025.0</span><span>,   </span><span style="color:#5c6370;font-style:italic">// Shifting the number 16 [255.0 ^ 2] bits for this component.</span><span>
</span><span>    </span><span style="color:#d19a66">1.0</span><span> / </span><span style="color:#d19a66">16581375.0</span><span> </span><span style="color:#5c6370;font-style:italic">// Shifting the number 24 [255.0 ^ 3] bits for this component.</span><span>
</span>  );
<!-- -->
<span>  </span><span style="color:#5c6370;font-style:italic">// Once done, we multiply this vector against the RGBA vector to shift each component the appropriate</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// number of places and add them all up together: (x1 * x2) + (y1 * y2) + (z1 * z2) + (w1 * w2).</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// Luckily we have a vector operation that does this called the dot product, so we can just use that</span><span>
</span><span>  </span><span style="color:#5c6370;font-style:italic">// and return the result.</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> </span><span style="color:#e6c07b">dot</span><span>(v, bitsToDecode);
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) </span><span style="color:#5c6370;font-style:italic">/* / (distanceFromLight * distanceFromLight) */</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = decodeFloatFromRgba(</span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy));
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = currentDepth &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>We can see from the above results that by splitting the depth value into chunks to be stored across the entire RGBA fragment color value, and by adjusting our near and far planes to stretch the scene across the entire depth range we&#x27;ve fixed our shadow acne issue.</p><p>For our case this was possible because our depth value (which is 32 bits) was possible to store without losing any precision as an RGBA color value.</p><p>However, it may be more common to not be able to store these values in full precision in the shadow map, as a result there will always be some amount of shadow acne generated in the final scene.</p><p>To completely remove the issue of shadow acne, we can follow the next solution.</p><h5 id="5-ii-use-a-bias-value">ii. Use a bias value<a href="#5-ii-use-a-bias-value" aria-label="Link to section &quot;ii. Use a bias value&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h5><p>The best (and most common) approach to removing shadow approach is to introduce a bias value to the comparison called an acne bias/depth bias.</p><p>The bias value allows you to set a threshold for how close the depth of the current fragment in the final scene has to be compared to the depth value read from the shadow map.</p><p>If the difference in distance is within the threshold defined by the bias value, then the fragment is considered to be visible to the light source and lit accordingly.</p><p>We can see this solution in action below:</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) </span><span style="color:#5c6370;font-style:italic">/* / (distanceFromLight * distanceFromLight) */</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy).z;
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> acneBias = </span><span style="color:#d19a66">0.00575</span><span>;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = (currentDepth - acneBias) &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>From the result, we can see that by introducing the acne bias value (in line 28) and using it as part of the depth comparison (in line 30), we were able to remove the shadow acne completely.</p><p>However, this solution does introduce a new problem that we will look at in the next section.</p><h5 id="5-iii-move-the-shadow-acne-to-parts-already-in-shadow">iii. Move the shadow acne to parts already in shadow<a href="#5-iii-move-the-shadow-acne-to-parts-already-in-shadow" aria-label="Link to section &quot;iii. Move the shadow acne to parts already in shadow&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h5><p>There is one more approach that could be taken with &quot;fixing&quot; the shadow acne, which is to make sure it only occurs in the areas of the scene under shadow.</p><p>Traditionally when rendering a scene, we have the GPU cull the back faces of the object that are not facing towards the camera. This saves on time that would otherwise be spent rendering faces that are hidden from us.</p><p>The shadow acne problem we&#x27;re facing is occuring on the faces that we render in the shadow map, the ones that are visible to the light source.</p><p>If we instead render the back faces of the objects in the shadow map, and cull the front faces, now the shadow acne problem will only occur on the faces of the objects that are not visible to the light, and hence should be in shadow.</p><p>Since those faces would not be lit anyways, the shadow acne problem should not affect the scene in any way.</p><p>However, this solution doesn&#x27;t work always. If you&#x27;re scene has very thin geometry, where the front and back faces are basically at the same depth (considering the imprecision in the shadow map), or parts of the scene are touching/connected to each other within the imprecision margin of the shadow map, then shadows may appear to &quot;hover&quot; slightly.</p><p>For this reason, you may need to evaluate on a per light basis on whether using front-culling in the shadow map is possible or not.</p><p>Now let&#x27;s look at the second problem we&#x27;re facing from using the acne bias solution.</p><h3 id="3-peter-panning">Peter-panning<a href="#3-peter-panning" aria-label="Link to section &quot;Peter-panning&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>Looking at the final rendered scene using the acne bias solution, we can clearly see that the shadow projected by the wall is &quot;hovering&quot;.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p>This &quot;hovering&quot; is called &quot;Peter-Panning&quot;, being named after the fictional character Peter Pan and his ability to fly.</p><p>This problem does occur with the other solutions as well. You can spot the shadow in the first solution to the shadow acne problem hovering slightly on the edge, and we mentioned that this occurs in the third solution as well.</p><p>The solution to shadow peter-panning is to update the scene to make the geometry thicker. This will push the rendered fragments in the shadow map close enough to the light source to counter the peter-panning effect introduced by the acne-bias/imprecision from the shadow map.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p>You can see from the above example that by making the floor and walls thicker the peter-panning problem now no longer exists</p><p>When using the third solution for the shadow acne problem, this won&#x27;t fix the issue because we&#x27;re rendering the faces that are not visible to the light source. So no matter how thick we make the geometry, the resultant shadow map will still be the same in the areas where peter-panning occurs.</p><p>However, when using the other two solutions for the shadow acne problem, this fix should work well.</p><p>Now let&#x27;s further zoom into the edges of the shadow to find another problem.</p><h3 id="3-shadow-aliasing">Shadow aliasing<a href="#3-shadow-aliasing" aria-label="Link to section &quot;Shadow aliasing&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>If we zoom in to the edges of the shadow we can spot another problem - aliasing.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p>This problem is caused mainly by the resolution of the shadow map. We can increase the resolution to reduce the amount of aliasing, but this will not completely remove the aliasing artifacts from the shadows.</p><h3 id="3-percentage-closer-filtering-pcf">Percentage-Closer Filtering (PCF)<a href="#3-percentage-closer-filtering-pcf" aria-label="Link to section &quot;Percentage-Closer Filtering (PCF)&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>Instead of increasing the shadow map resolution, we can implement a form of anti-aliasing calculation when determining whether a fragment is in shadow or not to blur the edges of the shadow and smoothen it to a certain degree.</p><p>This can be done by checking whether the current fragment is close to the edge of the shadow within a certain range. If it is, then it is set to be partially in shadow proportional to its distance from the shadow edge, and then rendered accordingly.</p><p>This sort of anti-aliasing algorithm where we&#x27;re shading the fragment to be in shadow based on how close it is to the shadow edge is called Percentage-Closer Filtering.</p><p>There are a wide variety of PCF algorithms that can be used to smoothen the edges of shadows, or make it more appealing or realistic. However, for our example we&#x27;ll go with a simple PCF algorithm.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 1.000, g: 1.000, b: 1.000 }
    Intensity: 0.75</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> texelSize;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> acneBias = </span><span style="color:#d19a66">0.0175</span><span>;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> getAverageVisibility(</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> shadowMapCoords, </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth) {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> visibility = </span><span style="color:#d19a66">0.0</span><span>;
</span><span>  </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> x = </span><span style="color:#d19a66">-2</span><span>; x &lt;= </span><span style="color:#d19a66">2</span><span>; x++) {
</span><span>    </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> y = </span><span style="color:#d19a66">-2</span><span>; y &lt;= </span><span style="color:#d19a66">2</span><span>; y++) {
</span><span>      </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy + (</span><span style="color:#d19a66">vec2</span><span>(x, y) * texelSize)).z;
</span><span>      visibility += currentDepth - acneBias &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>    }
<!-- -->  }
<span>  </span><span style="color:#c678dd">return</span><span> visibility / </span><span style="color:#d19a66">25.0</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>  
<span>  </span><span style="color:#5c6370;font-style:italic">// highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);</span><span>
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) </span><span style="color:#5c6370;font-style:italic">/* / (distanceFromLight * distanceFromLight) */</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = getAverageVisibility(shadowMapCoords.xy, currentDepth);
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>Previously we were setting the <code>fragmentVisibility</code> value to either <code>0</code> or <code>1</code> based on if its depth was lower than the depth recorded in the shadow map.</p><p>However, this time we&#x27;ll be calculating an &quot;average&quot; visibility value for the fragment using a PCF algorithm, so we&#x27;ve created a function<!-- --> <code>getAverageVisibility</code> to calculate this value on line 22.</p><p>Normally we just sample the shadow map depth value at the coordinate the current fragment is supposed to be located at.</p><p>As part of our PCF algorithm, we will also be sampling the depth value at various coordinates surrounding the coordinate where our current fragment is located.</p><p>We iterate through the shadow map coordinates using two nested loops on line 24 and 25, getting the depth values of all fragments that are at most 2 units away from the position of the current fragment in both the X and Y coordinates.</p><p>We then compare all of them to the depth of the current fragment and sum the visibilities based on the comparison results.</p><p>This is then divided by the number of samples taken in total, thereby giving us the average visibility of the fragment across all shadow map samples taken.</p><p>This results in the shadow softening near the edge as the average visibility slowly reduces till the fragments are far enough away from the shadow edge.</p><p>This can be seen in the end result, with the shadow in the main view having the &quot;stair-case&quot; effect caused by the aliasing being reduced, and the shadow edge looking blurrier compared to before in the zoomed example.</p><p>As said before, there are a wide variety of PCF algorithms that can be used to soften shadow edges and reduce the aliasing effect. They all have their benefits and drawbacks based on performance and appearance.</p><p>We&#x27;ve showcased a very simple PCF algorithm to show how it&#x27;s implemented, and recommend exploring other PCF algorithms and see how the behave.</p><p>This covers how to render shadows for directional lights, and also a look into the various issues that crop up when rendering shadows and how to solve them.</p><p>Next lets look at how to render shadows for some other types of lights, and implementing the same solutions we&#x27;ve learnt here for solving the problems we face when rendering shadows.</p><p>With the other lights we&#x27;ll be looking at, they are considered to be a finite distance away, and so follow the typical lighting calculations we were using in the<!-- --> <a href="/intermediates/lighting/">lighting chapter</a> (with intensity of the light reducing with distance).</p><h2 id="2-spot-light">Spot light<a href="#2-spot-light" aria-label="Link to section &quot;Spot light&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><p>Spot lights represent the typical light sources we see. The light originates from a single point, covering a certain area of the scene, and is considered to be a normal light source (considered to be a finite distance away with intensity dropping with increase in distance).</p><p>Since the light from spot light originates from a single point, with the rays not being parallel, they more accurately represent traditional lights we see, such as bulbs, street lights, lamps, etc.</p><p>The approach for generating shadows for spot lights is similar to directional lights, with the main differences being:</p><ul><li>The lighting calculation now does consider intensity reduction with increase in distance, as is generally done (unlike with directional lights).</li><li>The projection matrix used for the light&#x27;s point of view is a 3D perspective matrix instead of an orthogonal one (which was used for the directional light).</li></ul><p>The reason for using a 3D perspective matrix for the projection matrix instead of an orthogonal one is because the orthogonal projection for the shadow map would work if the rays of light are travelling in parallel.</p><p>However, in the case of spot lights, the rays are not travelling in parallel. They instead project from a single point and extend in various directions, with the rays generally following the same direction as the light source is facing.</p><p>A 3D perspective projection is the one that would accurately reflect this in the shadow map, hence why it is used for generating the spot light&#x27;s shadow map.</p><p>Let&#x27;s look at how the shadow map and the final scene look under a spot light.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }</pre><pre class="util text-left">Light:
    World Position: { x: -3.000, y: 10.000, z: -6.000 }</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    World Position: { x: -3.000, y: 10.000, z: -6.000 }
    Color: { r: 0.300, g: 0.300, b: 0.300 }
    Intensity: 300</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Vertex Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span></code><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition;
</span><span></span><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec3</span><span> vertexNormal;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> modelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> viewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> projectionMatrix;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightModelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightViewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> lightProjectionMatrix;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition_worldSpace = modelMatrix * vertexPosition;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;
</span>  
<span>  </span><span style="color:#e6c07b">gl_Position</span><span> = projectionMatrix * vertexPosition_viewSpace;
</span>
<!-- -->  fragmentPosition_worldSpace = vertexPosition_worldSpace;
<!-- -->  fragmentPositionFromLight = lightProjectionMatrix * lightViewMatrix * lightModelMatrix * vertexPosition;
<!-- -->  
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;
</span><span>  fragmentNormal_viewSpace = (viewMatrix * modelMatrix * </span><span style="color:#d19a66">vec4</span><span>(vertexNormal, </span><span style="color:#d19a66">0.0</span><span>)).xyz;
</span><span>  lightDirection_viewSpace = </span><span style="color:#e6c07b">normalize</span><span>((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);
</span>}</code></pre><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> texelSize;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> acneBias = </span><span style="color:#d19a66">0.025</span><span>;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> getAverageVisibility(</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> shadowMapCoords, </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth) {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> visibility = </span><span style="color:#d19a66">0.0</span><span>;
</span><span>  </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> x = </span><span style="color:#d19a66">-2</span><span>; x &lt;= </span><span style="color:#d19a66">2</span><span>; x++) {
</span><span>    </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> y = </span><span style="color:#d19a66">-2</span><span>; y &lt;= </span><span style="color:#d19a66">2</span><span>; y++) {
</span><span>      </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy + (</span><span style="color:#d19a66">vec2</span><span>(x, y) * texelSize)).z;
</span><span>      visibility += currentDepth - acneBias &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>    }
<!-- -->  }
<span>  </span><span style="color:#c678dd">return</span><span> visibility / </span><span style="color:#d19a66">25.0</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> distanceFromLight = </span><span style="color:#e6c07b">distance</span><span>(fragmentPosition_worldSpace, lightPosition_worldSpace);
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = getAverageVisibility(shadowMapCoords.xy, currentDepth);
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>We can see that switching to the 3D perspective projection matrix has changed the way the shadow map has rendered. The code for rendering the shadow map itself is the same as before, with the only change being the projection matrix that is passed to it.</p><p>The shader for rendering the final scene is also practically the same as well, with the only difference being the <code>getDiffuseLighting</code>, which uses the same way we calculated diffuse lighting in the<!-- --> <a href="/intermediates/lighting/">lighting chapter</a>.</p><h2 id="2-area-light">Area light<a href="#2-area-light" aria-label="Link to section &quot;Area light&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><p>Area lights are similar to directional lights, with the only distance being that they are considered to be a finite distance away, and the intensity of their light does reduce with increase in distance.</p><p>These lights are for representing flat plane lights that only light up the area that they directly face, rather than traditional lights which spot lights are better for.</p><p>Let&#x27;s look at how the shadow map and the final scene look under an area light.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    Direction: { x: 0.267, y: -0.802, z: 0.535 }
    Color: { r: 0.500, g: 0.500, b: 0.500 }
    Intensity: 1000</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span><span class="react-syntax-highlighter-line-number">49
</span><span class="react-syntax-highlighter-line-number">50
</span><span class="react-syntax-highlighter-line-number">51
</span><span class="react-syntax-highlighter-line-number">52
</span><span class="react-syntax-highlighter-line-number">53
</span><span class="react-syntax-highlighter-line-number">54
</span><span class="react-syntax-highlighter-line-number">55
</span><span class="react-syntax-highlighter-line-number">56
</span><span class="react-syntax-highlighter-line-number">57
</span><span class="react-syntax-highlighter-line-number">58
</span><span class="react-syntax-highlighter-line-number">59
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPositionFromLight;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> texelSize;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightDirection_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">sampler2D</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> acneBias = </span><span style="color:#d19a66">0.005</span><span>;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> getAverageVisibility(</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec2</span><span> shadowMapCoords, </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth) {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> visibility = </span><span style="color:#d19a66">0.0</span><span>;
</span><span>  </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> x = </span><span style="color:#d19a66">-2</span><span>; x &lt;= </span><span style="color:#d19a66">2</span><span>; x++) {
</span><span>    </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> y = </span><span style="color:#d19a66">-2</span><span>; y &lt;= </span><span style="color:#d19a66">2</span><span>; y++) {
</span><span>      </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">texture2D</span><span>(shadowMapTextureSampler, shadowMapCoords.xy + (</span><span style="color:#d19a66">vec2</span><span>(x, y) * texelSize)).z;
</span><span>      visibility += currentDepth - acneBias &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>    }
<!-- -->  }
<span>  </span><span style="color:#c678dd">return</span><span> visibility / </span><span style="color:#d19a66">25.0</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> getDistanceFromLight() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightPlaneNormal = </span><span style="color:#e6c07b">normalize</span><span>(lightDirection_worldSpace.xyz);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightPlaneDistanceFromOrigin = (</span><span style="color:#d19a66">0.0</span><span> - (lightPlaneNormal.x * lightPosition_worldSpace.x)
</span>                                                  - (lightPlaneNormal.y * lightPosition_worldSpace.y)
<!-- -->                                                  - (lightPlaneNormal.z * lightPosition_worldSpace.z)
<span>                                             ) / </span><span style="color:#e6c07b">length</span><span>(lightPlaneNormal);
</span>
<span>  </span><span style="color:#c678dd">return</span><span> </span><span style="color:#e6c07b">abs</span><span>(</span><span style="color:#e6c07b">dot</span><span>(lightPlaneNormal, fragmentPosition_worldSpace.xyz) + lightPlaneDistanceFromOrigin);
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> distanceFromLight = getDistanceFromLight();
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> shadowMapCoords = (fragmentPositionFromLight.xyz / fragmentPositionFromLight.w) * </span><span style="color:#d19a66">0.5</span><span> + </span><span style="color:#d19a66">0.5</span><span>;
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = shadowMapCoords.z;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = getAverageVisibility(shadowMapCoords.xy, currentDepth);
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>The shadow map is rendered exactly the same way as with directional lights, so they will look exactly the same as well. When it comes to rendering the final scene, the main difference compared to spot lights is how the distance is calculated from the light source.</p><p>With spot lights, the rays originate from a single point. So when calculating the distance of the fragment from the light source, we just need to calculate the distance between two points.</p><p>With area lights, however, the rays of light don&#x27;t originate from a single point, but instead from a plane, with all rays being parallel to each other.</p><p>However, the only information we have about the light source is a single point on the plane (which we can consider to be the center of the plane), and the direction the plane is facing.</p><p>In order to calculate the distance of the current fragment from the light source, we need to find the point on the light plane whose ray is travelling in the direction of the light source towards the fragment, and then calculate the distance between that point and the fragment. This would also be the shortest distance of the fragment from the plane.</p><p>Luckily, there is a way to describe a plane when given a point on the plane and the direction the plane is facing (also called the normal of the plane). The equation that describes a plane using these two parameters is called the Point-Normal Form (PNF) of a plane. You can learn more about this<!-- --> <a target="_blank" rel="noopener noreferrer" href="https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces/dot-cross-products/v/defining-a-plane-in-r3-with-a-point-and-normal-vector">here</a>.</p><p>In order to conveniently calculate the distance of a point, the equation of the plane needs to be converted from PNF to an equation called the Hessian-Normal Form (HNF) of the plane. Once this conversion is made, then calculating the distance of a point from the plane is very simple. You can learn more about this<!-- --> <a target="_blank" rel="noopener noreferrer" href="https://mathworld.wolfram.com/HessianNormalForm.html">here</a>.</p><p>This calculation is done in the <code>getDistanceFromLight</code> <!-- -->function at line 28 in the final scene fragment shader.</p><p>The standard equation for representing a plane is<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->ax + by + cz + d = 0</code>. If you know a point on the plane <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->P = (x_0, y_0, z_0)</code>, and the normal of the plane <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->hat N = (n_x, n_y, n_z)</code>, you can calculate the equation of the plane using the PNF equation<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->n_x(x - x_0) + n_y(y - y_0) + n_z(z - z_0) = 0 =&gt; n_xx + n_yy + n_zz + (- n_x x_0 - n_y y_0 - n_z z_0) = 0 </code>, where<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->a = n_x , b = n_y , c = n_z , d = - n_x x_0 - n_y y_0 - n_z z_0</code>.</p><p>This can then be converted to the HNF form of the plane using the formula <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->hat N cdot x = - p</code>, where<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->x</code> is a point, and<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->p = d / sqrt (a^2 + b^2 + c^2) = (- n_x x_0 - n_y y_0 - n_z z_0) / sqrt (n_x^2 + n_y^2 + n_z^2) = (- n_x x_0 - n_y y_0 - n_z z_0) / norm(hat N)</code>. <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->p</code> can be considered as the shortest distance of the plane from the origin.</p><p>Once done, then the distance between the plane and a point<!-- --> <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->x = (x_1, y_2, z_2)</code> can be calculated using the formula <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->D = hat n cdot x + p</code></p><p>In line 29 we first calculate the normalized form of the normal of the light plane. With this normal, we calculate <code style="display:inline-block;padding:0.5rem;margin:0.5rem">[AsciiMath Syntax:] <!-- -->p</code> (the distance of the plane from the origin) in line 30 - 33 using the formula we derived above.</p><p>And finally, we calculate the distance of the fragment from the plane by calculating the dot vector between the normal of the plane and the position of the fragment, and then adding the distance of the plane from the origin.</p><p>This distance formula is then used as part of the diffuse lighting calculation as normal.</p><p>Using this specific way of calculating the distance of the fragment from the light source can be ignored, with the standard method being used, if the inaccuracy from calculating the distance using the standard method compared to the accurate way is within a margin of error you set. This would help with improving the performance of the shader as well.</p><h2 id="2-point-light">Point light<a href="#2-point-light" aria-label="Link to section &quot;Point light&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><p>Point lights are a special type of spot light. While spot light only lights up an area in a general direction, point lights radiate light in all directions.</p><p>So far, we&#x27;ve been storing the shadow map as a simple 2D texture, as all the lights we&#x27;ve seen so far point in a single general direction.</p><p>However, with point lights, we need to capture the scene across all 6 axis directions (+X, -X, +Y, -Y, +Z, -Z). For this, we would need to use 6 textures to capture each direction.</p><p>There is special kind of texture that GPUs support that fit these kinds of use cases. They are called cube map textures. These textures represent faces of a cube, with each face representing a direction along an axis, with each face being its own 2D texture.</p><p>To read a value from a cube map, you provide a direction from the origin of the cube map to read the value stored in the cube map in that direction.</p><p>We&#x27;ll learn more about cube maps and some ways to use them in the<!-- --> <a href="/advanced/cube-maps/">next chapter</a>.</p><p>We can use a cube map to store all 6 directions of the shadow map generated by a point light, and then read from this shadow cube map by calculating the direction from the light source to the fragment, and then read from the cube map in that direction.</p><p>When rendering the shadow cube map, we create view matrices for each axis direction of the point light, and then render each face with those view matrices.</p><p>Each face of the shadow cube map is rendered through separate render passes in our examples, but with certain languages/frameworks it is possible to render all six faces under one render pass.</p><p>However, due to WebGL not supporting this behavior, and also for the sake of simplicity, we&#x27;ll be sticking with showing shaders for rendering a single face at a time.</p><p>Now let&#x27;s look at how the shadow cube map of a point light is rendered to capture the scene in all directions.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><select><option value="0">+X-Axis Face</option><option value="1">-X-Axis Face</option><option value="2">+Y-Axis Face</option><option value="3" selected="">-Y-Axis Face</option><option value="4">+Z-Axis Face</option><option value="5">-Z-Axis Face</option></select><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }</pre><pre class="util text-left">Light:
    World Position: { x: 0.000, y: 3.000, z: -1.500 }</pre><pre class="util text-left">Face:
    Center: { x: 0.000, y: 2.000, z: -1.500 }
    Up: { x: 0.000, y: 0.000, z: 1.000 }</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Shadow Map Vertex Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span></code><span style="color:#c678dd">attribute</span><span> </span><span style="color:#d19a66">vec4</span><span> vertexPosition;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> modelMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> viewMatrix;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">mat4</span><span> projectionMatrix;
</span>
<span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentPosition_worldSpace;
</span>
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> vertexPosition_worldSpace = (modelMatrix * vertexPosition).xyz;
</span><span>  </span><span style="color:#e6c07b">gl_Position</span><span> = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;
</span>
<!-- -->  fragmentPosition_worldSpace = vertexPosition_worldSpace;
<!-- -->}</code></pre><p><strong>Shadow Map Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentPosition_worldSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_worldSpace;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> farPlane;
</span>
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span> = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">vec3</span><span>(</span><span style="color:#e6c07b">distance</span><span>(fragmentPosition_worldSpace, lightPosition_worldSpace.xyz) / farPlane), </span><span style="color:#d19a66">1.0</span><span>);
</span>}</code></pre><p>For rendering previous shadow maps, we took the depth of the fragment from <code>gl_FragCoord.z</code> and saved that in the shadow map. However, for point light shadow maps, we can&#x27;t use this value, and need to store our own calculated depth value instead.</p><p>To do this, we calculate the distance between the light and the fragment, and then divide that distance by the far plane of the light&#x27;s &quot;camera&quot;, so that the distance is normalized to be between 0 and 1. This is the final depth value we store in the shadow cube map.</p><p>To calculate this depth value, we pass the vertex position from the vertex shader to the fragment shader, allowing the GPU to interpolate the position for each fragment as a result, and get the position of the light and the far plane of the light&#x27;s camera. using a uniform variable.</p><p>Next let&#x27;s look at how we use these recorded depth values when rendering the final scene.</p><div style="padding:2rem;margin:2rem 0;border:1px dashed #dddddd"><div class="util text-center" style="padding:1rem"><canvas width="640" height="480">Cannot run WebGL examples (not supported)</canvas><pre class="util text-left">Scene:
    World Position: { x: 0.000, y: 0.000, z: 0.000 }
    Lighting:
        Ambient Factor: 0.1</pre><pre class="util text-left">Light:
    World Position: { x: 0.000, y: 3.000, z: -1.500 }
    Color: { r: 0.300, g: 0.300, b: 0.300 }
    Intensity: 20</pre></div><div style="padding:1rem;text-align:center"><button class="example-view-link">Hide example</button></div></div><p><strong>Final Scene Fragment Shader<!-- --> Code:</strong></p><pre class="glsl-code" style="display:block;overflow-x:auto;padding:0;color:#abb2bf"><code style="white-space:pre;display:inline-block"><code style="display:inline-block;float:left;font-size:100%;padding-right:1.5rem;margin-right:1.5rem;border-right:0.2rem dashed #9b4dca;border-radius:0;white-space:inherit"><span class="react-syntax-highlighter-line-number">1
</span><span class="react-syntax-highlighter-line-number">2
</span><span class="react-syntax-highlighter-line-number">3
</span><span class="react-syntax-highlighter-line-number">4
</span><span class="react-syntax-highlighter-line-number">5
</span><span class="react-syntax-highlighter-line-number">6
</span><span class="react-syntax-highlighter-line-number">7
</span><span class="react-syntax-highlighter-line-number">8
</span><span class="react-syntax-highlighter-line-number">9
</span><span class="react-syntax-highlighter-line-number">10
</span><span class="react-syntax-highlighter-line-number">11
</span><span class="react-syntax-highlighter-line-number">12
</span><span class="react-syntax-highlighter-line-number">13
</span><span class="react-syntax-highlighter-line-number">14
</span><span class="react-syntax-highlighter-line-number">15
</span><span class="react-syntax-highlighter-line-number">16
</span><span class="react-syntax-highlighter-line-number">17
</span><span class="react-syntax-highlighter-line-number">18
</span><span class="react-syntax-highlighter-line-number">19
</span><span class="react-syntax-highlighter-line-number">20
</span><span class="react-syntax-highlighter-line-number">21
</span><span class="react-syntax-highlighter-line-number">22
</span><span class="react-syntax-highlighter-line-number">23
</span><span class="react-syntax-highlighter-line-number">24
</span><span class="react-syntax-highlighter-line-number">25
</span><span class="react-syntax-highlighter-line-number">26
</span><span class="react-syntax-highlighter-line-number">27
</span><span class="react-syntax-highlighter-line-number">28
</span><span class="react-syntax-highlighter-line-number">29
</span><span class="react-syntax-highlighter-line-number">30
</span><span class="react-syntax-highlighter-line-number">31
</span><span class="react-syntax-highlighter-line-number">32
</span><span class="react-syntax-highlighter-line-number">33
</span><span class="react-syntax-highlighter-line-number">34
</span><span class="react-syntax-highlighter-line-number">35
</span><span class="react-syntax-highlighter-line-number">36
</span><span class="react-syntax-highlighter-line-number">37
</span><span class="react-syntax-highlighter-line-number">38
</span><span class="react-syntax-highlighter-line-number">39
</span><span class="react-syntax-highlighter-line-number">40
</span><span class="react-syntax-highlighter-line-number">41
</span><span class="react-syntax-highlighter-line-number">42
</span><span class="react-syntax-highlighter-line-number">43
</span><span class="react-syntax-highlighter-line-number">44
</span><span class="react-syntax-highlighter-line-number">45
</span><span class="react-syntax-highlighter-line-number">46
</span><span class="react-syntax-highlighter-line-number">47
</span><span class="react-syntax-highlighter-line-number">48
</span><span class="react-syntax-highlighter-line-number">49
</span><span class="react-syntax-highlighter-line-number">50
</span><span class="react-syntax-highlighter-line-number">51
</span></code><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> fragmentPosition_worldSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentNormal_viewSpace;
</span><span></span><span style="color:#c678dd">varying</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightDirection_viewSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> lightIntensity;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> lightPosition_worldSpace;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> ambientFactor;
</span><span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> farPlane;
</span>
<span></span><span style="color:#c678dd">uniform</span><span> </span><span style="color:#d19a66">samplerCube</span><span> shadowMapTextureSampler;
</span>
<span></span><span style="color:#c678dd">const</span><span> </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> acneBias = </span><span style="color:#d19a66">0.02</span><span>;
</span>
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> getAverageVisibility(</span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentPosition_lightSpace) {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> currentDepth = </span><span style="color:#e6c07b">length</span><span>(fragmentPosition_lightSpace) / farPlane;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentDirection_lightSpace = </span><span style="color:#e6c07b">normalize</span><span>(fragmentPosition_lightSpace);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> visibility = </span><span style="color:#d19a66">0.0</span><span>;
</span><span>  </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> xi = </span><span style="color:#d19a66">-2</span><span>; xi &lt;= </span><span style="color:#d19a66">2</span><span>; xi++) {
</span><span>    </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> yi = </span><span style="color:#d19a66">-2</span><span>; yi &lt;= </span><span style="color:#d19a66">2</span><span>; yi++) {
</span><span>      </span><span style="color:#c678dd">for</span><span> (</span><span style="color:#d19a66">int</span><span> zi = </span><span style="color:#d19a66">-2</span><span>; zi &lt;= </span><span style="color:#d19a66">2</span><span>; zi++) {
</span><span>        </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> closestDepth = </span><span style="color:#e6c07b">textureCube</span><span>(shadowMapTextureSampler, fragmentDirection_lightSpace + (</span><span style="color:#d19a66">vec3</span><span>(xi, yi, zi) * </span><span style="color:#d19a66">0.02</span><span>)).z;
</span><span>        visibility += currentDepth - acneBias &gt; closestDepth ? </span><span style="color:#d19a66">0.0</span><span> : </span><span style="color:#d19a66">1.0</span><span>;
</span>      }
<!-- -->    }
<!-- -->  }
<span>  </span><span style="color:#c678dd">return</span><span> visibility / </span><span style="color:#d19a66">125.0</span><span>;
</span>}
<!-- -->
<span></span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> getDiffuseLighting() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> lightColorIntensity = lightColor * lightIntensity;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> diffuseStrength = </span><span style="color:#e6c07b">clamp</span><span>(</span><span style="color:#e6c07b">dot</span><span>(fragmentNormal_viewSpace, lightDirection_viewSpace), </span><span style="color:#d19a66">0.0</span><span>, </span><span style="color:#d19a66">1.0</span><span>);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> distanceFromLight = </span><span style="color:#e6c07b">distance</span><span>(fragmentPosition_worldSpace, lightPosition_worldSpace);
</span><span>  </span><span style="color:#c678dd">return</span><span> (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);
</span>}
<!-- -->
<span></span><span style="color:#d19a66">void</span><span> main() {
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> surfaceColor = </span><span style="color:#d19a66">vec4</span><span>(</span><span style="color:#d19a66">1.0</span><span>);
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec4</span><span> ambientColor = </span><span style="color:#d19a66">vec4</span><span>(surfaceColor);
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> diffuseLight = getDiffuseLighting();
</span>
<span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">vec3</span><span> fragmentPosition_lightSpace = (fragmentPosition_worldSpace - lightPosition_worldSpace).xyz;
</span><span>  </span><span style="color:#c678dd">highp</span><span> </span><span style="color:#d19a66">float</span><span> fragmentVisibility = getAverageVisibility(fragmentPosition_lightSpace);
</span>
<span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.rgb = (ambientColor.rgb * ambientFactor) + (fragmentVisibility * surfaceColor.rgb * diffuseLight);
</span><span>  </span><span style="color:#e6c07b">gl_FragColor</span><span>.a = surfaceColor.a;
</span>}</code></pre><p>As discussed previously, to read the recorded depth value from the shadow cube map, we need to calculate the direction of the current fragment from the light source. This direction vector is then used as a coordinate to read from the cube map.</p><p>To compare against the depth of the current fragment, we calculate the current fragment&#x27;s depth by using the same formula we used in the shadow map fragment shader, and then compare the two values.</p><p>If we were to use the standard approach of recording the depth values in the shadow map, then in the final scene fragment shader we would need to determine which of the light view matrices would be the correct one to use for the current fragment and calculate the current depth accordingly.</p><p>Since this is a lot more complex then just calculating the distance between the light source and each fragment of the scene and storing and comparing those values, this alternative approach is used instead.</p><p>We calculate the firection of the vertex from the light source in line 47, by just subtracting the position of the light source from the position of the current fragment. This value is then provided to the<!-- --> <code>getAverageVisibility</code> function.</p><p>The depth of the current fragment is calculated on line 19 by taking the distance of the current fragment from the light source and dividing that result by the far plane of the light&#x27;s &quot;camera&quot; (same as in the fragment shader for the shadow cube map).</p><p>And then the rest of the calculation for the visibility of the fragment is the same as before. One difference is that since we are now sampling a cube map, we need three nested loops (one for each axis) for sampling the surrounding depth values for our PCF algorithm.</p><h2 id="2-additional-notes">Additional Notes<a href="#2-additional-notes" aria-label="Link to section &quot;Additional Notes&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><h3 id="3-generating-point-light-shadow-maps-in-openglwebgl">Generating point light shadow maps in OpenGL/WebGL<a href="#3-generating-point-light-shadow-maps-in-openglwebgl" aria-label="Link to section &quot;Generating point light shadow maps in OpenGL/WebGL&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>When we generate a camera for each face of the shadow cube map, we use an up vector that points in the positive Y-axis (with the exception for the Y-axis faces, where we use a negative Z-axis up vector for the positive Y face, and a positive Z-axis up vector for the negative Z face).</p><p>However, in OpenGL/WebGL you need to invert these up vectors instead.</p><p>In the <a href="/intermediates/color-mapping/">color mapping</a> <!-- -->chapter, we provided an additional note that these graphics APIs read image data with the origin at the bottom-left of the image instead of the origin being traditionally at the top-left of the image. As a result, you would need to either flip the UV coordinates on the Y-axis, or flip the image vertically for the results to appear same as other graphics APIs.</p><p>The reason for this is that while OpenGL/WebGL typically use a right-handed coordinate system (where the positive Z-direction is towards the camera), cube maps instead use the left-handed coordinate system (where the positive Z-direction is away from the camera).</p><p>As a result, when you transform the cube map faces from one coordinate system to the other, you will find that the up vectors of each face get flipped to the opposite direction.</p><p>So keeping this in mind is important when working with cube maps and knowing how they behave differently compared to standard 2D maps.</p><p>This will be discussed in the<!-- --> <a href="/advanced/cube-maps/">next chapter</a> as well under the &quot;Additional Notes&quot; section.</p><h3 id="3-cascaded-shadow-maps">Cascaded shadow maps<a href="#3-cascaded-shadow-maps" aria-label="Link to section &quot;Cascaded shadow maps&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>One problem we didn&#x27;t tackle is shadows of lights covering a large area having lower detail.</p><p>If a light source is covering a large area, that means that the area has to be compressed more to fit into the shadow map, this means as the areas get bigger, the amount of resolution they get in the shadow map gets reduced, resulting in more aliased reflections.</p><p>This issue primarily occurs with directional lights due to the fact they have to cover the entire scene, which can be a very large area.</p><p>With other lights, they can only cover a smaller area due to them being of finite distance and their light intensity reducing with increase in distance as well. As a result, the shadows they cast would be relatively close to the light source itself, so no perspective aliasing issues should occur.</p><p>However, with infinite light sources like directional lights, they have to light up the entire scene. If the scene is very large, this can cause degraded looking shadows near the camera position.</p><p>The most common technique used to solve this problem is using Cascaded Shadow Maps (CSM).</p><p>This technique requires rendering multiple shadow maps, at various distances from the camera of the viewer. Based upon how far an object is from the camera, the appropriate shadow map is selected and used for generating the shadows.</p><p>This allows us to have one shadow map dedicated to covering a small area close to the viewer, spreading that area across the shadow map as much as possible.</p><p>The next shadow map will cover an area more further away from the viewer and covers a much larger area. Since this area is further away, the shadow doesn&#x27;t need to be as high in quality, so fitting in a larger area is fine.</p><p>This stacking of shadow maps to cover further and further distances can be done according to the amount of quality needed for each distance.</p><p>Typically 3 to 4 shadow maps are used to cover an entire scene, with the last shadow map covering the rest of the scene area not covered by the previous ones. Since it is the last one, it should be reasonably far away such that the low quality shadows from it should not be noticeable.</p><h3 id="3-other-types-of-lights">Other types of lights<a href="#3-other-types-of-lights" aria-label="Link to section &quot;Other types of lights&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>The lights discussed in these chapters are generally the most commonly used ones. There may be some other types of lights, which also have different ways for generating shadows, but they should all use the same or similar principles discussed we&#x27;ve discussed here.</p><h3 id="3-improving-render-performance">Improving render performance<a href="#3-improving-render-performance" aria-label="Link to section &quot;Improving render performance&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>There are ways to improve performance when rendering shadows. Objects in a scene can be tagged to be &quot;Shadow Receivers&quot; or &quot;Shadow Casters&quot; against each light source. Shadow receivers have the ability to be in shadow by another object, while shadow casters have the ability to cast shadows onto other objects from a specific light source. All shadow receivers are also considered to be shadow casters.</p><p>When rendering the shadow map for a light source, you only need to render those objects that have been tagged as a shadow caster or shadow receiver for that light. When rendering the final scene, the shadow map only needs to be passed to those objects that are marked as shadow receivers.</p><p>This helps to improve performance by reducing the number of objects being rendered into a shadow map, and having objects that won&#x27;t be receiving shadows skip the shadow calculation parts.</p><p>Other ways to improve performance is to also use lower detailed objects in the scene for rendering the shadow maps, if they are good enough to use as an approximation for the fully detailed object.</p><h3 id="3-calculating-projection-matrices-for-lights">Calculating projection matrices for lights<a href="#3-calculating-projection-matrices-for-lights" aria-label="Link to section &quot;Calculating projection matrices for lights&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h3><p>The projection matrices used for the cameras of the lights were hand-crafted, but this isn&#x27;t always practically. Sometimes (especially for directional lights) it is more practical to dynamically calculate what the projection matrix should be based on the position of objects in the scene.</p><p>This can be done by calculating a bounding box that encompasses all the objects that need to be rendered into the shadow map, and then calculate a projection matrix using that bounding box.</p><p>This allows to more effectively use the space in a shadow map, maximizing the resolution in the shadow map for each area in the scene.</p><p>There may be cases of popping occuring, where the shadows resolution may suddenly improve or degrade, as objects move in and out of the shadow map bounding box. This can be somewhat countered by smoothing out the change in shadow quality.</p><p>If you use cascaded shadow maps, this approach won&#x27;t provide any benefits, but it is still a useful alternative to cascaded shadow maps and is also simpler to implement.</p><h2 id="2-summary">Summary<a href="#2-summary" aria-label="Link to section &quot;Summary&quot;"><img alt="" role="presentation" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K"/></a></h2><ul><li>Rendering shadows are an important aspect of lighting to make a scene appear complete.</li><li>Shadows are rendered with the help of shadow maps.<ul><li>A shadow map is the scene rendered from the perspective of the light source.</li><li>The shadow map captures the depth of all fragments that are visible to the light source.</li></ul></li><li>When rendering the final scene, calculate the position of where the fragment would be if it were to be rendered in the shadow map, and get the depth value of the closest fragment from that map.<ul><li>If the current fragment&#x27;s depth is higher than the closest fragment, it isn&#x27;t visible to the light source and is in shadow.</li><li>If the current fragment&#x27;s depth is lower than or equal to the closest fragment, it is visible to the light source and should be lit instead.</li></ul></li><li>There are certain artifacts that can occur when rendering shadows using shadow maps:<ul><li><strong>Shadow acne</strong> - If the precision of the data being stored in the shadow map is higher than what the shadow map can support, the loss in precision can result in some fragments appearing to be in shadow when they aren&#x27;t. The possible approaches for solving this are:<ul><li>Storing the data into the shadow map in such a way that no precision is lost, such as increasing the effective range that the depth values will be stored as, or transforming the data into a data type that the shadow map can support in a lossless fashion.</li><li>Alternatively, a bias value can be introduced where as long as the difference of depth is less than this value then it can still be considered to be visible to the light source.</li><li>Since the acne is rendered on surfaces that are rendered in the shadow map, if the back faces of the scene are rendered when rendering the shadow map, then the acne will only occur in the areas of the scene in shadow, which will not be visible.</li></ul></li><li><strong>Peter-panning</strong> - Some of the solutions to shadow acne can result in shadows appearing to hover from where they should be. This primarily occurs in areas where two objects are touching or are very close to each other.<ul><li>The solution to this problem is to make geometry thicker so that the solution of using a bias value or rendering the back faces of a scene in a shadow map doesn&#x27;t cause peter-panning.</li></ul></li><li><strong>Shadow aliasing</strong> - Due to the limited resolution of a shadow map, shadows can have sharp jagged edges due to aliasing.<ul><li>The resolution of shadow maps can be increased to reducing the size of the aliasing, but this will increase the rendering time of the shadow map.</li><li>Alternatively, the shadow can be filtered using Percentage Closer Filtering (PCF) algorithms to get multiple samples of the shadow map and calculate the average intensity of the fragment being in shadow/light, resulting in softer edges on shadows.</li></ul></li></ul></li><li>There are various kinds of lights, all of which generate different kinds of shadows:<ul><li><strong>Directional lights</strong> - Light sources that are very far away and their light travels in the same direction and don&#x27;t reduce in intensity w.r.t. the distance from the light source.<!-- --> <em>Ex: the Sun</em>.</li><li><strong>Spot Lights</strong> - Light sources that are a finite distance away, where the light travels in a cone like way towards a single direction from the light source, and the intensity does reduce with distance. <em>Ex: Torches</em>.</li><li><strong>Area Lights</strong> - Similar to directional lights, except that they are a finite distance away and their intensity does drop with distance. <em>Ex: Office florescent lights</em>.</li><li><strong>Point Lights</strong> - Similar to spot lights, but their light travels in all directions, not just one approximate direction. <em>Ex: Traditional light bulb</em>.</li></ul></li></ul><div class="page-change"><div class="page-previous util text-left"><a href="/advanced/transparency/">← Previous Chapter</a></div></div></div></main><div class="row"><footer class="column"><div class="author">Logo inspired from<!-- --> <a href="https://commons.wikimedia.org/wiki/File:Phong-shading-sample.jpg" rel="noopener noreferrer" target="_blank">Wikimedia Commons</a></div><div class="social"><a href="https://github.com/sabarnac/shader-tutorial/" rel="noopener noreferrer" target="_blank"><div data-gatsby-image-wrapper="" style="width:32px;height:32px" class="gatsby-image-wrapper gatsby-image-wrapper-constrained"><div style="max-width:120px;display:block"><img alt="" role="presentation" aria-hidden="true" src="data:image/svg+xml;charset=utf-8,%3Csvg%20height=&#x27;120&#x27;%20width=&#x27;120&#x27;%20xmlns=&#x27;http://www.w3.org/2000/svg&#x27;%20version=&#x27;1.1&#x27;%3E%3C/svg%3E" style="max-width:100%;display:block;position:static"/></div><div aria-hidden="true" data-placeholder-image="" style="opacity:1;transition:opacity 500ms linear;background-color:#f8f8f8;position:absolute;top:0;left:0;bottom:0;right:0"></div><picture><source type="image/webp" data-srcset="/static/472739dfb5857b1f659f4c4c6b4568d0/bde72/github.webp 30w,/static/472739dfb5857b1f659f4c4c6b4568d0/927d1/github.webp 60w,/static/472739dfb5857b1f659f4c4c6b4568d0/507b0/github.webp 120w" sizes="(min-width: 120px) 120px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 120px) 120px, 100vw" decoding="async" loading="lazy" data-src="/static/472739dfb5857b1f659f4c4c6b4568d0/a8b52/github.png" data-srcset="/static/472739dfb5857b1f659f4c4c6b4568d0/53973/github.png 30w,/static/472739dfb5857b1f659f4c4c6b4568d0/7ab40/github.png 60w,/static/472739dfb5857b1f659f4c4c6b4568d0/a8b52/github.png 120w" alt="GitHub Repo Link"/></picture><noscript><picture><source type="image/webp" srcSet="/static/472739dfb5857b1f659f4c4c6b4568d0/bde72/github.webp 30w,/static/472739dfb5857b1f659f4c4c6b4568d0/927d1/github.webp 60w,/static/472739dfb5857b1f659f4c4c6b4568d0/507b0/github.webp 120w" sizes="(min-width: 120px) 120px, 100vw"/><img data-gatsby-image-ssr="" data-main-image="" style="opacity:0" sizes="(min-width: 120px) 120px, 100vw" decoding="async" loading="lazy" src="/static/472739dfb5857b1f659f4c4c6b4568d0/a8b52/github.png" srcSet="/static/472739dfb5857b1f659f4c4c6b4568d0/53973/github.png 30w,/static/472739dfb5857b1f659f4c4c6b4568d0/7ab40/github.png 60w,/static/472739dfb5857b1f659f4c4c6b4568d0/a8b52/github.png 120w" alt="GitHub Repo Link"/></picture></noscript><script type="module">const t="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;if(t){const t=document.querySelectorAll("img[data-main-image]");for(let e of t){e.dataset.src&&(e.setAttribute("src",e.dataset.src),e.removeAttribute("data-src")),e.dataset.srcset&&(e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset"));const t=e.parentNode.querySelectorAll("source[data-srcset]");for(let e of t)e.setAttribute("srcset",e.dataset.srcset),e.removeAttribute("data-srcset");e.complete&&(e.style.opacity=1,e.parentNode.parentNode.querySelector("[data-placeholder-image]").style.opacity=0)}}</script></div></a></div></footer></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/advanced/shadow-mapping/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-91724c2851514a4f468e.js\"],\"component---cache-caches-gatsby-plugin-offline-app-shell-js\":[\"/component---cache-caches-gatsby-plugin-offline-app-shell-js-0709e273de6418adc24c.js\"],\"component---src-pages-404-js\":[\"/component---src-pages-404-js-ff074761dcf49aad50d0.js\"],\"component---src-pages-advanced-branching-js\":[\"/component---src-pages-advanced-branching-js-e75434264095d9aeb00d.js\"],\"component---src-pages-advanced-color-banding-dithering-js\":[\"/component---src-pages-advanced-color-banding-dithering-js-d7c3d60724228fa601b3.js\"],\"component---src-pages-advanced-cube-maps-js\":[\"/component---src-pages-advanced-cube-maps-js-91cfe775e982867723f5.js\"],\"component---src-pages-advanced-index-js\":[\"/component---src-pages-advanced-index-js-b37f16b078dee220dea1.js\"],\"component---src-pages-advanced-shadow-mapping-js\":[\"/component---src-pages-advanced-shadow-mapping-js-3dddd912118886b6738c.js\"],\"component---src-pages-advanced-transparency-js\":[\"/component---src-pages-advanced-transparency-js-e021338a2ee4192d4a2e.js\"],\"component---src-pages-basics-color-js\":[\"/component---src-pages-basics-color-js-174da72266fe670723be.js\"],\"component---src-pages-basics-end-js\":[\"/component---src-pages-basics-end-js-bd723577cef163ebfa58.js\"],\"component---src-pages-basics-fragment-shader-js\":[\"/component---src-pages-basics-fragment-shader-js-4934d6ef64d93e25c81b.js\"],\"component---src-pages-basics-index-js\":[\"/component---src-pages-basics-index-js-ddc61fc0a4a83629df06.js\"],\"component---src-pages-basics-introduction-js\":[\"/component---src-pages-basics-introduction-js-0d0783a5a6e3193a5845.js\"],\"component---src-pages-basics-mathematics-js\":[\"/component---src-pages-basics-mathematics-js-e6dc72577dfe70f3b630.js\"],\"component---src-pages-basics-render-pipeline-js\":[\"/component---src-pages-basics-render-pipeline-js-3d0dd2b65ec85a2676fc.js\"],\"component---src-pages-basics-vertex-shader-js\":[\"/component---src-pages-basics-vertex-shader-js-20b0689037b79db2d450.js\"],\"component---src-pages-faq-js\":[\"/component---src-pages-faq-js-38bad46c5d1b4abc7849.js\"],\"component---src-pages-index-js\":[\"/component---src-pages-index-js-ebe00d5d5465472ceaaa.js\"],\"component---src-pages-intermediates-color-2-js\":[\"/component---src-pages-intermediates-color-2-js-97e96a3ae1559ab9b0b2.js\"],\"component---src-pages-intermediates-color-mapping-js\":[\"/component---src-pages-intermediates-color-mapping-js-0252a1f0d4411481ffc7.js\"],\"component---src-pages-intermediates-image-generation-js\":[\"/component---src-pages-intermediates-image-generation-js-db9722606bb210aa4aa8.js\"],\"component---src-pages-intermediates-index-js\":[\"/component---src-pages-intermediates-index-js-acf3dbd57e9e0ee19688.js\"],\"component---src-pages-intermediates-lighting-js\":[\"/component---src-pages-intermediates-lighting-js-b74abbde1c242fc4d958.js\"],\"component---src-pages-intermediates-mapping-js\":[\"/component---src-pages-intermediates-mapping-js-61c99e9a1cd7c60b9cfd.js\"],\"component---src-pages-intermediates-normal-mapping-js\":[\"/component---src-pages-intermediates-normal-mapping-js-2ee11e468865ed89e5c0.js\"],\"component---src-pages-intermediates-specular-mapping-js\":[\"/component---src-pages-intermediates-specular-mapping-js-a38f1f96e4e7cb88eb68.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="39f144f604316a18fcf0";</script><script src="/webpack-runtime-51b926bee621703d1e27.js" async></script><script src="/framework-cc2a0d5da93eae3857d3.js" async></script><script src="/app-91724c2851514a4f468e.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>