"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[674],{6604:function(e,t,a){a.r(t),a.d(t,{default:function(){return O}});var n=a(4794),r=a(2532),i=a(6540),o=a(9460),l=a(7722),c=a(7154),s=a(6042),m=(a(6449),a(3514),a(4796)),u=a(329),h=a(7684),p=a(2859),f=a(3461),g=a(6417),v=a(782);const d={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{specularReflectivity:"float",diffuseTextureSampler:"sampler2D"}}},x=m.fA(4,0,4,1),w=u.fA(1,1,1),b=h.vt();var E=(0,g.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],uvs:[[0,1],[0,0],[1,1],[0,0],[1,1],[1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],indices:[[0,1,2,3,4,5]],texture:p.A,specularReflectivity:.3,specularLobeFactor:5},{0:t,1:a}=(0,i.useState)(null),{0:n,1:r}=(0,i.useState)(null),{0:o,1:l}=(0,i.useState)(null),{0:c,1:s}=(0,i.useState)({vertices:null,uvs:null,normals:null,indices:null,texture:null}),m=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==m.current){const e=new v.A(m.current,b);return a(e),()=>{a(null),e.destroy()}}}),[m]),(0,i.useEffect)((0,f.sT)(null!==t,(()=>{r(t.createShaderProgram("attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\n\nvarying highp vec2 uv;\nvarying highp vec4 fragmentPosition_viewSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n  \n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\n  fragmentNormal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  uv = vertexUv;\n}","varying highp vec2 uv;\nvarying highp vec4 fragmentPosition_viewSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\n\nuniform highp mat4 viewMatrix;\nuniform highp vec4 lightPosition_worldSpace;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\n\nuniform highp float specularLobeFactor;\nuniform highp float specularReflectivity;\n\nuniform sampler2D diffuseTextureSampler;\n\nvoid main() {\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\n\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - cameraPosition_viewSpace);\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\n\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, fragmentNormal_viewSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\n  gl_FragColor.a = diffuseColor.a;\n}"))})),[t]),(0,i.useEffect)((0,f.sT)(null!==n,(()=>{l(t.getDataLocations(n,d))})),[n]),(0,i.useEffect)((0,f.sT)(null!==o,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[o]),(0,i.useEffect)((0,f.sT)(null!==c.vertices,(()=>{let a=!0;const r=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:l,viewMatrix:s,modelMatrix:m}=t;if(!a)return;const u=h.vt(),p=30*Math.PI/180;h.Tl(u,m,[0,0,2]),h.Z8(u,u,p),i.bindBuffer(i.ARRAY_BUFFER,c.vertices),i.vertexAttribPointer(o.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,c.uvs),i.vertexAttribPointer(o.vertex.attributeLocations.vertexUv,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexUv),i.bindBuffer(i.ARRAY_BUFFER,c.normals),i.vertexAttribPointer(o.vertex.attributeLocations.vertexNormal,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexNormal),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,c.indices),i.useProgram(n),i.uniformMatrix4fv(o.vertex.uniformLocations.projectionMatrix,!1,l),i.uniformMatrix4fv(o.vertex.uniformLocations.viewMatrix,!1,s),i.uniformMatrix4fv(o.vertex.uniformLocations.modelMatrix,!1,u),i.uniform4fv(o.vertex.uniformLocations.lightPosition_worldSpace,x),i.uniform3fv(o.vertex.uniformLocations.lightColor,w),i.uniform1f(o.vertex.uniformLocations.lightIntensity,50),i.uniform1f(o.fragment.uniformLocations.specularReflectivity,e.specularReflectivity),i.uniform1f(o.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,c.texture),i.uniform1i(o.fragment.uniformLocations.diffuseTextureSampler,0),i.drawElements(i.TRIANGLES,e.indices.length*e.indices[0].length,i.UNSIGNED_SHORT,0),requestAnimationFrame(r)}))};return requestAnimationFrame(r),()=>{a=!1}})),[c]);return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:m},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,f.NW)([0,0,0])+"\n    Lighting:\n        Specular Reflectivity: "+e.specularReflectivity+"\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,f.NW)(x)+"\n    Color: "+(0,f.NW)(w,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))})),T=a(842),S=a(9498);const y="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\nattribute vec3 vertexTangent;\nattribute vec3 vertexBiTangent;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying highp vec2 uv;\nvarying highp mat3 tbnMatrix_viewSpace;\nvarying highp vec4 fragmentPosition_viewSpace;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\n  uv = vertexUv;\n\n  highp mat3 modelViewMatrix_3x3 = mat3(viewMatrix * modelMatrix);\n  highp vec3 vertexTangent = normalize(vertexTangent);\n  highp vec3 vertexBiTangent = normalize(vertexBiTangent);\n  highp vec3 vertexNormal = normalize(vertexNormal);\n\n  tbnMatrix_viewSpace = modelViewMatrix_3x3 * mat3(\n    vertexTangent,\n    vertexBiTangent,\n    vertexNormal\n  );\n}",_="varying highp vec2 uv;\nvarying highp mat3 tbnMatrix_viewSpace;\nvarying highp vec4 fragmentPosition_viewSpace;\n\nuniform highp mat4 viewMatrix;\nuniform highp vec4 lightPosition_worldSpace;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\n\nuniform highp float specularLobeFactor;\nuniform highp float specularReflectivity;\n\nuniform sampler2D diffuseTextureSampler;\nuniform sampler2D normalTextureSampler;\n\nvoid main() {\n  highp vec4 normalColor = texture2D(normalTextureSampler, uv);\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\n\n  highp vec3 normal_viewSpace = tbnMatrix_viewSpace * normalize((normalColor.xyz * 2.0) - 1.0);\n\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - cameraPosition_viewSpace);\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  highp vec3 diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, normal_viewSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\n  gl_FragColor.a = diffuseColor.a;\n}",A={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec3",vertexTangent:"vec3",vertexBiTangent:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{specularReflectivity:"float",diffuseTextureSampler:"sampler2D",normalTextureSampler:"sampler2D"}}},L=m.fA(4,0,4,1),R=u.fA(1,1,1),P=h.vt();var N=(0,g.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],uvs:[[0,1],[0,0],[1,1],[0,0],[1,1],[1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],tangents:[],biTangents:[],indices:[[0,1,2,3,4,5]],texture:p.A,normalTexture:S.A,specularReflectivity:.3,specularLobeFactor:5};for(let i=0;i<e.vertices.length;i+=3){const t=u.o8(e.vertices[i+0]),a=u.o8(e.vertices[i+1]),n=u.o8(e.vertices[i+2]),r=T.o8(e.uvs[i+0]),o=T.o8(e.uvs[i+1]),l=T.o8(e.uvs[i+2]),c=u.Re(u.vt(),a,t),s=u.Re(u.vt(),n,t),m=T.Re(T.vt(),o,r),h=T.Re(T.vt(),l,r),p=1/(m[0]*h[1]-m[1]*h[0]),f=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),c,[h[1],h[1],h[1]]),u.lw(u.vt(),s,[m[1],m[1],m[1]])),[p,p,p])),g=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),s,[m[0],m[0],m[0]]),u.lw(u.vt(),c,[h[0],h[0],h[0]])),[p,p,p]));e.tangents.push(f,f,f),e.biTangents.push(g,g,g)}const{0:t,1:a}=(0,i.useState)(null),{0:n,1:r}=(0,i.useState)(null),{0:o,1:l}=(0,i.useState)(null),{0:c,1:s}=(0,i.useState)({vertices:null,uvs:null,normals:null,tangents:null,biTangents:null,indices:null,texture:null,normalTexture:null}),m=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==m.current){const e=new v.A(m.current,P);return a(e),()=>{a(null),e.destroy()}}}),[m]),(0,i.useEffect)((0,f.sT)(null!==t,(()=>{r(t.createShaderProgram(y,_))})),[t]),(0,i.useEffect)((0,f.sT)(null!==n,(()=>{l(t.getDataLocations(n,A))})),[n]),(0,i.useEffect)((0,f.sT)(null!==o,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),tangents:t.createStaticDrawArrayBuffer(e.tangents.flat(),c.tangents),biTangents:t.createStaticDrawArrayBuffer(e.biTangents.flat(),c.biTangents),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture),normalTexture:t.createImageTexture(e.normalTexture,c.normalTexture)})})),[o]),(0,i.useEffect)((0,f.sT)(null!==c.vertices,(()=>{let a=!0;const r=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:l,viewMatrix:s,modelMatrix:m}=t;if(!a)return;const u=h.vt(),p=30*Math.PI/180;h.Tl(u,m,[0,0,2]),h.Z8(u,u,p),i.bindBuffer(i.ARRAY_BUFFER,c.vertices),i.vertexAttribPointer(o.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,c.uvs),i.vertexAttribPointer(o.vertex.attributeLocations.vertexUv,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexUv),i.bindBuffer(i.ARRAY_BUFFER,c.normals),i.vertexAttribPointer(o.vertex.attributeLocations.vertexNormal,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexNormal),i.bindBuffer(i.ARRAY_BUFFER,c.tangents),i.vertexAttribPointer(o.vertex.attributeLocations.vertexTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexTangent),i.bindBuffer(i.ARRAY_BUFFER,c.biTangents),i.vertexAttribPointer(o.vertex.attributeLocations.vertexBiTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexBiTangent),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,c.indices),i.useProgram(n),i.uniformMatrix4fv(o.vertex.uniformLocations.projectionMatrix,!1,l),i.uniformMatrix4fv(o.vertex.uniformLocations.viewMatrix,!1,s),i.uniformMatrix4fv(o.vertex.uniformLocations.modelMatrix,!1,u),i.uniform4fv(o.vertex.uniformLocations.lightPosition_worldSpace,L),i.uniform3fv(o.vertex.uniformLocations.lightColor,R),i.uniform1f(o.vertex.uniformLocations.lightIntensity,50),i.uniform1f(o.fragment.uniformLocations.specularReflectivity,e.specularReflectivity),i.uniform1f(o.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,c.texture),i.uniform1i(o.fragment.uniformLocations.diffuseTextureSampler,0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,c.normalTexture),i.uniform1i(o.fragment.uniformLocations.normalTextureSampler,1),i.drawElements(i.TRIANGLES,e.indices.length*e.indices[0].length,i.UNSIGNED_SHORT,0),requestAnimationFrame(r)}))};return requestAnimationFrame(r),()=>{a=!1}})),[c]);return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:m},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,f.NW)([0,0,0])+"\n    Lighting:\n        Specular Reflectivity: "+e.specularReflectivity+"\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,f.NW)(L)+"\n    Color: "+(0,f.NW)(R,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))}));const B="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\nattribute vec3 vertexTangent;\nattribute vec3 vertexBiTangent;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying highp vec2 uv;\nvarying highp mat3 tbnMatrix_tangentSpace;\nvarying highp vec3 fragmentPosition_tangentSpace;\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  uv = vertexUv;\n\n  highp mat3 modelViewMatrix_3x3 = mat3(viewMatrix * modelMatrix);\n  highp vec3 vertexTangent = normalize(vertexTangent);\n  highp vec3 vertexBiTangent = normalize(vertexBiTangent);\n  highp vec3 vertexNormal = normalize(vertexNormal);\n\n  tbnMatrix_tangentSpace = transpose(modelViewMatrix_3x3 * mat3(\n    vertexTangent,\n    vertexBiTangent,\n    vertexNormal\n  ));\n\n  fragmentPosition_tangentSpace = tbnMatrix_tangentSpace * (viewMatrix * vertexPosition_worldSpace).xyz;\n}",F="varying highp vec2 uv;\n\nvarying highp mat3 tbnMatrix_tangentSpace;\nvarying highp vec3 fragmentPosition_tangentSpace;\n\nuniform highp mat4 modelMatrix;\nuniform highp mat4 viewMatrix;\nuniform highp vec4 lightPosition_worldSpace;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\nuniform highp float specularReflectivity;\nuniform highp float specularLobeFactor;\n\nuniform sampler2D diffuseTextureSampler;\nuniform sampler2D normalTextureSampler;\n\nvoid main() {\n  highp vec4 normalColor = texture2D(normalTextureSampler, uv);\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\n  highp vec3 specularColor = vec3(diffuseColor.rgb);\n\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightPosition_tangentSpace = tbnMatrix_tangentSpace * lightPosition_viewSpace.xyz;\n  highp vec3 lightDirection_tangentSpace = normalize(lightPosition_tangentSpace - fragmentPosition_tangentSpace);\n\n  highp vec3 normal_tangentSpace = normalize((normalColor.xyz * 2.0) - 1.0);\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_tangentSpace, lightPosition_tangentSpace);\n\n  highp float diffuseStrength = clamp(dot(normal_tangentSpace, lightDirection_tangentSpace), 0.0, 1.0);\n  highp vec3 diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 cameraPosition_viewSpace = vec3(0.0, 0.0, 0.0); // In view-space, the camera is in the center of the world, so it's position would be (0, 0, 0).\n  highp vec3 viewDirection_tangentSpace = normalize(fragmentPosition_tangentSpace.xyz - cameraPosition_viewSpace);\n  highp vec3 lightReflection_tangentSpace = reflect(lightDirection_tangentSpace, normal_tangentSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_tangentSpace, lightReflection_tangentSpace), 0.0, 1.0);\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n  \n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\n  gl_FragColor.a = diffuseColor.a;\n}",M={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec3",vertexTangent:"vec3",vertexBiTangent:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{specularReflectivity:"float",diffuseTextureSampler:"sampler2D",normalTextureSampler:"sampler2D"}}},C=m.fA(4,0,4,1),D=u.fA(1,1,1),I=h.vt();var k=(0,g.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],uvs:[[0,1],[0,0],[1,1],[0,0],[1,1],[1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],tangents:[],biTangents:[],indices:[[0,1,2,3,4,5]],texture:p.A,normalTexture:S.A,specularReflectivity:.3,specularLobeFactor:5};for(let i=0;i<e.vertices.length;i+=3){const t=u.o8(e.vertices[i+0]),a=u.o8(e.vertices[i+1]),n=u.o8(e.vertices[i+2]),r=T.o8(e.uvs[i+0]),o=T.o8(e.uvs[i+1]),l=T.o8(e.uvs[i+2]),c=u.Re(u.vt(),a,t),s=u.Re(u.vt(),n,t),m=T.Re(T.vt(),o,r),h=T.Re(T.vt(),l,r),p=1/(m[0]*h[1]-m[1]*h[0]),f=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),c,[h[1],h[1],h[1]]),u.lw(u.vt(),s,[m[1],m[1],m[1]])),[p,p,p])),g=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),s,[m[0],m[0],m[0]]),u.lw(u.vt(),c,[h[0],h[0],h[0]])),[p,p,p]));e.tangents.push(f,f,f),e.biTangents.push(g,g,g)}const{0:t,1:a}=(0,i.useState)(null),{0:n,1:r}=(0,i.useState)(null),{0:o,1:l}=(0,i.useState)(null),{0:c,1:s}=(0,i.useState)({vertices:null,uvs:null,normals:null,tangents:null,biTangents:null,indices:null,texture:null,normalTexture:null}),m=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==m.current){const e=new v.A(m.current,I);return a(e),()=>{a(null),e.destroy()}}}),[m]),(0,i.useEffect)((0,f.sT)(null!==t,(()=>{r(t.createShaderProgram(B,F))})),[t]),(0,i.useEffect)((0,f.sT)(null!==n,(()=>{l(t.getDataLocations(n,M))})),[n]),(0,i.useEffect)((0,f.sT)(null!==o,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),tangents:t.createStaticDrawArrayBuffer(e.tangents.flat(),c.tangents),biTangents:t.createStaticDrawArrayBuffer(e.biTangents.flat(),c.biTangents),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture),normalTexture:t.createImageTexture(e.normalTexture,c.normalTexture)})})),[o]),(0,i.useEffect)((0,f.sT)(null!==c.vertices,(()=>{let a=!0;const r=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:l,viewMatrix:s,modelMatrix:m}=t;if(!a)return;const u=h.vt(),p=30*Math.PI/180;h.Tl(u,m,[0,0,2]),h.Z8(u,u,p),i.bindBuffer(i.ARRAY_BUFFER,c.vertices),i.vertexAttribPointer(o.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,c.uvs),i.vertexAttribPointer(o.vertex.attributeLocations.vertexUv,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexUv),i.bindBuffer(i.ARRAY_BUFFER,c.normals),i.vertexAttribPointer(o.vertex.attributeLocations.vertexNormal,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexNormal),i.bindBuffer(i.ARRAY_BUFFER,c.tangents),i.vertexAttribPointer(o.vertex.attributeLocations.vertexTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexTangent),i.bindBuffer(i.ARRAY_BUFFER,c.biTangents),i.vertexAttribPointer(o.vertex.attributeLocations.vertexBiTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(o.vertex.attributeLocations.vertexBiTangent),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,c.indices),i.useProgram(n),i.uniformMatrix4fv(o.vertex.uniformLocations.projectionMatrix,!1,l),i.uniformMatrix4fv(o.vertex.uniformLocations.viewMatrix,!1,s),i.uniformMatrix4fv(o.vertex.uniformLocations.modelMatrix,!1,u),i.uniform4fv(o.vertex.uniformLocations.lightPosition_worldSpace,C),i.uniform3fv(o.vertex.uniformLocations.lightColor,D),i.uniform1f(o.vertex.uniformLocations.lightIntensity,50),i.uniform1f(o.fragment.uniformLocations.specularReflectivity,e.specularReflectivity),i.uniform1f(o.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,c.texture),i.uniform1i(o.fragment.uniformLocations.diffuseTextureSampler,0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,c.normalTexture),i.uniform1i(o.fragment.uniformLocations.normalTextureSampler,1),i.drawElements(i.TRIANGLES,e.indices.length*e.indices[0].length,i.UNSIGNED_SHORT,0),requestAnimationFrame(r)}))};return requestAnimationFrame(r),()=>{a=!1}})),[c]);return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:m},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,f.NW)([0,0,0])+"\n    Lighting:\n        Specular Reflectivity: "+e.specularReflectivity+"\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,f.NW)(C)+"\n    Color: "+(0,f.NW)(D,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))})),U=a(7570),z=a(2007),W=a(2269);var O=e=>{let{location:{pathname:t}}=e;return i.createElement(U.A,null,i.createElement(W.A,{pathname:t,title:"Shader Intermediates - Normal Mapping",description:"A look into the how normal map textures are used to add lighting detail to objects.",keywords:["normal","mapping","texturing","shader","intermediates"]}),i.createElement(o.A,null,i.createElement("h1",null,"Shader Intermediates - Normal Mapping"),i.createElement("p",null,"An issue with the lighting examples seen in the"," ",i.createElement(n.Link,{to:"/intermediates/lighting/"},"previous chapter on lighting")," ","is that the entire surface of the object has a uniform appearance, making it appear flat."),i.createElement(s.A,{type:"h2"},"Example - Stone wall"),i.createElement(E,null),i.createElement("p",null,"In the above example of the stone wall, we've applied our naive approach to lighting the surface of the wall. The result is the appearance of a wall with detailed color, but looking very flat due to the simple form of lighting."),i.createElement("p",null,'The wall shouldn\'t appear as flat since it has bumps, scratches, grooves, etc. These interact with light in different ways resulting in a surface that highlights the roughness and imperfections on it, giving it "depth".'),i.createElement("p",null,"A similar situation was discussed and solved in the chapter on"," ",i.createElement(n.Link,{to:"/intermediates/color-mapping/"},"color mapping"),", where the lack of color detail from vertex data was solved by passing color information using a texture."),i.createElement("p",null,"The same concept of mapping can be used to add better lighting detail without increasing the complexity of the object. By changing the way the light interacts with the surface using a texture, the wall can be made to appear rough instead of smooth and flat."),i.createElement(s.A,{type:"h2"},"Why store normals in a map?"),i.createElement("p",null,"If we look into the"," ",i.createElement(n.Link,{to:"/intermediates/lighting/"},"lighting chapter"),", we see that there are three main components being used to describe the object through its vertices."),i.createElement("ul",null,i.createElement("li",null,"The vertex position."),i.createElement("li",null,"The vertex UV coordinates."),i.createElement("li",null,"The vertex normal.")),i.createElement("p",null,"Among these, the main component that affects the factor of lighting on an object is the vertex normal."),i.createElement("p",null,"The reason for this is simple - the normal of a surface defines what direction the surface is facing, which is important for lighting."),i.createElement("p",null,"Since the direction of the surface determines what amount of and how light will bounce and fall onto your eyes, this value can affect how a surface looks."),i.createElement("div",{className:"image util text-center"},i.createElement(r.S,{src:"../../images/intermediates/surface-1.png",alt:"Smooth Surface Light Reflection",style:{maxWidth:"65%"},__imageData:a(2884)})),i.createElement("p",null,"With a smooth surface, all points on the surface have their normals pointing in the same direction. This means that light falling on the surface bounces and reflects in the exact same manner across it, giving it a flat appearance, similar to the wall example seen above."),i.createElement("div",{className:"image util text-center"},i.createElement(r.S,{src:"../../images/intermediates/surface-2.png",alt:"Rough Surface Light Reflection",style:{maxWidth:"65%"},__imageData:a(4317)})),i.createElement("p",null,"In contrast, a rough and bumpy surface has points with normals pointing towards different directions. This results in certain spots reflecting a lot more light towards the users view, while other spots reflect less, or completely reflect light away from the users view."),i.createElement("p",null,"We can mimic the look of a rough surface by defining the normals of each point through the use of a texture, similar to how the color of each point of a surface was defined the same way in the"," ",i.createElement(n.Link,{to:"/intermediates/color-mapping/"},"color mappping")," chapter."),i.createElement("p",null,"This provides the ability to generate lighting detail similar to if the object was modeled with its roughness described through polygons, but without the additional complexity and processing to deal with those polygons."),i.createElement("p",null,"Just like with a diffuse map, a texture map used to describe the normals of an object is called a normal map, and the process of mapping normals of a fragment from a texture is called normal mapping."),i.createElement(s.A,{type:"h2"},"Normal Maps"),i.createElement("p",null,"The texture maps that will be used to color and light the wall are:"),i.createElement("div",{className:"image util text-center"},i.createElement(r.S,{src:"../../images/intermediates/texture-2.png",alt:"Stone Wall - Diffuse Map",style:{maxWidth:"65%"},__imageData:a(6252)}),i.createElement("br",null),"Diffuse map",i.createElement("br",null),i.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/",target:"_blank",rel:"noopener noreferrer"},"Source")),i.createElement("div",{className:"image util text-center"},i.createElement(r.S,{src:"../../images/intermediates/normal.png",alt:"Stone Wall - Normal Map",style:{maxWidth:"65%"},__imageData:a(552)}),i.createElement("br",null),"Normal map",i.createElement("br",null),i.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/",target:"_blank",rel:"noopener noreferrer"},"Source")),i.createElement("p",null,"The normal map is an image that contains the following information per pixel:"),i.createElement("ul",null,i.createElement("li",null,"The value of the normals are stored in the map as their unit vectors."),i.createElement("li",null,"The x-axis component of the normal is encoded as the red color of the pixel, with the color values 0 to 255 (0.0 - 1.0 in float) mapping into the range -1 to 1 on the x-axis."),i.createElement("li",null,"The y-axis component of the normal is encoded as the green color of the pixel, with the color values 0 to 255 (0.0 - 1.0 in float) mapping into the range -1 to 1 on the y-axis."),i.createElement("li",null,"The z-axis component of the normal is encoded as the blue color of the pixel, with the color values 128 to 255 (0.5 - 1.0 in float) mapping into the range 0 to 1 on the z-axis.")),i.createElement("p",null,"The reason why the z-axis is mapped only in the positive range is because any normal with a negative z-axis value is a direction that is pointing away from the view of the user, meaning that it would never be visible to the user anyways."),i.createElement("p",null,'The values of the normals in the normal map are stored in a 2.5D space called "tangent-space".'),i.createElement(s.A,{type:"h3"},"Tangent-Space"),i.createElement("p",null,'Consider a sphere. A plane (a flat 2D surface) is considered "tangent" to a point on the sphere if the plane only touches the sphere at that point and not at any other neighbouring points.'),i.createElement("p",{className:"util text-center"},i.createElement("img",{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Image_Tangent-plane.svg/2560px-Image_Tangent-plane.svg.png",alt:"Wikipedia Tangent Plane Example",style:{width:"65%"}}),i.createElement("br",null),i.createElement("a",{href:"https://en.wikipedia.org/wiki/Tangent#/media/File:Image_Tangent-plane.svg",target:"_blank",rel:"noopener noreferrer"},"Source"),i.createElement("br",null),i.createElement("small",null,"The plane shown here is the plane that is tangent to the point marked on the sphere. In other words, it is the tangent plane of the marked point on the sphere.")),i.createElement("p",null,"This plane is what is considered as XY-axis part of the tangent-space for that point of the sphere, with the Z-axis protruding outwards and away from the sphere (the direction of the normal of that point on the sphere)."),i.createElement("p",null,"In order to store the information of the normals of all points of that sphere, the values of the normals have to be recorded w.r.t the tangent-space of the point they belong to."),i.createElement(s.A,{type:"h2"},"Calculating the lighting"),i.createElement("p",null,'Since the calculations we\'ve seen in previous chapters are done in a space that is not the tangent-space, in order to use a normal map a transformation of values has to occur to ensure that the calculation occurs in the same "space" to be valid.'),i.createElement("p",null,"There are two potential options in order to fix calculations into a specific space:"),i.createElement("ul",null,i.createElement("li",null,"Keep other values as is, transform the normal map values from tangent-space into the other spaces, and perform the calculations in the other spaces."),i.createElement("li",null,"Keep the normal map values as is, transform all other values from other spaces into tangent-space, and perform the calculations in tangent-space.")),i.createElement("p",null,"In order to perform either of these, we'll need a certain matrix to perform the transformation. This matrix is called the Tangent-Bitangent-Normal matrix (or TBN matrix)."),i.createElement(s.A,{type:"h3"},"TBN Matrix"),i.createElement("p",null,"Just like with the model, view, and projection matrices, in order to transform values either into (or out of) tangent-space, a matrix called the TBN (Tangent Bi-Tangent Normal) matrix is required."),i.createElement("p",null,"A TBN matrix for a vertex is calculated by generating a 3x3 matrix using the tangent, bi-tangent, and normal direction values of a vertex."),i.createElement("p",null,"If we represent the tangent vector as T, bi-tangent vector as B, and normal vector as N, the TBN matrix would look like:"),i.createElement("p",{className:"util text-center"},i.createElement(l.A,{text:"TBN = [[T_x, B_x, N_x], [T_y, B_y, N_y], [T_z, B_z, N_z]]"})),i.createElement("p",null,"Similar to how a model matrix can transform a point or direction from model-space into world-space, a TBN matrix can transform a point or direction from tangent-space into model-space."),i.createElement("p",null,"Similarly, if the inverse of the TBN matrix is used instead, then the matrix can transform a point or direction from model-space into tangent-space. This is useful if you wish to keep calculations present in tangent-space."),i.createElement("p",null,"Since the TBN matrix is calculated for each vertex, the matrix value for each fragment is interpolated from the matrix values for each vertex that forms the polygon that the fragment belongs to."),i.createElement("p",null,"Let's look at an example where the calculation for lighting using the normal values in the normal map are done in view-space using the TBN matrix."),i.createElement(s.A,{type:"h2"},"Example - Normal-mapped stone wall (in view-space)"),i.createElement(N,null),i.createElement(c.A,{code:y.trim(),type:"Vertex"}),i.createElement(c.A,{code:_.trim(),type:"Fragment"}),i.createElement("p",null,"The shaders are written similar to the final shader in the"," ",i.createElement(n.Link,{to:"/intermediates/lighting/"},"lighting chapter"),", but with all the main lighting calculation moved to the fragment shader. The reason for this is since we'd be grabbing the normal of the surface at the fragment level, the lighting can only be calculated in the fragment shader."),i.createElement("p",null,"The first step is to calculate the TBN matrix which we need for transforming the normal values from tangent-space into view-space. This is done from line 22 onwards in the vertex shader."),i.createElement("p",null,"The tangent, bi-tangent and normal values for each vertex in a model is known beforehand. These values are in model-space, and so need to be converted to view-space in order to calculate the TBN matrix in view-space."),i.createElement("p",null,"The tangent, bi-tangent and normal values are first normalized (converted into a unit vector), and then a 3x3 matrix is constructed using them, as explained previously."),i.createElement("p",null,"The resultant matrix is a TBN matrix that transforms vectors from tangent-space to model-space. Since we want to work in view-space instead, we multiply the model-view matrix against the TBN matrix to get a TBN matrix in view-space."),i.createElement("p",null,"However, if you notice carefully, the TBN matrix is a 3x3 matrix, whereas a model-view matrix is a 4x4 matrix."),i.createElement("p",null,"To transform the TBN matrix into view-space, the last column and last row of the model-view matrix can be removed in order to multiply it against the TBN matrix. This is fine because those fields don't contain any values that affect the calculation."),i.createElement("p",null,"Alternatively, the TBN matrix can be converted into a 4x4 matrix, but this wouldn't provide much benefit as the resultant matrix would be used with vectors with three dimensions, not four."),i.createElement("p",null,"The calculated TBN matrix in view-space is now passed to the fragment shader, along with certain other values that can only be calculated in the vertex shader (",i.createElement("code",null,"vertexPosition_viewSpace"),")."),i.createElement("p",null,"In the fragment shader, the normal value of the fragment is retrieved the normal map, similar to how the color value is retrieved from tge color map"),i.createElement("p",null,"Once the normal color value is retrieved, it needs to be converted into an actual normal vector (in tangent-space). Since we know what the range of the color values are supposed to represent, we can perform the conversion using a simple mathematical formula."),i.createElement("p",{className:"util text-center"},i.createElement(l.A,{text:'"normal" = ("normalColor" * 2.0) - 1.0'})),i.createElement("p",null,"Let's take a color value of whose RGB value is"," ",i.createElement(l.A,{text:'"normalColor" = [128, 128, 128]'}),". In OpenGL, the colors are represented in a range of 0 - 1 instead of 0 - 255, so the RGB value would actually be"," ",i.createElement(l.A,{text:'"normalColor" = [0.5, 0.5, 0.5]'}),"."),i.createElement("p",null,"This color value is right in the middle of the color range, so it should represent a normal vector"," ",i.createElement(l.A,{text:'"normal" = [0.0, 0.0, 0.0]'}),"."),i.createElement("p",null,"When we plug in the normal color value into our formula for calculating the normal, we get:"),i.createElement("p",{className:"util text-center"},i.createElement(l.A,{text:'"normal" = ([0.5, 0.5, 0.5] * 2.0) - 1.0 = [1.0, 1.0, 1.0] - 1.0 = [0.0, 0.0, 0.0]'})),i.createElement("p",null,"Which matches perfectly with what we expect to get!"),i.createElement("p",null,"Just to further verify the formula, let's take a color value"," ",i.createElement(l.A,{text:'"normalColor" = [64, 64, 192]'}),". In OpenGL, this would be ",i.createElement(l.A,{text:'"normalColor" = [0.25, 0.25, 0.75]'}),", which should represent a normal"," ",i.createElement(l.A,{text:'"normal" = [-0.5, -0.5, 0.5]'}),"."),i.createElement("p",null,"Plugging this color value into the formula returns:"),i.createElement("p",{className:"util text-center"},i.createElement(l.A,{text:'"normal" = ([0.25, 0.25, 0.75] * 2.0) - 1.0 = [0.5, 0.5, 1.5] - 1.0 = [-0.5, -0.5, 0.5]'})),i.createElement("p",null,"Which again equals to the expected normal vector."),i.createElement("p",null,"Once the normal vector in tangent-space is calculated, it can now be transformed into view-space by multiplying the TBN matrix against it."),i.createElement("p",{className:"util text-center"},i.createElement(l.A,{text:'"normal"_"viewSpace" = "TBN" times "normal"'})),i.createElement("p",null,"Once this is calculated, the rest of the lighting calculations use this normal value to calculate the lighting on the fragment. This is similar to what was taught in the"," ",i.createElement(n.Link,{to:"/intermediates/lighting/"},"lighting chapter"),"."),i.createElement("p",null,"Now that we've seen what the calculation looks like in view-space, let's now look at how the calculation would appear in tangent-space."),i.createElement(s.A,{type:"h2"},"Example - Normal-mapped stone wall (in tangent-space)"),i.createElement(k,null),i.createElement(c.A,{code:B.trim(),type:"Vertex"}),i.createElement(c.A,{code:F.trim(),type:"Fragment"}),i.createElement("p",null,"Since the TBN matrix we previously had transformed vectors from tangent-space to view-space, in order to transform values the other way we need to calculate the transpose of the TBN matrix we previously calculated. This is done in line 33 of the vertex shader."),i.createElement("p",null,"Once the new TBN matrix is calculated, we now transform all the values we were previously using in view-space into tangent space. In the vertex shader, we transform the vertex position into tangent-space, and in the fragment shader we transform the light position into tangent-space."),i.createElement("p",null,"Once in the fragment shader, we grab the normal vector from the normal map as we did in the previous example. Since the lighting calculations are being done in tangent-space, only the conversion from the color value to the vector value is required."),i.createElement("p",null,"Now that all the variables we require for calculating lighting are in tangent-space, we can perform the lighting calculations in the exact same way as in the previous example. The resultant lighting value will be the same!"),i.createElement(s.A,{type:"h2"},"Summary"),i.createElement("ul",null,i.createElement("li",null,"Similar to color mapping, normal mapping can be used to map normals to fragments inside a polygon to add more detail to a surface."),i.createElement("li",null,"Normal maps add the appearance of roughness or small bumps on the surface of objects."),i.createElement("li",null,'The normals of each point are stored in an image in "tangent-space" with the X, Y, and Z coordinates represented using RGB color values.'),i.createElement("li",null,"The color values representing the normals for each fragment are retrieved from the texture and then converted into normal vectors, which are then used to perform lighting calculations."),i.createElement("li",null,"Check out"," ",i.createElement("a",{href:"http://www.mattrittman.com/create-normal-map-photoshop/",rel:"noopener noreferrer",target:"_blank"},"this guide by Matt Rittman")," ","on how to generate a normal map in Photoshop. You should find other references for generating normal maps online."))),i.createElement(z.A,{previous:"/intermediates/lighting/",next:"/intermediates/specular-mapping/"}))}},9498:function(e,t,a){t.A=a.p+"static/normal-3d370ff1c6790eee68b4a59f5ccdc8b9.png"},2859:function(e,t,a){t.A=a.p+"static/texture-2-c11990d4afdf5ed2f0fb3c44636bccd1.png"},6252:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/b5658/texture-2.png","srcSet":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/acb7c/texture-2.png 256w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/ccc41/texture-2.png 512w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/b5658/texture-2.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/22bfc/texture-2.webp 256w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/d689f/texture-2.webp 512w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/67ded/texture-2.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}')},4317:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/5fd5ef988984323810d3678d47cba6fa/acc16/surface-2.png","srcSet":"/static/5fd5ef988984323810d3678d47cba6fa/0b0d8/surface-2.png 194w,\\n/static/5fd5ef988984323810d3678d47cba6fa/52a9e/surface-2.png 387w,\\n/static/5fd5ef988984323810d3678d47cba6fa/acc16/surface-2.png 774w","sizes":"(min-width: 774px) 774px, 100vw"},"sources":[{"srcSet":"/static/5fd5ef988984323810d3678d47cba6fa/5036c/surface-2.webp 194w,\\n/static/5fd5ef988984323810d3678d47cba6fa/6aaa4/surface-2.webp 387w,\\n/static/5fd5ef988984323810d3678d47cba6fa/26906/surface-2.webp 774w","type":"image/webp","sizes":"(min-width: 774px) 774px, 100vw"}]},"width":774,"height":320}')},552:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#7878f8","images":{"fallback":{"src":"/static/6fe7653c1672859325c6018bb59934b5/b5658/normal.png","srcSet":"/static/6fe7653c1672859325c6018bb59934b5/acb7c/normal.png 256w,\\n/static/6fe7653c1672859325c6018bb59934b5/ccc41/normal.png 512w,\\n/static/6fe7653c1672859325c6018bb59934b5/b5658/normal.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/6fe7653c1672859325c6018bb59934b5/22bfc/normal.webp 256w,\\n/static/6fe7653c1672859325c6018bb59934b5/d689f/normal.webp 512w,\\n/static/6fe7653c1672859325c6018bb59934b5/67ded/normal.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}')},2884:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/f3159b4749780e30862cfec8b429914f/44290/surface-1.png","srcSet":"/static/f3159b4749780e30862cfec8b429914f/da927/surface-1.png 200w,\\n/static/f3159b4749780e30862cfec8b429914f/f3a26/surface-1.png 400w,\\n/static/f3159b4749780e30862cfec8b429914f/44290/surface-1.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/f3159b4749780e30862cfec8b429914f/19b05/surface-1.webp 200w,\\n/static/f3159b4749780e30862cfec8b429914f/1d7a5/surface-1.webp 400w,\\n/static/f3159b4749780e30862cfec8b429914f/6857b/surface-1.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":375}')}}]);
//# sourceMappingURL=component---src-pages-intermediates-normal-mapping-js-2ee11e468865ed89e5c0.js.map