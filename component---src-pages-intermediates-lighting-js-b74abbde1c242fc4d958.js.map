{"version":3,"file":"component---src-pages-intermediates-lighting-js-b74abbde1c242fc4d958.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/intermediates/lighting/first-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/first-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/first-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/first-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/fourth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/fourth-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/fourth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/fourth-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/light-point-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/light-point/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/light-point/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/fragment-lighting-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/fragment-lighting-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/fragment-lighting-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/no-light-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/no-light-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/no-light-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/no-light-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/second-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/second-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/second-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/second-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/third-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/third-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/third-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/third-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/vertex-lighting-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/lighting/vertex-lighting-example.js","webpack://shader-tutorial/./src/components/intermediates/lighting/vertex-lighting-example/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/lighting/vertex-lighting-example/fragment.glsl","webpack://shader-tutorial/./src/pages/intermediates/lighting.js","webpack://shader-tutorial/./src/images/intermediates/texture.png"],"sourcesContent":["import fragmentShader from \"!raw-loader!./first-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./first-example/vertex.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\nuniform vec3 lightColor;\\nuniform float lightIntensity;\\n\\nvarying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  uv = vertexUv;\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\\n\\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n}\";","export default \"varying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\n\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\\n\\n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\\n  gl_FragColor.a = surfaceColor.a;\\n}\";","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 4.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(0.3, 0.3, 0.3);\nconst lightIntensity = 50.0;\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst LightingFirstExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    normals: [\n      // Front normals\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      // Left normals\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      // Right normals\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      // Top normals\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Bottom normals\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      // Back normals\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          cube.normals.flat(),\n          cubeBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    World Position: ${coordArrToString(lightModelPosition)}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(LightingFirstExample);\n","import fragmentShader from \"!raw-loader!./fourth-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./fourth-example/vertex.glsl\";\n\nexport const fourthVertexShaderSource = vertexShader;\nexport const fourthFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying highp vec2 uv;\\nvarying highp vec4 fragmentPosition_viewSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\\n  fragmentNormal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  uv = vertexUv;\\n}\";","export default \"varying highp vec2 uv;\\nvarying highp vec4 fragmentPosition_viewSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\n\\nuniform highp mat4 viewMatrix;\\nuniform highp vec4 lightPosition_worldSpace;\\n\\nuniform highp vec3 lightColor;\\nuniform highp float lightIntensity;\\n\\nuniform highp float ambientFactor;\\n\\nuniform highp float specularLobeFactor;\\nuniform highp float specularReflectivity;\\n\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\\n  highp vec4 ambientColor = vec4(surfaceColor);\\n  highp vec4 specularColor = vec4(1.0);\\n\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - vec3(0.0, 0.0, 0.0));\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\\n\\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, fragmentNormal_viewSpace);\\n\\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\\n\\n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\\n  gl_FragColor.a = surfaceColor.a;\\n}\";","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fourthFragmentShaderSource, fourthVertexShaderSource } from \"./fourth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n      specularLobeFactor: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      ambientFactor: \"float\",\n      specularReflectivity: \"float\",\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 4.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(0.3, 0.3, 0.3);\nconst lightIntensity = 50.0;\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst LightingFourthExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    normals: [\n      // Front normals\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      // Left normals\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      // Right normals\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      // Top normals\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Bottom normals\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      // Back normals\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n    ambientFactor: 0.1,\n    specularReflectivity: 0.5,\n    specularLobeFactor: 5.0,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          fourthVertexShaderSource,\n          fourthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          cube.normals.flat(),\n          cubeBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.specularLobeFactor,\n              cube.specularLobeFactor,\n            );\n\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.ambientFactor,\n              cube.ambientFactor,\n            );\n\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.specularReflectivity,\n              cube.specularReflectivity,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Lighting:\n        Ambient Factor: ${cube.ambientFactor}\n        Specular Reflectivity: ${cube.specularReflectivity}\n        Lobe Density: ${cube.specularLobeFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(LightingFourthExample);\n","import vertexShader from \"!raw-loader!./light-point/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./light-point/fragment.glsl\";\n\nexport const lightPointVertexShaderSource = vertexShader;\nexport const lightPointFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\\n}\";","export default \"void main() {\\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n}\";","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fragmentLightingFragmentShaderSource, fragmentLightingVertexShaderSource } from \"./fragment-lighting-example-shaders\"\nimport { lightPointFragmentShaderSource, lightPointVertexShaderSource } from \"./light-point-shaders\"\n\nconst lightShaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexNormal: \"vec3\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(0.5, 0.2, 3.0, 1.0);\nconst lightColor = vec3.fromValues(1.0, 1.0, 1.0);\nconst lightIntensity = 2.25;\n\nconst squareModelPosition = mat4.create();\n\nconst VertexLightingExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n  };\n  const square = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n    normals: [\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n    ],\n    indices: [[0, 1, 2, 3, 4, 5]],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [lightShaderProgram, updateLightShaderProgram] = useState(null);\n  const [lightShaderInfo, updateLightShaderInfo] = useState(null);\n  const [lightBuffer, updateLightBuffer] = useState({\n    vertices: null,\n  });\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [squareBuffer, updatesquareBuffer] = useState({\n    vertices: null,\n    normals: null,\n    indices: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        squareModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateLightShaderProgram(\n        webGlRef.createShaderProgram(\n          lightPointVertexShaderSource,\n          lightPointFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(lightShaderProgram !== null, () => {\n      updateLightShaderInfo(\n        webGlRef.getDataLocations(lightShaderProgram, lightShaderProgramInfo),\n      );\n    }),\n    [lightShaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(lightShaderInfo !== null, () => {\n      updateLightBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          lightBuffer.vertices,\n        ),\n      });\n    }),\n    [lightShaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(lightBuffer.vertices !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          fragmentLightingVertexShaderSource,\n          fragmentLightingFragmentShaderSource,\n        ),\n      );\n    }),\n    [lightBuffer],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updatesquareBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          square.vertices.flat(),\n          squareBuffer.vertices,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          square.normals.flat(),\n          squareBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          square.indices.flat(),\n          squareBuffer.indices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(squareBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            {\n              const rotatedModelMatrix = mat4.create();\n              const rotationAngle = (30 * Math.PI) / 180;\n              mat4.translate(rotatedModelMatrix, modelMatrix, [0.0, 0.0, 2.0]);\n              mat4.rotateY(\n                rotatedModelMatrix,\n                rotatedModelMatrix,\n                rotationAngle,\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.vertices);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.normals);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexNormal,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexNormal,\n              );\n\n              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices);\n\n              gl.useProgram(shaderProgram);\n\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.projectionMatrix,\n                false,\n                projectionMatrix,\n              );\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.viewMatrix,\n                false,\n                viewMatrix,\n              );\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.modelMatrix,\n                false,\n                rotatedModelMatrix,\n              );\n\n              gl.uniform4fv(\n                shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n                lightModelPosition,\n              );\n              gl.uniform3fv(\n                shaderInfo.vertex.uniformLocations.lightColor,\n                lightColor,\n              );\n              gl.uniform1f(\n                shaderInfo.vertex.uniformLocations.lightIntensity,\n                lightIntensity,\n              );\n\n              gl.drawElements(\n                gl.TRIANGLES,\n                square.indices.length * square.indices[0].length,\n                gl.UNSIGNED_SHORT,\n                0,\n              );\n            }\n\n            {\n              const lightModelMatrix = mat4.create();\n              mat4.translate(\n                lightModelMatrix,\n                lightModelMatrix,\n                lightModelPosition,\n              );\n              mat4.scale(\n                lightModelMatrix,\n                lightModelMatrix,\n                [0.03, 0.03, 0.03],\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, lightBuffer.vertices);\n              gl.vertexAttribPointer(\n                lightShaderInfo.vertex.attributeLocations.vertexPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                lightShaderInfo.vertex.attributeLocations.vertexPosition,\n              );\n\n              gl.useProgram(lightShaderProgram);\n\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.projectionMatrix,\n                false,\n                projectionMatrix,\n              );\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.viewMatrix,\n                false,\n                viewMatrix,\n              );\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.modelMatrix,\n                false,\n                lightModelMatrix,\n              );\n\n              gl.drawArrays(gl.TRIANGLES, 0, triangle.vertices.length);\n            }\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [squareBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nSquare:\n    World Position: ${coordArrToString([0.0, 0.0, 0.0])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(VertexLightingExample);\n","export default \"attribute vec4 vertexPosition;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\n\\nvarying highp vec4 fragmentPosition_worldSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\nvarying highp vec3 lightDirection_viewSpace;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  \\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n  \\n  fragmentPosition_worldSpace = vertexPosition_worldSpace;\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  fragmentNormal_viewSpace = (viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz;\\n  lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\\n}\";","export default \"varying highp vec4 fragmentPosition_worldSpace;\\nvarying highp vec3 fragmentNormal_viewSpace;\\nvarying highp vec3 lightDirection_viewSpace;\\n\\nuniform highp mat4 viewMatrix;\\n\\nuniform highp vec3 lightColor;\\nuniform highp float lightIntensity;\\nuniform highp vec4 lightPosition_worldSpace;\\n\\nvoid main() {\\n  highp vec3 surfaceColor = vec3(1.0);\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);\\n\\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\\n  gl_FragColor.a = 1.0;\\n}\";","import fragmentShader from \"!raw-loader!./no-light-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./no-light-example/vertex.glsl\";\n\nexport const noLightVertexShaderSource = vertexShader;\nexport const noLightFragmentShaderSource = fragmentShader;\n","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { noLightFragmentShaderSource, noLightVertexShaderSource } from \"./no-light-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst LightingNoLightExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          noLightVertexShaderSource,\n          noLightFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(LightingNoLightExample);\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying highp vec2 uv;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\\n  uv = vertexUv;\\n}\";","export default \"varying highp vec2 uv;\\n\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  gl_FragColor = texture2D(colorTextureSampler, uv);\\n  gl_FragColor.rgb = gl_FragColor.rgb * 0.0;\\n}\";","import fragmentShader from \"!raw-loader!./second-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./second-example/vertex.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"varying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\n\\nuniform highp float ambientFactor;\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\\n  highp vec4 ambientColor = vec4(surfaceColor);\\n\\n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight);\\n  gl_FragColor.a = surfaceColor.a;\\n}\";","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      ambientFactor: \"float\",\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 4.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(0.3, 0.3, 0.3);\nconst lightIntensity = 50.0;\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst LightingSecondExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    normals: [\n      // Front normals\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      // Left normals\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      // Right normals\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      // Top normals\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Bottom normals\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      // Back normals\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n    ambientFactor: 0.1,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          cube.normals.flat(),\n          cubeBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.ambientFactor,\n              cube.ambientFactor,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Lighting:\n        Ambient Factor: ${cube.ambientFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(LightingSecondExample);\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\nuniform vec3 lightColor;\\nuniform float lightIntensity;\\n\\nvarying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  uv = vertexUv;\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\\n\\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n}\";","import fragmentShader from \"!raw-loader!./third-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./third-example/vertex.glsl\";\n\nexport const thirdVertexShaderSource = vertexShader;\nexport const thirdFragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\nuniform vec3 lightColor;\\nuniform float lightIntensity;\\nuniform float specularLobeFactor;\\n\\nvarying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\nvarying highp vec3 specularLight;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  uv = vertexUv;\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\\n\\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n\\n  highp vec3 viewDirection_viewSpace = normalize(vertexPosition_viewSpace.xyz - vec3(0.0, 0.0, 0.0));\\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, normal_viewSpace);\\n\\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\\n  specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\\n}\";","export default \"varying highp vec2 uv;\\nvarying highp vec3 diffuseLight;\\nvarying highp vec3 specularLight;\\n\\nuniform highp float ambientFactor;\\nuniform highp float specularReflectivity;\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\\n  highp vec4 ambientColor = vec4(surfaceColor);\\n  highp vec4 specularColor = vec4(1.0);\\n  \\n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\\n  gl_FragColor.a = surfaceColor.a;\\n}\";","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { thirdFragmentShaderSource, thirdVertexShaderSource } from \"./third-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n      vertexNormal: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n      specularLobeFactor: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      ambientFactor: \"float\",\n      specularReflectivity: \"float\",\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(4.0, 4.0, 4.0, 1.0);\nconst lightColor = vec3.fromValues(0.3, 0.3, 0.3);\nconst lightIntensity = 50.0;\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst LightingThirdExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    normals: [\n      // Front normals\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      // Left normals\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      [-1.0, 0.0, 0.0],\n      // Right normals\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      // Top normals\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Bottom normals\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      [0.0, -1.0, 0.0],\n      // Back normals\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n      [0.0, 0.0, -1.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n    ambientFactor: 0.1,\n    specularReflectivity: 0.5,\n    specularLobeFactor: 5.0,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    normals: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          thirdVertexShaderSource,\n          thirdFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          cube.normals.flat(),\n          cubeBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.normals);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexNormal,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.projectionMatrix,\n              false,\n              projectionMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.viewMatrix,\n              false,\n              viewMatrix,\n            );\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.modelMatrix,\n              false,\n              rotatedModelMatrix,\n            );\n\n            gl.uniform4fv(\n              shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n              lightModelPosition,\n            );\n            gl.uniform3fv(\n              shaderInfo.vertex.uniformLocations.lightColor,\n              lightColor,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.lightIntensity,\n              lightIntensity,\n            );\n            gl.uniform1f(\n              shaderInfo.vertex.uniformLocations.specularLobeFactor,\n              cube.specularLobeFactor,\n            );\n\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.ambientFactor,\n              cube.ambientFactor,\n            );\n\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.specularReflectivity,\n              cube.specularReflectivity,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Lighting:\n        Ambient Factor: ${cube.ambientFactor}\n        Specular Reflectivity: ${cube.specularReflectivity}\n        Lobe Density: ${cube.specularLobeFactor}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(LightingThirdExample);\n","import vertexShader from \"!raw-loader!./vertex-lighting-example/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./vertex-lighting-example/fragment.glsl\";\n\nexport const vertexLightingVertexShaderSource = vertexShader;\nexport const vertexLightingFragmentShaderSource = fragmentShader;\n","import { mat4, vec3, vec4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { lightPointFragmentShaderSource, lightPointVertexShaderSource } from \"./light-point-shaders\"\nimport { vertexLightingFragmentShaderSource, vertexLightingVertexShaderSource } from \"./vertex-lighting-example-shaders\"\n\nconst lightShaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexNormal: \"vec3\",\n    },\n    uniformLocations: {\n      modelMatrix: \"mat4\",\n      viewMatrix: \"mat4\",\n      projectionMatrix: \"mat4\",\n\n      lightPosition_worldSpace: \"vec4\",\n      lightColor: \"vec3\",\n      lightIntensity: \"float\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst lightModelPosition = vec4.fromValues(0.5, 0.2, 3.0, 1.0);\nconst lightColor = vec3.fromValues(1.0, 1.0, 1.0);\nconst lightIntensity = 2.25;\n\nconst squareModelPosition = mat4.create();\n\nconst VertexLightingExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n  };\n  const square = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n    normals: [\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n      [0.0, 0.0, 1.0],\n    ],\n    indices: [[0, 1, 2, 3, 4, 5]],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [lightShaderProgram, updateLightShaderProgram] = useState(null);\n  const [lightShaderInfo, updateLightShaderInfo] = useState(null);\n  const [lightBuffer, updateLightBuffer] = useState({\n    vertices: null,\n  });\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [squareBuffer, updatesquareBuffer] = useState({\n    vertices: null,\n    normals: null,\n    indices: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        squareModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateLightShaderProgram(\n        webGlRef.createShaderProgram(\n          lightPointVertexShaderSource,\n          lightPointFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(lightShaderProgram !== null, () => {\n      updateLightShaderInfo(\n        webGlRef.getDataLocations(lightShaderProgram, lightShaderProgramInfo),\n      );\n    }),\n    [lightShaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(lightShaderInfo !== null, () => {\n      updateLightBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          lightBuffer.vertices,\n        ),\n      });\n    }),\n    [lightShaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(lightBuffer.vertices !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          vertexLightingVertexShaderSource,\n          vertexLightingFragmentShaderSource,\n        ),\n      );\n    }),\n    [lightBuffer],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updatesquareBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          square.vertices.flat(),\n          squareBuffer.vertices,\n        ),\n        normals: webGlRef.createStaticDrawArrayBuffer(\n          square.normals.flat(),\n          squareBuffer.normals,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          square.indices.flat(),\n          squareBuffer.indices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(squareBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            {\n              const rotatedModelMatrix = mat4.create();\n              const rotationAngle = (30 * Math.PI) / 180;\n              mat4.translate(rotatedModelMatrix, modelMatrix, [0.0, 0.0, 2.0]);\n              mat4.rotateY(\n                rotatedModelMatrix,\n                rotatedModelMatrix,\n                rotationAngle,\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.vertices);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, squareBuffer.normals);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexNormal,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexNormal,\n              );\n\n              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareBuffer.indices);\n\n              gl.useProgram(shaderProgram);\n\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.projectionMatrix,\n                false,\n                projectionMatrix,\n              );\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.viewMatrix,\n                false,\n                viewMatrix,\n              );\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.modelMatrix,\n                false,\n                rotatedModelMatrix,\n              );\n\n              gl.uniform4fv(\n                shaderInfo.vertex.uniformLocations.lightPosition_worldSpace,\n                lightModelPosition,\n              );\n              gl.uniform3fv(\n                shaderInfo.vertex.uniformLocations.lightColor,\n                lightColor,\n              );\n              gl.uniform1f(\n                shaderInfo.vertex.uniformLocations.lightIntensity,\n                lightIntensity,\n              );\n\n              gl.drawElements(\n                gl.TRIANGLES,\n                square.indices.length * square.indices[0].length,\n                gl.UNSIGNED_SHORT,\n                0,\n              );\n            }\n\n            {\n              const lightModelMatrix = mat4.create();\n              mat4.translate(\n                lightModelMatrix,\n                lightModelMatrix,\n                lightModelPosition,\n              );\n              mat4.scale(\n                lightModelMatrix,\n                lightModelMatrix,\n                [0.03, 0.03, 0.03],\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, lightBuffer.vertices);\n              gl.vertexAttribPointer(\n                lightShaderInfo.vertex.attributeLocations.vertexPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                lightShaderInfo.vertex.attributeLocations.vertexPosition,\n              );\n\n              gl.useProgram(lightShaderProgram);\n\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.projectionMatrix,\n                false,\n                projectionMatrix,\n              );\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.viewMatrix,\n                false,\n                viewMatrix,\n              );\n              gl.uniformMatrix4fv(\n                lightShaderInfo.vertex.uniformLocations.modelMatrix,\n                false,\n                lightModelMatrix,\n              );\n\n              gl.drawArrays(gl.TRIANGLES, 0, triangle.vertices.length);\n            }\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [squareBuffer],\n  );\n\n  const colorCoords = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nSquare:\n    World Position: ${coordArrToString([0.0, 0.0, 0.0])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nLight:\n    World Position: ${coordArrToString(lightModelPosition)}\n    Color: ${coordArrToString(lightColor, colorCoords)}\n    Intensity: ${lightIntensity}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(VertexLightingExample);\n","export default \"attribute vec4 vertexPosition;\\nattribute vec3 vertexNormal;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nuniform vec4 lightPosition_worldSpace;\\nuniform vec3 lightColor;\\nuniform float lightIntensity;\\n\\nvarying highp vec3 diffuseLight;\\n\\nvoid main() {\\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\\n\\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\\n\\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\\n}\";","export default \"varying highp vec3 diffuseLight;\\n\\nvoid main() {\\n  highp vec3 surfaceColor = vec3(1.0);\\n  \\n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\\n  gl_FragColor.a = 1.0;\\n}\";","import { Link } from \"gatsby\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport Content from \"../../components/content\";\nimport Equation from \"../../components/equation/equation\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport LightingFirstExample from \"../../components/intermediates/lighting/first-example\";\nimport {\n  firstFragmentShaderSource,\n  firstVertexShaderSource,\n} from \"../../components/intermediates/lighting/first-example-shaders\";\nimport LightingFourthExample from \"../../components/intermediates/lighting/fourth-example\";\nimport {\n  fourthFragmentShaderSource,\n  fourthVertexShaderSource,\n} from \"../../components/intermediates/lighting/fourth-example-shaders\";\nimport FragmentLightingExample from \"../../components/intermediates/lighting/fragment-lighting-example\";\nimport LightingNoLightExample from \"../../components/intermediates/lighting/no-light-example.js\";\nimport LightingSecondExample from \"../../components/intermediates/lighting/second-example\";\nimport { secondFragmentShaderSource } from \"../../components/intermediates/lighting/second-example-shaders\";\nimport LightingThirdExample from \"../../components/intermediates/lighting/third-example\";\nimport {\n  thirdFragmentShaderSource,\n  thirdVertexShaderSource,\n} from \"../../components/intermediates/lighting/third-example-shaders\";\nimport VertexLightingExample from \"../../components/intermediates/lighting/vertex-lighting-example\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst LightingPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Intermediates - Lighting\"\n      description=\"A look into how lighting can be simulated on objects through shaders.\"\n      keywords={[\n        \"lighting\",\n        \"shader\",\n        \"intermediates\",\n        \"diffuse\",\n        \"specular\",\n        \"ambient\",\n      ]}\n    />\n    <Content>\n      <h1>Shader Intermediates - Lighting</h1>\n      <p>\n        While adding textures to color your objects helps to add more detail,\n        simulating the lighting of the environment on the object adds further\n        detail and makes it appear in place with the rest of the world.\n      </p>\n      <p>\n        There are three components of light reflection that come into effect\n        when simulating light falling on an object:\n      </p>\n      <ul>\n        <li>The diffuse component</li>\n        <li>The ambient component</li>\n        <li>The specular component</li>\n      </ul>\n      <p>\n        Let's look at each component, and how they effect the look of the object\n        when simulating lighting. We'll only work with a single point light,\n        which has light rays going from a single point in every direction, but\n        the same principles apply to other kinds of lights, as well as multiple\n        sources of light.\n      </p>\n      <p>\n        But before that, let's look at how the cube appears with no lighting for\n        reference.\n      </p>\n      <LightingNoLightExample />\n      <Heading type=\"h2\">The Diffuse Component</Heading>\n      <p>\n        The first component is the diffuse component and is the primary\n        reflection component that lights up objects.\n      </p>\n      <p>\n        When a ray of light hits an object, due to the roughness and texture of\n        the object, this light spreads out and reflects in multiple directions.\n      </p>\n      <p>\n        However, not all of the light is reflected. Certain colors that are part\n        of the light are absorbed by the object, with the rest being reflected.\n        The colors that are reflected by the object are the ones that we see,\n        which means these are the colors which we see as being the color of that\n        object.\n      </p>\n      <div className=\"util text-center\">\n        <img\n          src=\"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/diffuseWhite1.png\"\n          alt=\"Diffuse Lighting Main Example\"\n        />\n        <br />\n        <a\n          href=\"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        For example, when white light falls on an apple, we see that the apple\n        is red. This is because white light is made up of multiple colors in a\n        spectrum mixed together.\n      </p>\n      <p>\n        The colors that are not red are absorbed by the surface of the apple,\n        and the red components of light that remain are reflected. This results\n        in us seeing the apple as being red.\n      </p>\n      <p>\n        The light that shows us this color is what we consider as the diffuse\n        component of the light reflection of the apple.\n      </p>\n      <p>The diffuse component is dependent on four factors:</p>\n      <ul>\n        <li>\n          <strong>The color of the light</strong> - If the light is red and the\n          object is blue, since these two colors are completely separate in the\n          color spectrum, all the light is absorbed by the object and nothing is\n          reflected, making the object appear black (or having no color).\n        </li>\n        <li>\n          <strong>The intensity of the light</strong> - The brighter the source\n          of light is, more light will hit an object, making it appear brighter\n          (unless the example in the first point occurs).\n        </li>\n        <li>\n          <strong>The distance of the light source from the object</strong> -\n          The further away a source of light is from an object, the less intense\n          the light will be when it hits the object. This is due to the\n          <a\n            href=\"https://en.wikipedia.org/wiki/Inverse-square_law\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            inverse-square law\n          </a>\n          , which states that the intensity of the light is inversely\n          proportional to the square of the distance between the light source\n          and the object.\n        </li>\n        <li>\n          <strong>The angle at which the light hits the object</strong> - This\n          we'll explain below.\n        </li>\n      </ul>\n      <p>\n        If the light hits the surface of the object at an angle, the light gets\n        spread out over a wide surface.\n      </p>\n      <p>\n        However, if the light hits the surface at an angle that's closer to\n        perpendicular to the surface of the obejct, then a lot more light gets\n        concentrated across a smaller surface, making the surface appear\n        brighter.\n      </p>\n      <div className=\"util text-center\">\n        <img\n          src=\"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/diffuseAngle.png\"\n          alt=\"Diffuse Lighting Angle Example\"\n        />\n        <br />\n        <a\n          href=\"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        This can be done through an experiment as well. Grab your phone and turn\n        on the flashlight (or else grab a torch) and shine it perpendicularly\n        away by a certain distance on a rough surface and note down the\n        brightness.\n      </p>\n      <p>\n        Next, shine it from approximately the same distance at an acute angle to\n        the surface, with the light source being the same distance away as in\n        the first test.\n      </p>\n      <p>\n        The brightness of the surface should decrease when the light is shining\n        at an angle compared to when it was perpendicularly, and is why the\n        angle of the light compared to the surface of the object matters.\n      </p>\n      <p>\n        These four factors combined together affect how the diffuse reflection\n        will finally appear.\n      </p>\n      <p>\n        Since the diffuse component is what shows the color of an object, the\n        color map used to color an object is also called a diffuse map, since it\n        provides the color that the diffuse reflection is supposed to show.\n      </p>\n      <Heading type=\"h2\">Example - Cube with diffused reflection</Heading>\n      <LightingFirstExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        We now know that diffuse light is the light that shows the color of the\n        surface of an object, and it's brighter when the incident light is\n        closer to being perpendicular to the surface, its color falls within the\n        color spectrum of the object, has a high intensity, and is close to the\n        object.\n      </p>\n      <p>\n        The first thing required is the normal of the surface being lighted. A\n        normal can be considered as a direction that is perpendicular to a\n        surface. So if there was a surface that was across the XZ-plane, then\n        it's normal would be any direction along the Y-axis.\n      </p>\n      <p>\n        Since we can only tell the GPU information about each vertex, the normal\n        of the plane is set as the normal of each vertex forming that plane.\n      </p>\n      <p>\n        This way when the entire plane is being drawn, since all vertices have\n        the same normal, the entire plane will also be interpolated to have that\n        normal.\n      </p>\n      <p>\n        The second thing required is the direction of the light. Since the\n        position of the light and objects in the world are known, and the light\n        is a point light, the direction would be from the light source to the\n        object itself.\n      </p>\n      <p>\n        In order to determine the brightness of a point on the surface of the\n        object, the angle between the normal of the surface and the direction of\n        light must be compared.\n      </p>\n      <Heading type=\"h4\">The mathematics</Heading>\n      <p>\n        If the direction of the light is perpendicular to the surface, then the\n        angle between the direction of light and the normal of the surface will\n        equal 0 degrees, resulting in the brightness at that point should be\n        brightest.\n      </p>\n      <p>\n        Conversely, if the direction of the light is parallel to the surface,\n        then the angle between the direction of light and the normal of the\n        surface will be 90 degrees, which results in no light hitting the\n        surface and its brighness being zero.\n      </p>\n      <p>\n        Consider brightness as a factor from 0 to 1, where at 1, the brightness\n        is at its highest possible value, and at 0, it is at it's lowest\n        possible value.\n      </p>\n      <p>\n        So a mathematical operation is required which, when given an angle of 0\n        degrees provides a result of 1, and when given an angle of 0 degrees\n        provides a result of 0.\n      </p>\n      <p>\n        The best operation for this is the trignometric function{\" \"}\n        <Equation text={`cos(theta)`} />, where <Equation text={`theta`} /> is\n        the angle between the two directions.\n      </p>\n      <p>\n        Do note that if the angle between the normal and the light is greater\n        than 90 and upto 180, the result of this operation goes upto -1. So the\n        result of the operation needs to be clamped to 0 to prevent the diffuse\n        factor from being negative, since you can't have a negative amount of\n        light.\n      </p>\n      <p>\n        In the GPU, we'll be representing the directions of the surface normal\n        and light direction in the form of vectors. So a mathematical operation\n        is required between two vectors, which can provide us with the{\" \"}\n        <Equation text={`cos(theta)`} /> result of the angle between them. This\n        operation is the <code>dot</code> product.\n      </p>\n      <p>\n        Let us take two vectors <Equation text={`vec v_1`} /> and{\" \"}\n        <Equation text={`vec v_2`} />. The <code>dot</code> product of these two\n        vectors would be{\" \"}\n        <Equation\n          text={`vec v_1 cdot vec v_2 = norm(vec v_1) norm(vec v_2) cos(theta)`}\n        />\n        , where <Equation text={`norm(vec v_1)`} /> and{\" \"}\n        <Equation text={`norm(vec v_2)`} /> represent the magnitute of{\" \"}\n        <Equation text={`vec v_1`} /> and <Equation text={`vec v_2`} />{\" \"}\n        respectively.\n      </p>\n      <p>\n        The magnitude of a vector can be considered as a certain quantity that\n        is required to move a point from one place to another. The magnitude\n        combined with the direction of the vector forms the vector itself.\n      </p>\n      <p>\n        If we move around parts of this equation, we can represent this as\n        equation as{\" \"}\n        <Equation\n          text={`(vec v_1) / norm(vec v_1) cdot (vec v_2) / norm(vec v_2) = cos(theta)`}\n        />\n        , where <Equation text={`(vec v) / norm(vec v)`} /> is considered the\n        unit vector of the vector (represented as <Equation text={`hat(v)`} />\n        ), because the magnitude of the vector is removed from the vector\n        itself, leaving it as a single unit of itself that purely represents its\n        direction.\n      </p>\n      <p>\n        This results in the final equation being{\" \"}\n        <Equation text={`hat(v_1) cdot hat(v_2) = cos(theta)`} />, where{\" \"}\n        <Equation text={`hat(v_1)`} /> and <Equation text={`hat(v_2)`} />{\" \"}\n        represent the unit vectors of the vectors <Equation text={`vec v_1`} />{\" \"}\n        and <Equation text={`vec v_2`} />. So we can determine the{\" \"}\n        <Equation text={`cos(theta)`} /> of two vectors by finding the dot\n        product of their unit vectors. This can be done easily, because there\n        are built-in functions that let us calculate the unit vector of a given\n        vector.\n      </p>\n      <p>\n        Including the other factors that affect the diffuse reflection, the\n        final equation is:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`\"diffuseLight\" = ((hat \"lightDirection\" cdot hat \"surfaceNormal\") times \"lightColor\" times \"lightIntensity\") / \"distance\" ^ 2`}\n        />\n      </p>\n      <p>\n        The factors are combined through multiplication and division and not\n        addition and subtraction, because addition would mean that these factors\n        pile up on each other. However, these factors mix with each other to\n        determine the final factor of the diffuse reflection, which is done\n        through multiplcation and division.\n      </p>\n      <p>Let us look at the code to see how this equation is implemented.</p>\n      <GlslCodeHighlight\n        code={firstVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={firstFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        In the vertex shader, the lines 17-21 are the standard operations we've\n        seen in previous chapters, so they can be mostly ignored.\n      </p>\n      <p>\n        The important things to note from them is that the results of the\n        position of the vertex in the world-space and view-space (see the{\" \"}\n        <Link to=\"/basics/vertex-shader/\">Vertex Shader Basics</Link> if you\n        need to recollect) are saved in certain variables which will be required\n        later.\n      </p>\n      <p>\n        After those lines, we first calculate the combined product of the light\n        color and intensity, which is a simple multiplication. This result is\n        stored in a <code>vec3</code> named <code>lightColorIntensity</code>,\n        since it stores the intensity of each color (R, G, and B) of the light.\n      </p>\n      <p>\n        The distance between the light source and object is very simple. Since\n        the positions of both are already stored in vectors, the distance\n        between them can be calculated through a built-in function available in\n        shading languages. In GLSL, this function is <code>distance</code>.\n      </p>\n      <p>\n        Alternatively, the two vectors can be subtracted into another vector,\n        and the magnitude of that resultant vector would give us the distance\n        between the two points. The magnitude of a vector can be calculated in\n        GLSL using the built-in function <code>length</code>.\n      </p>\n      <p>\n        The direction of the normal of the vertex is required to be known\n        respective to the camera, which is why the calculation of the normal in\n        view-space (multiplying the model and view matrices) is performed and\n        stored in <code>normal_viweSpace</code>. This is similarly done for the\n        direction of the light and stored in the{\" \"}\n        <code>lightDirection_viweSpace</code>.\n      </p>\n      <p>\n        A point of note is that the direction of the light is stored as the\n        direction from the object to the light source. This allows our\n        calculations to be accurate, since if the light is falling perpendicular\n        to the surface, then the direction of the light is the same as the\n        normal of the vertex. This results in the <code>dot</code> product of\n        the two directions equaling <code>1</code>, which is what we require.\n      </p>\n      <p>\n        If the direction of the light was stored as the direction from the light\n        source to the object, then the resulting <code>dot</code> product of the\n        direction of the light and the vertex normal would be <code>-1</code>,\n        because the two vectors are pointing in the opposite direction.\n      </p>\n      <p>\n        The vectors calculate for the vertex normal and light direction in\n        view-space are converted into a unit vector, which is used to calculate\n        the diffuse factor by the angle of the light and the normal of the\n        surface. In GLSL, the built-in function for this calculation is{\" \"}\n        <code>normalize</code>.\n      </p>\n      <p>\n        The reason for normalizing vectors is so that we remove the influence of\n        magnitudes of vectors from calculations. A normalized vector only\n        provides information regarding its direction, but not the magnitude of\n        the direction. Since certain calculations we perform only require the\n        directions of vectors, those vectors are normalized.\n      </p>\n      <p>\n        The diffuse strength (strength of the diffuse reflection from the angle\n        of the light and the surface) is calculated by finding the dot product\n        of <code>normal_viewSpace</code> and{\" \"}\n        <code>lightDirection_viewSpace</code> (done through the built-in\n        function <code>dot</code> in GLSL). This is clamped between 0 and 1 to\n        prevent a negative diffuse strength.\n      </p>\n      <p>\n        The final diffuse reflection factor of the object is calculated by\n        multiplying the diffuse strength calculated in the previous step with\n        the product of the light color and intensity.\n      </p>\n      <p>\n        This result is then divided by the square of the distance between the\n        light and the object, which is required due to the inverse-square law.\n      </p>\n      <p>\n        This final diffuse factor is then passed to the fragment shader,\n        allowing the value to be interpolated per fragment. The diffuse factor\n        is multiplied with the surface color of the fragment to determine the\n        final color of that fragment.\n      </p>\n      <p>\n        Do note that the alpha value of the fragment color is not multiplied,\n        since the transparency of an object won't change based upon the light\n        falling on it.\n      </p>\n      <Heading type=\"h2\">The Ambient Component</Heading>\n      <p>\n        The ambient component is the second component of lighting reflection,\n        and is generally a much more subtle form of reflection. Ambient\n        reflection is not from direct interaction with the light source, but\n        interaction with the rest of the environment.\n      </p>\n      <p>\n        The rays of light from the light source hit other objects as well, and\n        the light reflected from these other objects in the environment bounce\n        around and eventually hit the primary object as well.\n      </p>\n      <p>\n        This light that comes indirectly through light bouncing of other objects\n        form the ambient component of lighting of an object, causing the object\n        to always have a minimum amount of brightness, either over the entire\n        object or over a certain area.\n      </p>\n      <p>\n        Since this the minimum brightness of an object caused due to the\n        environment, the diffuse lighting component adds on top of the ambient\n        component.\n      </p>\n      <Heading type=\"h2\">\n        Example - Cube with ambient and diffuse reflections\n      </Heading>\n      <LightingSecondExample />\n      <GlslCodeHighlight\n        code={secondFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Since the ambient component of lighting is just a minimum brightness of\n        the object due to the environment, the ambient factor doesn't need any\n        calculation, so the vertex shader requires no modification.\n      </p>\n      <p>\n        The ambient color is the color that the object produces when hit with\n        ambient light. This is the same as the diffuse color of an object in\n        most cases, which is why we're setting the ambient color the same as the\n        diffuse color. However, you could set this to a different color to\n        create interesting effects.\n      </p>\n      <p>\n        The ambient factor of the environment is directly passed to the fragment\n        shader, which is then multiplied with the ambient color of the fragment\n        to introduce the minimum brightness.\n      </p>\n      <p>\n        This is then added along with the diffusion component of lighting, since\n        the ambient lighting is the base brightness of the object, and the\n        diffusion component is an addition on top of it to further increase the\n        brightness of surfaces being hit by the light.\n      </p>\n      <Heading type=\"h2\">The Specular Component</Heading>\n      <p>\n        The specular component is the final component of lighting reflection and\n        is what gives objects a \"shine\".\n      </p>\n      <p>\n        Specular reflection is similar to reflection by a mirror. When a ray of\n        light hits the surface, depending on the smoothness of the surface, this\n        light may be completely reflected, like as if the surface were a mirror.\n      </p>\n      <div className=\"util text-center\">\n        <img\n          src=\"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/specular.png\"\n          alt=\"Specular Lighting Main Example\"\n        />\n        <br />\n        <a\n          href=\"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        If the reflected light is seen by the viewer, it would look like all, or\n        a part of the light was reflected by the object, giving the impression\n        the object has a shiny surface. This is specular reflection.\n      </p>\n      <p>\n        Just like how with diffuse reflection the brightness is dependent on the\n        angle of the light and the surface, with specular reflection the\n        brightness is dependent on the direction of the reflected light and the\n        direction of the camera.\n      </p>\n      <p>\n        Other than this factor, specular reflection is also dependent on all the\n        other factors that diffuse reflection is.\n      </p>\n      <Heading type=\"h2\">Example - Cube with all lighting components</Heading>\n      <LightingThirdExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        We can reuse the principles we've learnt from diffuse reflection. We\n        know that a factor of diffuse lighting is the angle of the reflected\n        light with the direction of the camera.\n      </p>\n      <Heading type=\"h4\">The mathematics</Heading>\n      <p>\n        If the direction of the camera is known, as well as the direction of the\n        reflected light, by applying the <code>dot</code> operation we've\n        learnt, we can calculate the the <Equation text={`cos(theta)`} /> angle\n        between them, which gives us the strength of the specular reflection.\n      </p>\n      <p>\n        The same <Equation text={`cos(theta)`} /> operation is required here\n        since the same principle applies - the closer the light reflection and\n        the camera are in the same direction, the brighter the specular\n        reflection will appear to be.\n      </p>\n      <p>\n        Another point to note is when calculating the <code>dot</code> product\n        of these two vectors, they must be in the relatively same direction.\n      </p>\n      <p>\n        What is meant by this is, if the direction of the camera is taken as the\n        direction from the camera to the object, then the direction of the\n        reflected light has to also be taken from the point the light is\n        travelling towards to the object.\n      </p>\n      <p>\n        If this condition is not satisfied, the two directions will appear to be\n        completely opposite to each other, resulting in their dot product being\n        in the opposite sign than they should be (negative when it should be\n        positive and vice-versa).\n      </p>\n      <p>\n        Another alternate solution to this issue is to multiply the result of\n        the dot product with -1 to get the correct result. Either solution can\n        be applied.\n      </p>\n      <p>\n        According to the law of reflection, the angle at which a ray of light\n        hits a surface (angle of incidence) is equal to the angle at which the\n        light reflects off the surface (angle of reflection).\n      </p>\n      <p>\n        Since the normal of a surface is always perpendicular to the surface,\n        this angle of incidence and angle of reflection are against the normal\n        of the surface.\n      </p>\n      <p>An image showing this law is below:</p>\n      <div className=\"util text-center\">\n        <img\n          src=\"https://www.asu.edu/courses/phs208/patternsbb/PiN/rdg/reflection/opticsRDG1.gif\"\n          alt=\"Law Of Reflection\"\n        />\n        <br />\n        <a\n          href=\"https://www.asu.edu/courses/phs208/patternsbb/PiN/rdg/reflection/reflection.shtml\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        We've already know the direction of the light to the object when\n        calculating diffuse reflection. Using the normal of the surface, the\n        direction of the reflected light can be calculated.\n      </p>\n      <p>\n        Once the dot product of the direction of the reflected light and\n        direction of the camera is calculated, it is combined with other factors\n        resulting in the final equation:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`\"specularLight\" = ((hat \"lightDirection\" cdot hat \"cameraDirection\")^\"Lobe Density\" times \"lightColor\" times \"lightIntensity\") / \"distance\" ^ 2`}\n        />\n      </p>\n      <p>\n        The lobe density defines how concentrated the specular reflection is\n        over a surface. A lower value means that the light is reflecting over a\n        larger surface area, and a higher value means that the light is\n        reflecting over a smaller surface area.\n      </p>\n      <p>Let us look at the code to see how this equation is implemented.</p>\n      <GlslCodeHighlight\n        code={thirdVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={thirdFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        In the vertex shader, the new code is from line 33. First the direction\n        of the camera is calculated. Since the object is in view, the direction\n        of the camera would be everywhere in view of the camera.\n      </p>\n      <p>\n        A direction vector is calculated by subtracting the vector that\n        represents the source point from the vector that represents the point\n        the direction is pointing towards.\n      </p>\n      <p>\n        In the case for calculating the direction of the camera, it is\n        calculated by subtracting the position of the camera from the direction\n        of the object.\n      </p>\n      <p>\n        In view-space, the camera is always at the center of the world, since in\n        view-space, everything is positioned relative to the camera. This is why\n        the position of the camera is taken as <code>vec3(0.0, 0.0, 0.0)</code>.\n      </p>\n      <p>\n        This direction is normalized so that the resultant vector calculated is\n        the unit vector that represents the just direction of the camera, with\n        no magnitude.\n      </p>\n      <p>\n        The light direction in view-space is known, along with the direction of\n        the normal of the surface. Using a built-in function, the reflection of\n        the direction of light w.r.t to the normal can be calculated. In GLSL,\n        this function is <code>reflect</code>.\n      </p>\n      <p>\n        The result of the reflection calculation is not normalized since the\n        direction of the incident light is already a unit vector, so it's\n        resultant reflection will also be a unit vector.\n      </p>\n      <p>\n        A point of note is that with <code>reflect</code> in GLSL, the light\n        direction still points away from the object, not towards it.\n      </p>\n      <p>\n        Imagine the normal of the surface as a mirror. When calculating the\n        reflection of the light direction relative to the normal, the reflection\n        would appear on the other side of the normal, but the direction won't\n        change.\n      </p>\n      <p>This is shown in the illustration below:</p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/glsl-reflect.png\"\n          alt=\"GLSL Reflect Function Result Illustration\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        Since the direction calculated for the camera is from the object to the\n        camera, the calculation of the <code>dot</code> product of the camera\n        direction and the light direction will still be accurate, since they are\n        both pointing away from the object.\n      </p>\n      <p>\n        This calculation is done in the next step to determine the strength of\n        the specular reflection. Similar to the same calculation for the\n        diffusion strength, this result is also clamped to between 0 and 1 to\n        prevent a negative strength result.\n      </p>\n      <p>\n        The final specular reflection factor is then calculated in the same way\n        as the diffusion factor - multiply the specular strength with the light\n        color and intensity, and divide it by the square of the distance of the\n        light source from the object.\n      </p>\n      <p>\n        Since the specular factor is also dependent on the specular lobe density\n        of the light, it is increased to the power of the lobe density. So the\n        more dense the light specular lobe is, the specular factor of the light\n        on the surface increases exponentially.\n      </p>\n      <p>\n        The result is then passed to the fragment shader, allowing it to be\n        interpolated per fragment.\n      </p>\n      <p>\n        The specular reflectivity is the value that determines how reflective or\n        smooth the surface of the object is.\n      </p>\n      <p>\n        The surfaces of objects aren't always perfectly smooth, but have very\n        small bumps in them. When light falls on an object, only a portion of\n        the light would be reflected by these bumps perfectly towards the\n        camera. The rest of the light would be reflected in other directions and\n        not contribute to the specular lighting component.\n      </p>\n      <p>\n        If we set the specular reflectivity of the surface to 1.0, it means that\n        all of the light is reflected by the surface of the object towards the\n        camera, making the surface of the object perfectly smooth.\n      </p>\n      <p>\n        However, if we set the specular reflectivity to 0.5, only 50% of the\n        light is reflected towards the camera by the surface of the object, with\n        the rest being reflected in other directions.\n      </p>\n      <p>\n        In our case, we've set the specular reflectivity to 0.5, meaning that\n        the cube only reflects 50% of the light falling on it.\n      </p>\n      <p>\n        The color of specular lighting is also dependent on the specular color\n        that the surface emits during specular reflection, as the surface can\n        absorb part of the light, and reflect the rest of it, resulting in it\n        having a different color.\n      </p>\n      <p>\n        The specular color value is generally set to the color of the object,\n        but we set the specular color value to{\" \"}\n        <Equation text={`(1.0, 1.0, 1.0)`} /> as we want all the light falling\n        on the surface to be reflected without any parts being absorbed.\n      </p>\n      <p>\n        The specular factor is multiplied against the specular reflectivity and\n        the specular color of the fragment, and then added to the other lighting\n        reflection components to set the final color value of the fragment.\n      </p>\n      <Heading type=\"h2\">Per-vertex vs Per-fragment lighting</Heading>\n      <p>\n        All lighting factors we calculated was done on the vertex shader, which\n        is then passed to the fragment shader, allowing the GPU to interpolate\n        the factor for each fragment. This is doing lighting calculations\n        \"per-vertex\".\n      </p>\n      <p>\n        The reason that this is done on the vertex shader and not the fragment\n        shader is to reduce the number of calculations, similar to why the MVP\n        matrix is passed directly instead of the multiplication being done on\n        the GPU.\n      </p>\n      <p>\n        There will always be considerably more fragments that a fragment shader\n        would have to process than vertices that a vertex shader would have to\n        process.\n      </p>\n      <p>\n        This means that any calculations done on a fragment shader will be done\n        much more in comparison to a calculation done on the vertex shader.\n      </p>\n      <p>\n        To save on computation time, if there is a calculation on the fragment\n        shader can be performed on the vertex shader and then interpolated for\n        each fragment, it is recommended to perform that calculation on the\n        vertex shader.\n      </p>\n      <p>\n        This optimization reduces the number of overall computations performed\n        and relies on the GPU interpolating values correctly.\n      </p>\n      <p>\n        However, this may not always produce accurate results. Since the GPU has\n        to interpolate the lighting values of the fragments inside the polygon\n        based on the values returned for each vertex, it is possible for\n        inaccuracies to be present.\n      </p>\n      <p>\n        Let's illustrate with an example to show how per-vertex lighting can\n        produce incorrect results compared to per-fragment lighting.\n      </p>\n      <FragmentLightingExample />\n      <p>\n        Here we have a light source (represented as the red triangle) present\n        near the center of a wall, shining towards it. The light is focused\n        towards the center of the wall, making the inside of the wall brighter\n        than the corners and edges.\n      </p>\n      <p>\n        This is rendered by performing the lighting calculations on the fragment\n        instead of on the vertex, meaning that the light is calculated on a\n        \"per-fragment\" basis.\n      </p>\n      <p>\n        Calculating the lighting on the fragment shader results in a much more\n        accurate result since the light values of the fragments inside the\n        polygon aren't interpolated from the vertex.\n      </p>\n      <p>\n        Only the locations of the fragments, and their normals are interpolated\n        from there, which has no issues since interpolating the position of a\n        fragment based on the position of its vertices is simple for GPUs to do.\n      </p>\n      <p>\n        Now lets look at how the lighting looks if we perform the lighting\n        calculation for each vertex instead and let the GPU interpolate those\n        lighting values for the fragments inside the polygons.\n      </p>\n      <VertexLightingExample />\n      <p>\n        The results when performing lighting calculations per-vertex are much\n        more inaccurate compared to if the calculations are performed\n        per-fragment.\n      </p>\n      <p>\n        The reason for this is simple: the amount of light falling on the\n        corners of the wall is lower than the amount of light falling at the\n        center of the wall.\n      </p>\n      <p>\n        This means that when calculating the lighting values at the vertices,\n        since the amount of light is lower due to the further distance from the\n        light source, the results will be low.\n      </p>\n      <p>\n        Now the GPU only has information on the lighting values for each vertex.\n        It has no information regarding the light source or how these values are\n        calculated.\n      </p>\n      <p>\n        As a result, when it needs to interpolate the lighting values at the\n        center of the wall, it can only assume that the amount of light falling\n        on the center of the screen is somewhere in between the amount of light\n        falling on each vertex.\n      </p>\n      <p>\n        The resolution (amount of detail) in per-vertex lighting is dependent on\n        the number of vertices being drawn. The more vertices being processed,\n        the more data the GPU has available to interpolate the values for the\n        rest of the fragments.\n      </p>\n      <p>\n        However, the resolution for per-fragment lighting is equal to the number\n        of fragments being drawn. Since we perform the lighting calculation for\n        each fragment, we know that the final lighting calculation will be\n        accurate for that fragment.\n      </p>\n      <p>\n        The only thing really required for per-fragment lighting is\n        interpolating the position of a fragment in a polygon. This can always\n        be easily interpolated by the GPU since the position of a fragment can\n        always be interpolated using the positions of the vertices and where the\n        fragment is present relative to those vertices.\n      </p>\n      <p>\n        Now let's look at our cube example, but with per-fragment lighting\n        calculations.\n      </p>\n      <LightingFourthExample />\n      <GlslCodeHighlight\n        code={fourthVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={fourthFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        You can see that the lighting in this example is different compared to\n        the previous cube example, and shows how per-vertex lighting can produce\n        incorrect results if not used correctly.\n      </p>\n      <p>\n        In our code, we've moved all lighting calculations onto the fragment\n        shader. The vertex shader only provides the fragment shader with values\n        that the GPU should always be able to correctly interpolate for each\n        fragment.\n      </p>\n      <p>\n        The fragment shader can then calculate the final lighting values for\n        each fragment using the interpolated results.\n      </p>\n      <p>\n        The values being passed to the fragment shader from the vertex shader\n        are:\n      </p>\n      <ul>\n        <li>\n          <code>vertexPosition_viewSpace</code>\n          <div style={{ paddingLeft: \"2.5rem\" }}>\n            The position of the vertex in view-space. This is interpolated into\n            the position of the fragment in view-space.\n          </div>\n          <div style={{ paddingLeft: \"2.5rem\" }}>\n            Since the vertex position describes where a vertex is located, and\n            the position of each vertex determine where a polygon is located,\n            the position of a fragment can be interpolated through the position\n            of each vertex of the polygon it is present in.\n          </div>\n        </li>\n        <li>\n          <code>vertexNormal_viewSpace</code>\n          <div style={{ paddingLeft: \"2.5rem\" }}>\n            The position of the vertex in world-space. This is interpolated into\n            the normal of the fragment in view-space.\n          </div>\n          <div style={{ paddingLeft: \"2.5rem\" }}>\n            Since the vertex normal describes which direction a vertex is\n            facing, and the normals of each vertex determine which direction a\n            polygon faces, the normal of a fragment can be interpolated through\n            the normals of each vertex of the polygon it is present in.\n          </div>\n        </li>\n      </ul>\n      <p>\n        In future examples with lighting, we'll be performing the lighting\n        calculations per-fragment instead of per-vertex for more accuracy.\n      </p>\n      <Heading type=\"h2\">Additional Notes</Heading>\n      <p>\n        This process can also be called shading, since we are \"shading\" an\n        object based on how light falls on it. Certain topics taught later also\n        fall under the process of shading since the contribute to the way an\n        object is \"shaded\".\n      </p>\n      <p>\n        A point of note is that for specular lighting we provided a value to\n        control how much of the light is reflected towards the camera (the\n        specular reflectivity).\n      </p>\n      <p>\n        For diffuse lighting, the roughness of the surface should also be\n        considered when calculating how much of the light is diffused by the\n        object, since a rougher surface would diffuse more light than a smooth\n        one.\n      </p>\n      <p>\n        However, the roughness of the surface can be multiplied against the\n        color of the surface and stored as part of the color map itself,\n        resulting in a map called a \"diffuse map\".\n      </p>\n      <p>\n        In later chapters, we'll be using a diffuse map instead of a simple\n        color map to provide diffuse color information.\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          Lighting helps to make an object seem more in place with the world\n        </li>\n        <li>\n          There are three reflection components when lighting an object:\n          <ul>\n            <li>\n              <strong>Diffuse Component</strong> - The component that shows us\n              the color and look of the object. Brightness depends on at what\n              angle the light hits the surface.\n            </li>\n            <li>\n              <strong>Ambient Component</strong> - The component that is\n              resultant from the light reflected by the rest of the environment\n              onto the object. Results in the object always having a minimum\n              amount of brightness.\n            </li>\n            <li>\n              <strong>Specular Component</strong> - The component that is\n              resultant from the light reflected by the object towards the\n              camera. Results in the object looking like it has a reflective\n              surface.\n            </li>\n          </ul>\n        </li>\n        <li>\n          When the main three lighting components are combined, they simulate\n          realistic lighting of an object in a basic form.\n        </li>\n      </ul>\n    </Content>\n    <PageChange\n      previous=\"/intermediates/color-mapping/\"\n      next=\"/intermediates/normal-mapping/\"\n    />\n  </Layout>\n);\n\nexport default LightingPage;\n","export default __webpack_public_path__ + \"static/texture-d46d879879755d42e588c10e2b6c3335.png\";"],"names":["firstVertexShaderSource","firstFragmentShaderSource","shaderProgramInfo","vertex","attributeLocations","vertexPosition","vertexUv","vertexNormal","uniformLocations","modelMatrix","viewMatrix","projectionMatrix","lightPosition_worldSpace","lightColor","lightIntensity","fragment","colorTextureSampler","lightModelPosition","vec4","vec3","cubeModelPosition","mat4","cubeFaceUvs","wrapExample","LightingFirstExample","cube","vertices","uvs","concat","normals","indices","texture","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","cubeBuffer","updateCubeBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","createElementArrayBuffer","createImageTexture","shouldRender","renderScene","_ref","gl","time","parseInt","performance","now","toString","rotatedModelMatrix","rotationAngle","Math","PI","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","useProgram","uniformMatrix4fv","uniform4fv","uniform3fv","uniform1f","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","drawElements","TRIANGLES","length","UNSIGNED_SHORT","requestAnimationFrame","React","className","style","padding","width","height","ref","coordArrToString","trim","x","y","z","fourthVertexShaderSource","fourthFragmentShaderSource","specularLobeFactor","ambientFactor","specularReflectivity","LightingFourthExample","lightPointVertexShaderSource","lightPointFragmentShaderSource","lightShaderProgramInfo","squareModelPosition","VertexLightingExample","triangle","square","lightShaderProgram","updateLightShaderProgram","lightShaderInfo","updateLightShaderInfo","lightBuffer","updateLightBuffer","squareBuffer","updatesquareBuffer","lightModelMatrix","drawArrays","LightingNoLightExample","secondFragmentShaderSource","LightingSecondExample","thirdVertexShaderSource","thirdFragmentShaderSource","LightingThirdExample","location","pathname","Layout","Seo","title","description","keywords","Content","Heading","type","src","alt","href","target","rel","Equation","text","GlslCodeHighlight","code","Link","to","StaticImage","maxWidth","__imageData","require","FragmentLightingExample","paddingLeft","PageChange","previous","next"],"sourceRoot":""}