"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[786],{9830:function(e,t,i){i.r(t),i.d(t,{default:function(){return ve}});var r=i(4794),n=i(2532),o=i(6540),a=i(9460),l=i(7722),c=i(7154),s=i(6042),h=(i(6449),i(3514),i(4796)),u=i(329),f=i(7684),m=i(6018),g=i(3461),v=i(6417),d=i(782);const p="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\nuniform vec3 lightColor;\nuniform float lightIntensity;\n\nvarying highp vec2 uv;\nvarying highp vec3 diffuseLight;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  uv = vertexUv;\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n}",x="varying highp vec2 uv;\nvarying highp vec3 diffuseLight;\n\nuniform sampler2D colorTextureSampler;\n\nvoid main() {\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\n\n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\n  gl_FragColor.a = surfaceColor.a;\n}",w={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float"}},fragment:{attributeLocations:{},uniformLocations:{colorTextureSampler:"sampler2D"}}},b=h.fA(4,4,4,1),E=u.fA(.3,.3,.3),y=f.vt(),S=[[0,0],[0,1],[1,0],[0,1],[1,0],[1,1]];var L=(0,v.A)((()=>{const e={vertices:[[-1,-1,1],[-1,1,1],[1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[-1,-1,-1],[-1,1,-1],[-1,-1,1],[-1,1,-1],[-1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[1,-1,-1],[1,1,1],[1,-1,-1],[1,1,-1],[-1,1,1],[-1,1,-1],[1,1,1],[-1,1,-1],[1,1,1],[1,1,-1],[-1,-1,-1],[-1,-1,1],[1,-1,-1],[-1,-1,1],[1,-1,-1],[1,-1,1],[1,-1,-1],[1,1,-1],[-1,-1,-1],[1,1,-1],[-1,-1,-1],[-1,1,-1]],uvs:[].concat(S,S,S,S,S,S),normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23],[24,25,26,27,28,29],[30,31,32,33,34,35]],texture:m.A},{0:t,1:i}=(0,o.useState)(null),{0:r,1:n}=(0,o.useState)(null),{0:a,1:l}=(0,o.useState)(null),{0:c,1:s}=(0,o.useState)({vertices:null,uvs:null,normals:null,indices:null,texture:null}),h=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,y);return i(e),()=>{i(null),e.destroy()}}}),[h]),(0,o.useEffect)((0,g.sT)(null!==t,(()=>{n(t.createShaderProgram(p,x))})),[t]),(0,o.useEffect)((0,g.sT)(null!==r,(()=>{l(t.getDataLocations(r,w))})),[r]),(0,o.useEffect)((0,g.sT)(null!==a,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[a]),(0,o.useEffect)((0,g.sT)(null!==c.vertices,(()=>{let i=!0;const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:l,viewMatrix:s,modelMatrix:h}=t;if(!i)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString()),m=f.vt(),g=u/30%2160*Math.PI/180;f.Qr(m,h,g),f.eL(m,m,g/2),f.Z8(m,m,g/3),o.bindBuffer(o.ARRAY_BUFFER,c.vertices),o.vertexAttribPointer(a.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexPosition),o.bindBuffer(o.ARRAY_BUFFER,c.uvs),o.vertexAttribPointer(a.vertex.attributeLocations.vertexUv,2,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexUv),o.bindBuffer(o.ARRAY_BUFFER,c.normals),o.vertexAttribPointer(a.vertex.attributeLocations.vertexNormal,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexNormal),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,c.indices),o.useProgram(r),o.uniformMatrix4fv(a.vertex.uniformLocations.projectionMatrix,!1,l),o.uniformMatrix4fv(a.vertex.uniformLocations.viewMatrix,!1,s),o.uniformMatrix4fv(a.vertex.uniformLocations.modelMatrix,!1,m),o.uniform4fv(a.vertex.uniformLocations.lightPosition_worldSpace,b),o.uniform3fv(a.vertex.uniformLocations.lightColor,E),o.uniform1f(a.vertex.uniformLocations.lightIntensity,50),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,c.texture),o.uniform1i(a.fragment.uniformLocations.colorTextureSampler,0),o.drawElements(o.TRIANGLES,e.indices.length*e.indices[0].length,o.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{i=!1}})),[c]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nCube:\n    World Position: "+(0,g.NW)(b)+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(b)+"\n    Color: "+(0,g.NW)(E,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))}));const A="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying highp vec2 uv;\nvarying highp vec4 fragmentPosition_viewSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\n  fragmentNormal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  uv = vertexUv;\n}",T="varying highp vec2 uv;\nvarying highp vec4 fragmentPosition_viewSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\n\nuniform highp mat4 viewMatrix;\nuniform highp vec4 lightPosition_worldSpace;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\n\nuniform highp float ambientFactor;\n\nuniform highp float specularLobeFactor;\nuniform highp float specularReflectivity;\n\nuniform sampler2D colorTextureSampler;\n\nvoid main() {\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\n  highp vec4 ambientColor = vec4(surfaceColor);\n  highp vec4 specularColor = vec4(1.0);\n\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - vec3(0.0, 0.0, 0.0));\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\n\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, fragmentNormal_viewSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n\n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\n  gl_FragColor.a = surfaceColor.a;\n}",_={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{ambientFactor:"float",specularReflectivity:"float",colorTextureSampler:"sampler2D"}}},P=h.fA(4,4,4,1),M=u.fA(.3,.3,.3),F=f.vt(),R=[[0,0],[0,1],[1,0],[0,1],[1,0],[1,1]];var N=(0,v.A)((()=>{const e={vertices:[[-1,-1,1],[-1,1,1],[1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[-1,-1,-1],[-1,1,-1],[-1,-1,1],[-1,1,-1],[-1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[1,-1,-1],[1,1,1],[1,-1,-1],[1,1,-1],[-1,1,1],[-1,1,-1],[1,1,1],[-1,1,-1],[1,1,1],[1,1,-1],[-1,-1,-1],[-1,-1,1],[1,-1,-1],[-1,-1,1],[1,-1,-1],[1,-1,1],[1,-1,-1],[1,1,-1],[-1,-1,-1],[1,1,-1],[-1,-1,-1],[-1,1,-1]],uvs:[].concat(R,R,R,R,R,R),normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23],[24,25,26,27,28,29],[30,31,32,33,34,35]],texture:m.A,ambientFactor:.1,specularReflectivity:.5,specularLobeFactor:5},{0:t,1:i}=(0,o.useState)(null),{0:r,1:n}=(0,o.useState)(null),{0:a,1:l}=(0,o.useState)(null),{0:c,1:s}=(0,o.useState)({vertices:null,uvs:null,normals:null,indices:null,texture:null}),h=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,F);return i(e),()=>{i(null),e.destroy()}}}),[h]),(0,o.useEffect)((0,g.sT)(null!==t,(()=>{n(t.createShaderProgram(A,T))})),[t]),(0,o.useEffect)((0,g.sT)(null!==r,(()=>{l(t.getDataLocations(r,_))})),[r]),(0,o.useEffect)((0,g.sT)(null!==a,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[a]),(0,o.useEffect)((0,g.sT)(null!==c.vertices,(()=>{let i=!0;const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:l,viewMatrix:s,modelMatrix:h}=t;if(!i)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString()),m=f.vt(),g=u/30%2160*Math.PI/180;f.Qr(m,h,g),f.eL(m,m,g/2),f.Z8(m,m,g/3),o.bindBuffer(o.ARRAY_BUFFER,c.vertices),o.vertexAttribPointer(a.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexPosition),o.bindBuffer(o.ARRAY_BUFFER,c.uvs),o.vertexAttribPointer(a.vertex.attributeLocations.vertexUv,2,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexUv),o.bindBuffer(o.ARRAY_BUFFER,c.normals),o.vertexAttribPointer(a.vertex.attributeLocations.vertexNormal,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexNormal),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,c.indices),o.useProgram(r),o.uniformMatrix4fv(a.vertex.uniformLocations.projectionMatrix,!1,l),o.uniformMatrix4fv(a.vertex.uniformLocations.viewMatrix,!1,s),o.uniformMatrix4fv(a.vertex.uniformLocations.modelMatrix,!1,m),o.uniform4fv(a.vertex.uniformLocations.lightPosition_worldSpace,P),o.uniform3fv(a.vertex.uniformLocations.lightColor,M),o.uniform1f(a.vertex.uniformLocations.lightIntensity,50),o.uniform1f(a.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),o.uniform1f(a.fragment.uniformLocations.ambientFactor,e.ambientFactor),o.uniform1f(a.fragment.uniformLocations.specularReflectivity,e.specularReflectivity),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,c.texture),o.uniform1i(a.fragment.uniformLocations.colorTextureSampler,0),o.drawElements(o.TRIANGLES,e.indices.length*e.indices[0].length,o.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{i=!1}})),[c]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nCube:\n    World Position: "+(0,g.NW)(P)+"\n    Lighting:\n        Ambient Factor: "+e.ambientFactor+"\n        Specular Reflectivity: "+e.specularReflectivity+"\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(P)+"\n    Color: "+(0,g.NW)(M,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))}));const j="attribute vec4 vertexPosition;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\n}",C="void main() {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",I={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{}}},D={vertex:{attributeLocations:{vertexPosition:"vec4",vertexNormal:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float"}},fragment:{attributeLocations:{},uniformLocations:{}}},B=h.fA(.5,.2,3,1),U=u.fA(1,1,1),k=f.vt();var W=(0,v.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]]},t={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],indices:[[0,1,2,3,4,5]]},{0:i,1:r}=(0,o.useState)(null),{0:n,1:a}=(0,o.useState)(null),{0:l,1:c}=(0,o.useState)(null),{0:s,1:h}=(0,o.useState)({vertices:null}),{0:u,1:m}=(0,o.useState)(null),{0:v,1:p}=(0,o.useState)(null),{0:x,1:w}=(0,o.useState)({vertices:null,normals:null,indices:null}),b=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==b.current){const e=new d.A(b.current,k);return r(e),()=>{r(null),e.destroy()}}}),[b]),(0,o.useEffect)((0,g.sT)(null!==i,(()=>{a(i.createShaderProgram(j,C))})),[i]),(0,o.useEffect)((0,g.sT)(null!==n,(()=>{c(i.getDataLocations(n,I))})),[n]),(0,o.useEffect)((0,g.sT)(null!==l,(()=>{h({vertices:i.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[l]),(0,o.useEffect)((0,g.sT)(null!==s.vertices,(()=>{m(i.createShaderProgram("attribute vec4 vertexPosition;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\n\nvarying highp vec4 fragmentPosition_worldSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\nvarying highp vec3 lightDirection_viewSpace;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  \n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n  \n  fragmentPosition_worldSpace = vertexPosition_worldSpace;\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  fragmentNormal_viewSpace = (viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz;\n  lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\n}","varying highp vec4 fragmentPosition_worldSpace;\nvarying highp vec3 fragmentNormal_viewSpace;\nvarying highp vec3 lightDirection_viewSpace;\n\nuniform highp mat4 viewMatrix;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\nuniform highp vec4 lightPosition_worldSpace;\n\nvoid main() {\n  highp vec3 surfaceColor = vec3(1.0);\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_worldSpace, lightPosition_worldSpace);\n\n  highp float diffuseStrength = clamp(dot(fragmentNormal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  highp vec3 diffuseLight =  (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\n  gl_FragColor.a = 1.0;\n}"))})),[s]),(0,o.useEffect)((0,g.sT)(null!==u,(()=>{p(i.getDataLocations(u,D))})),[u]),(0,o.useEffect)((0,g.sT)(null!==v,(()=>{w({vertices:i.createStaticDrawArrayBuffer(t.vertices.flat(),x.vertices),normals:i.createStaticDrawArrayBuffer(t.normals.flat(),x.normals),indices:i.createElementArrayBuffer(t.indices.flat(),x.indices)})})),[v]),(0,o.useEffect)((0,g.sT)(null!==x.vertices,(()=>{let r=!0;const o=()=>{i.renderScene((i=>{let{gl:a,projectionMatrix:c,viewMatrix:h,modelMatrix:m}=i;if(r){{const e=f.vt(),i=30*Math.PI/180;f.Tl(e,m,[0,0,2]),f.Z8(e,e,i),a.bindBuffer(a.ARRAY_BUFFER,x.vertices),a.vertexAttribPointer(v.vertex.attributeLocations.vertexPosition,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(v.vertex.attributeLocations.vertexPosition),a.bindBuffer(a.ARRAY_BUFFER,x.normals),a.vertexAttribPointer(v.vertex.attributeLocations.vertexNormal,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(v.vertex.attributeLocations.vertexNormal),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,x.indices),a.useProgram(u),a.uniformMatrix4fv(v.vertex.uniformLocations.projectionMatrix,!1,c),a.uniformMatrix4fv(v.vertex.uniformLocations.viewMatrix,!1,h),a.uniformMatrix4fv(v.vertex.uniformLocations.modelMatrix,!1,e),a.uniform4fv(v.vertex.uniformLocations.lightPosition_worldSpace,B),a.uniform3fv(v.vertex.uniformLocations.lightColor,U),a.uniform1f(v.vertex.uniformLocations.lightIntensity,2.25),a.drawElements(a.TRIANGLES,t.indices.length*t.indices[0].length,a.UNSIGNED_SHORT,0)}{const t=f.vt();f.Tl(t,t,B),f.hs(t,t,[.03,.03,.03]),a.bindBuffer(a.ARRAY_BUFFER,s.vertices),a.vertexAttribPointer(l.vertex.attributeLocations.vertexPosition,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(l.vertex.attributeLocations.vertexPosition),a.useProgram(n),a.uniformMatrix4fv(l.vertex.uniformLocations.projectionMatrix,!1,c),a.uniformMatrix4fv(l.vertex.uniformLocations.viewMatrix,!1,h),a.uniformMatrix4fv(l.vertex.uniformLocations.modelMatrix,!1,t),a.drawArrays(a.TRIANGLES,0,e.vertices.length)}requestAnimationFrame(o)}}))};return requestAnimationFrame(o),()=>{r=!1}})),[x]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:b},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,g.NW)([0,0,0])+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(B)+"\n    Color: "+(0,g.NW)(U,{x:"r",y:"g",z:"b"})+"\n    Intensity: 2.25\n").trim()))}));const q={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{colorTextureSampler:"sampler2D"}}},G=f.vt(),z=[[0,0],[0,1],[1,0],[0,1],[1,0],[1,1]];var O=(0,v.A)((()=>{const e={vertices:[[-1,-1,1],[-1,1,1],[1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[-1,-1,-1],[-1,1,-1],[-1,-1,1],[-1,1,-1],[-1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[1,-1,-1],[1,1,1],[1,-1,-1],[1,1,-1],[-1,1,1],[-1,1,-1],[1,1,1],[-1,1,-1],[1,1,1],[1,1,-1],[-1,-1,-1],[-1,-1,1],[1,-1,-1],[-1,-1,1],[1,-1,-1],[1,-1,1],[1,-1,-1],[1,1,-1],[-1,-1,-1],[1,1,-1],[-1,-1,-1],[-1,1,-1]],uvs:[].concat(z,z,z,z,z,z),indices:[[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23],[24,25,26,27,28,29],[30,31,32,33,34,35]],texture:m.A},{0:t,1:i}=(0,o.useState)(null),{0:r,1:n}=(0,o.useState)(null),{0:a,1:l}=(0,o.useState)(null),{0:c,1:s}=(0,o.useState)({vertices:null,uvs:null,indices:null,texture:null}),h=(0,o.useRef)();return(0,o.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,G);return i(e),()=>{i(null),e.destroy()}}}),[h]),(0,o.useEffect)((0,g.sT)(null!==t,(()=>{n(t.createShaderProgram("attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying highp vec2 uv;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\n  uv = vertexUv;\n}","varying highp vec2 uv;\n\nuniform sampler2D colorTextureSampler;\n\nvoid main() {\n  gl_FragColor = texture2D(colorTextureSampler, uv);\n  gl_FragColor.rgb = gl_FragColor.rgb * 0.0;\n}"))})),[t]),(0,o.useEffect)((0,g.sT)(null!==r,(()=>{l(t.getDataLocations(r,q))})),[r]),(0,o.useEffect)((0,g.sT)(null!==a,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[a]),(0,o.useEffect)((0,g.sT)(null!==c.vertices,(()=>{let i=!0;const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:l,viewMatrix:s,modelMatrix:h}=t;if(!i)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString()),m=f.vt(),g=u/30%2160*Math.PI/180;f.Qr(m,h,g),f.eL(m,m,g/2),f.Z8(m,m,g/3),o.bindBuffer(o.ARRAY_BUFFER,c.vertices),o.vertexAttribPointer(a.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexPosition),o.bindBuffer(o.ARRAY_BUFFER,c.uvs),o.vertexAttribPointer(a.vertex.attributeLocations.vertexUv,2,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexUv),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,c.indices),o.useProgram(r),o.uniformMatrix4fv(a.vertex.uniformLocations.projectionMatrix,!1,l),o.uniformMatrix4fv(a.vertex.uniformLocations.viewMatrix,!1,s),o.uniformMatrix4fv(a.vertex.uniformLocations.modelMatrix,!1,m),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,c.texture),o.uniform1i(a.fragment.uniformLocations.colorTextureSampler,0),o.drawElements(o.TRIANGLES,e.indices.length*e.indices[0].length,o.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{i=!1}})),[c]),o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const Y="varying highp vec2 uv;\nvarying highp vec3 diffuseLight;\n\nuniform highp float ambientFactor;\nuniform sampler2D colorTextureSampler;\n\nvoid main() {\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\n  highp vec4 ambientColor = vec4(surfaceColor);\n\n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight);\n  gl_FragColor.a = surfaceColor.a;\n}",V={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float"}},fragment:{attributeLocations:{},uniformLocations:{ambientFactor:"float",colorTextureSampler:"sampler2D"}}},H=h.fA(4,4,4,1),X=u.fA(.3,.3,.3),Z=f.vt(),Q=[[0,0],[0,1],[1,0],[0,1],[1,0],[1,1]];var J=(0,v.A)((()=>{const e={vertices:[[-1,-1,1],[-1,1,1],[1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[-1,-1,-1],[-1,1,-1],[-1,-1,1],[-1,1,-1],[-1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[1,-1,-1],[1,1,1],[1,-1,-1],[1,1,-1],[-1,1,1],[-1,1,-1],[1,1,1],[-1,1,-1],[1,1,1],[1,1,-1],[-1,-1,-1],[-1,-1,1],[1,-1,-1],[-1,-1,1],[1,-1,-1],[1,-1,1],[1,-1,-1],[1,1,-1],[-1,-1,-1],[1,1,-1],[-1,-1,-1],[-1,1,-1]],uvs:[].concat(Q,Q,Q,Q,Q,Q),normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23],[24,25,26,27,28,29],[30,31,32,33,34,35]],texture:m.A,ambientFactor:.1},{0:t,1:i}=(0,o.useState)(null),{0:r,1:n}=(0,o.useState)(null),{0:a,1:l}=(0,o.useState)(null),{0:c,1:s}=(0,o.useState)({vertices:null,uvs:null,normals:null,indices:null,texture:null}),h=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,Z);return i(e),()=>{i(null),e.destroy()}}}),[h]),(0,o.useEffect)((0,g.sT)(null!==t,(()=>{n(t.createShaderProgram("attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\nuniform vec3 lightColor;\nuniform float lightIntensity;\n\nvarying highp vec2 uv;\nvarying highp vec3 diffuseLight;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  uv = vertexUv;\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n}",Y))})),[t]),(0,o.useEffect)((0,g.sT)(null!==r,(()=>{l(t.getDataLocations(r,V))})),[r]),(0,o.useEffect)((0,g.sT)(null!==a,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[a]),(0,o.useEffect)((0,g.sT)(null!==c.vertices,(()=>{let i=!0;const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:l,viewMatrix:s,modelMatrix:h}=t;if(!i)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString()),m=f.vt(),g=u/30%2160*Math.PI/180;f.Qr(m,h,g),f.eL(m,m,g/2),f.Z8(m,m,g/3),o.bindBuffer(o.ARRAY_BUFFER,c.vertices),o.vertexAttribPointer(a.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexPosition),o.bindBuffer(o.ARRAY_BUFFER,c.uvs),o.vertexAttribPointer(a.vertex.attributeLocations.vertexUv,2,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexUv),o.bindBuffer(o.ARRAY_BUFFER,c.normals),o.vertexAttribPointer(a.vertex.attributeLocations.vertexNormal,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexNormal),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,c.indices),o.useProgram(r),o.uniformMatrix4fv(a.vertex.uniformLocations.projectionMatrix,!1,l),o.uniformMatrix4fv(a.vertex.uniformLocations.viewMatrix,!1,s),o.uniformMatrix4fv(a.vertex.uniformLocations.modelMatrix,!1,m),o.uniform4fv(a.vertex.uniformLocations.lightPosition_worldSpace,H),o.uniform3fv(a.vertex.uniformLocations.lightColor,X),o.uniform1f(a.vertex.uniformLocations.lightIntensity,50),o.uniform1f(a.fragment.uniformLocations.ambientFactor,e.ambientFactor),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,c.texture),o.uniform1i(a.fragment.uniformLocations.colorTextureSampler,0),o.drawElements(o.TRIANGLES,e.indices.length*e.indices[0].length,o.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{i=!1}})),[c]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nCube:\n    World Position: "+(0,g.NW)(H)+"\n    Lighting:\n        Ambient Factor: "+e.ambientFactor+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(H)+"\n    Color: "+(0,g.NW)(X,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))}));const K="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\nuniform vec3 lightColor;\nuniform float lightIntensity;\nuniform float specularLobeFactor;\n\nvarying highp vec2 uv;\nvarying highp vec3 diffuseLight;\nvarying highp vec3 specularLight;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  uv = vertexUv;\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 viewDirection_viewSpace = normalize(vertexPosition_viewSpace.xyz - vec3(0.0, 0.0, 0.0));\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, normal_viewSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\n  specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n}",$="varying highp vec2 uv;\nvarying highp vec3 diffuseLight;\nvarying highp vec3 specularLight;\n\nuniform highp float ambientFactor;\nuniform highp float specularReflectivity;\nuniform sampler2D colorTextureSampler;\n\nvoid main() {\n  highp vec4 surfaceColor = texture2D(colorTextureSampler, uv);\n  highp vec4 ambientColor = vec4(surfaceColor);\n  highp vec4 specularColor = vec4(1.0);\n  \n  gl_FragColor.rgb = (ambientColor.rgb * ambientFactor) + (surfaceColor.rgb * diffuseLight) + (specularColor.rgb * specularReflectivity * specularLight);\n  gl_FragColor.a = surfaceColor.a;\n}",ee={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{ambientFactor:"float",specularReflectivity:"float",colorTextureSampler:"sampler2D"}}},te=h.fA(4,4,4,1),ie=u.fA(.3,.3,.3),re=f.vt(),ne=[[0,0],[0,1],[1,0],[0,1],[1,0],[1,1]];var oe=(0,v.A)((()=>{const e={vertices:[[-1,-1,1],[-1,1,1],[1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[-1,-1,-1],[-1,1,-1],[-1,-1,1],[-1,1,-1],[-1,-1,1],[-1,1,1],[1,-1,1],[1,1,1],[1,-1,-1],[1,1,1],[1,-1,-1],[1,1,-1],[-1,1,1],[-1,1,-1],[1,1,1],[-1,1,-1],[1,1,1],[1,1,-1],[-1,-1,-1],[-1,-1,1],[1,-1,-1],[-1,-1,1],[1,-1,-1],[1,-1,1],[1,-1,-1],[1,1,-1],[-1,-1,-1],[1,1,-1],[-1,-1,-1],[-1,1,-1]],uvs:[].concat(ne,ne,ne,ne,ne,ne),normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[-1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,-1,0],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1],[0,0,-1]],indices:[[0,1,2,3,4,5],[6,7,8,9,10,11],[12,13,14,15,16,17],[18,19,20,21,22,23],[24,25,26,27,28,29],[30,31,32,33,34,35]],texture:m.A,ambientFactor:.1,specularReflectivity:.5,specularLobeFactor:5},{0:t,1:i}=(0,o.useState)(null),{0:r,1:n}=(0,o.useState)(null),{0:a,1:l}=(0,o.useState)(null),{0:c,1:s}=(0,o.useState)({vertices:null,uvs:null,normals:null,indices:null,texture:null}),h=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,re);return i(e),()=>{i(null),e.destroy()}}}),[h]),(0,o.useEffect)((0,g.sT)(null!==t,(()=>{n(t.createShaderProgram(K,$))})),[t]),(0,o.useEffect)((0,g.sT)(null!==r,(()=>{l(t.getDataLocations(r,ee))})),[r]),(0,o.useEffect)((0,g.sT)(null!==a,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture)})})),[a]),(0,o.useEffect)((0,g.sT)(null!==c.vertices,(()=>{let i=!0;const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:l,viewMatrix:s,modelMatrix:h}=t;if(!i)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString()),m=f.vt(),g=u/30%2160*Math.PI/180;f.Qr(m,h,g),f.eL(m,m,g/2),f.Z8(m,m,g/3),o.bindBuffer(o.ARRAY_BUFFER,c.vertices),o.vertexAttribPointer(a.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexPosition),o.bindBuffer(o.ARRAY_BUFFER,c.uvs),o.vertexAttribPointer(a.vertex.attributeLocations.vertexUv,2,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexUv),o.bindBuffer(o.ARRAY_BUFFER,c.normals),o.vertexAttribPointer(a.vertex.attributeLocations.vertexNormal,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(a.vertex.attributeLocations.vertexNormal),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,c.indices),o.useProgram(r),o.uniformMatrix4fv(a.vertex.uniformLocations.projectionMatrix,!1,l),o.uniformMatrix4fv(a.vertex.uniformLocations.viewMatrix,!1,s),o.uniformMatrix4fv(a.vertex.uniformLocations.modelMatrix,!1,m),o.uniform4fv(a.vertex.uniformLocations.lightPosition_worldSpace,te),o.uniform3fv(a.vertex.uniformLocations.lightColor,ie),o.uniform1f(a.vertex.uniformLocations.lightIntensity,50),o.uniform1f(a.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),o.uniform1f(a.fragment.uniformLocations.ambientFactor,e.ambientFactor),o.uniform1f(a.fragment.uniformLocations.specularReflectivity,e.specularReflectivity),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,c.texture),o.uniform1i(a.fragment.uniformLocations.colorTextureSampler,0),o.drawElements(o.TRIANGLES,e.indices.length*e.indices[0].length,o.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{i=!1}})),[c]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nCube:\n    World Position: "+(0,g.NW)(te)+"\n    Lighting:\n        Ambient Factor: "+e.ambientFactor+"\n        Specular Reflectivity: "+e.specularReflectivity+"\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(te)+"\n    Color: "+(0,g.NW)(ie,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))}));const ae={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{}}},le={vertex:{attributeLocations:{vertexPosition:"vec4",vertexNormal:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float"}},fragment:{attributeLocations:{},uniformLocations:{}}},ce=h.fA(.5,.2,3,1),se=u.fA(1,1,1),he=f.vt();var ue=(0,v.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]]},t={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],indices:[[0,1,2,3,4,5]]},{0:i,1:r}=(0,o.useState)(null),{0:n,1:a}=(0,o.useState)(null),{0:l,1:c}=(0,o.useState)(null),{0:s,1:h}=(0,o.useState)({vertices:null}),{0:u,1:m}=(0,o.useState)(null),{0:v,1:p}=(0,o.useState)(null),{0:x,1:w}=(0,o.useState)({vertices:null,normals:null,indices:null}),b=(0,o.useRef)();(0,o.useEffect)((()=>{if(null!==b.current){const e=new d.A(b.current,he);return r(e),()=>{r(null),e.destroy()}}}),[b]),(0,o.useEffect)((0,g.sT)(null!==i,(()=>{a(i.createShaderProgram(j,C))})),[i]),(0,o.useEffect)((0,g.sT)(null!==n,(()=>{c(i.getDataLocations(n,ae))})),[n]),(0,o.useEffect)((0,g.sT)(null!==l,(()=>{h({vertices:i.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[l]),(0,o.useEffect)((0,g.sT)(null!==s.vertices,(()=>{m(i.createShaderProgram("attribute vec4 vertexPosition;\nattribute vec3 vertexNormal;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform vec4 lightPosition_worldSpace;\nuniform vec3 lightColor;\nuniform float lightIntensity;\n\nvarying highp vec3 diffuseLight;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(vertexPosition_worldSpace, lightPosition_worldSpace);\n  highp vec3 normal_viewSpace = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - vertexPosition_viewSpace).xyz);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n}","varying highp vec3 diffuseLight;\n\nvoid main() {\n  highp vec3 surfaceColor = vec3(1.0);\n  \n  gl_FragColor.rgb = surfaceColor.rgb * diffuseLight;\n  gl_FragColor.a = 1.0;\n}"))})),[s]),(0,o.useEffect)((0,g.sT)(null!==u,(()=>{p(i.getDataLocations(u,le))})),[u]),(0,o.useEffect)((0,g.sT)(null!==v,(()=>{w({vertices:i.createStaticDrawArrayBuffer(t.vertices.flat(),x.vertices),normals:i.createStaticDrawArrayBuffer(t.normals.flat(),x.normals),indices:i.createElementArrayBuffer(t.indices.flat(),x.indices)})})),[v]),(0,o.useEffect)((0,g.sT)(null!==x.vertices,(()=>{let r=!0;const o=()=>{i.renderScene((i=>{let{gl:a,projectionMatrix:c,viewMatrix:h,modelMatrix:m}=i;if(r){{const e=f.vt(),i=30*Math.PI/180;f.Tl(e,m,[0,0,2]),f.Z8(e,e,i),a.bindBuffer(a.ARRAY_BUFFER,x.vertices),a.vertexAttribPointer(v.vertex.attributeLocations.vertexPosition,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(v.vertex.attributeLocations.vertexPosition),a.bindBuffer(a.ARRAY_BUFFER,x.normals),a.vertexAttribPointer(v.vertex.attributeLocations.vertexNormal,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(v.vertex.attributeLocations.vertexNormal),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,x.indices),a.useProgram(u),a.uniformMatrix4fv(v.vertex.uniformLocations.projectionMatrix,!1,c),a.uniformMatrix4fv(v.vertex.uniformLocations.viewMatrix,!1,h),a.uniformMatrix4fv(v.vertex.uniformLocations.modelMatrix,!1,e),a.uniform4fv(v.vertex.uniformLocations.lightPosition_worldSpace,ce),a.uniform3fv(v.vertex.uniformLocations.lightColor,se),a.uniform1f(v.vertex.uniformLocations.lightIntensity,2.25),a.drawElements(a.TRIANGLES,t.indices.length*t.indices[0].length,a.UNSIGNED_SHORT,0)}{const t=f.vt();f.Tl(t,t,ce),f.hs(t,t,[.03,.03,.03]),a.bindBuffer(a.ARRAY_BUFFER,s.vertices),a.vertexAttribPointer(l.vertex.attributeLocations.vertexPosition,3,a.FLOAT,!1,0,0),a.enableVertexAttribArray(l.vertex.attributeLocations.vertexPosition),a.useProgram(n),a.uniformMatrix4fv(l.vertex.uniformLocations.projectionMatrix,!1,c),a.uniformMatrix4fv(l.vertex.uniformLocations.viewMatrix,!1,h),a.uniformMatrix4fv(l.vertex.uniformLocations.modelMatrix,!1,t),a.drawArrays(a.TRIANGLES,0,e.vertices.length)}requestAnimationFrame(o)}}))};return requestAnimationFrame(o),()=>{r=!1}})),[x]);return o.createElement("div",{className:"util text-center",style:{padding:"1rem"}},o.createElement("canvas",{width:"640",height:"480",ref:b},"Cannot run WebGL examples (not supported)"),o.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,g.NW)([0,0,0])+"\n").trim()),o.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,g.NW)(ce)+"\n    Color: "+(0,g.NW)(se,{x:"r",y:"g",z:"b"})+"\n    Intensity: 2.25\n").trim()))})),fe=i(7570),me=i(2007),ge=i(2269);var ve=e=>{let{location:{pathname:t}}=e;return o.createElement(fe.A,null,o.createElement(ge.A,{pathname:t,title:"Shader Intermediates - Lighting",description:"A look into how lighting can be simulated on objects through shaders.",keywords:["lighting","shader","intermediates","diffuse","specular","ambient"]}),o.createElement(a.A,null,o.createElement("h1",null,"Shader Intermediates - Lighting"),o.createElement("p",null,"While adding textures to color your objects helps to add more detail, simulating the lighting of the environment on the object adds further detail and makes it appear in place with the rest of the world."),o.createElement("p",null,"There are three components of light reflection that come into effect when simulating light falling on an object:"),o.createElement("ul",null,o.createElement("li",null,"The diffuse component"),o.createElement("li",null,"The ambient component"),o.createElement("li",null,"The specular component")),o.createElement("p",null,"Let's look at each component, and how they effect the look of the object when simulating lighting. We'll only work with a single point light, which has light rays going from a single point in every direction, but the same principles apply to other kinds of lights, as well as multiple sources of light."),o.createElement("p",null,"But before that, let's look at how the cube appears with no lighting for reference."),o.createElement(O,null),o.createElement(s.A,{type:"h2"},"The Diffuse Component"),o.createElement("p",null,"The first component is the diffuse component and is the primary reflection component that lights up objects."),o.createElement("p",null,"When a ray of light hits an object, due to the roughness and texture of the object, this light spreads out and reflects in multiple directions."),o.createElement("p",null,"However, not all of the light is reflected. Certain colors that are part of the light are absorbed by the object, with the rest being reflected. The colors that are reflected by the object are the ones that we see, which means these are the colors which we see as being the color of that object."),o.createElement("div",{className:"util text-center"},o.createElement("img",{src:"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/diffuseWhite1.png",alt:"Diffuse Lighting Main Example"}),o.createElement("br",null),o.createElement("a",{href:"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/",target:"_blank",rel:"noopener noreferrer"},"Source")),o.createElement("p",null,"For example, when white light falls on an apple, we see that the apple is red. This is because white light is made up of multiple colors in a spectrum mixed together."),o.createElement("p",null,"The colors that are not red are absorbed by the surface of the apple, and the red components of light that remain are reflected. This results in us seeing the apple as being red."),o.createElement("p",null,"The light that shows us this color is what we consider as the diffuse component of the light reflection of the apple."),o.createElement("p",null,"The diffuse component is dependent on four factors:"),o.createElement("ul",null,o.createElement("li",null,o.createElement("strong",null,"The color of the light")," - If the light is red and the object is blue, since these two colors are completely separate in the color spectrum, all the light is absorbed by the object and nothing is reflected, making the object appear black (or having no color)."),o.createElement("li",null,o.createElement("strong",null,"The intensity of the light")," - The brighter the source of light is, more light will hit an object, making it appear brighter (unless the example in the first point occurs)."),o.createElement("li",null,o.createElement("strong",null,"The distance of the light source from the object")," - The further away a source of light is from an object, the less intense the light will be when it hits the object. This is due to the",o.createElement("a",{href:"https://en.wikipedia.org/wiki/Inverse-square_law",target:"_blank",rel:"noopener noreferrer"},"inverse-square law"),", which states that the intensity of the light is inversely proportional to the square of the distance between the light source and the object."),o.createElement("li",null,o.createElement("strong",null,"The angle at which the light hits the object")," - This we'll explain below.")),o.createElement("p",null,"If the light hits the surface of the object at an angle, the light gets spread out over a wide surface."),o.createElement("p",null,"However, if the light hits the surface at an angle that's closer to perpendicular to the surface of the obejct, then a lot more light gets concentrated across a smaller surface, making the surface appear brighter."),o.createElement("div",{className:"util text-center"},o.createElement("img",{src:"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/diffuseAngle.png",alt:"Diffuse Lighting Angle Example"}),o.createElement("br",null),o.createElement("a",{href:"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/",target:"_blank",rel:"noopener noreferrer"},"Source")),o.createElement("p",null,"This can be done through an experiment as well. Grab your phone and turn on the flashlight (or else grab a torch) and shine it perpendicularly away by a certain distance on a rough surface and note down the brightness."),o.createElement("p",null,"Next, shine it from approximately the same distance at an acute angle to the surface, with the light source being the same distance away as in the first test."),o.createElement("p",null,"The brightness of the surface should decrease when the light is shining at an angle compared to when it was perpendicularly, and is why the angle of the light compared to the surface of the object matters."),o.createElement("p",null,"These four factors combined together affect how the diffuse reflection will finally appear."),o.createElement("p",null,"Since the diffuse component is what shows the color of an object, the color map used to color an object is also called a diffuse map, since it provides the color that the diffuse reflection is supposed to show."),o.createElement(s.A,{type:"h2"},"Example - Cube with diffused reflection"),o.createElement(L,null),o.createElement(s.A,{type:"h3"},"How it works"),o.createElement("p",null,"We now know that diffuse light is the light that shows the color of the surface of an object, and it's brighter when the incident light is closer to being perpendicular to the surface, its color falls within the color spectrum of the object, has a high intensity, and is close to the object."),o.createElement("p",null,"The first thing required is the normal of the surface being lighted. A normal can be considered as a direction that is perpendicular to a surface. So if there was a surface that was across the XZ-plane, then it's normal would be any direction along the Y-axis."),o.createElement("p",null,"Since we can only tell the GPU information about each vertex, the normal of the plane is set as the normal of each vertex forming that plane."),o.createElement("p",null,"This way when the entire plane is being drawn, since all vertices have the same normal, the entire plane will also be interpolated to have that normal."),o.createElement("p",null,"The second thing required is the direction of the light. Since the position of the light and objects in the world are known, and the light is a point light, the direction would be from the light source to the object itself."),o.createElement("p",null,"In order to determine the brightness of a point on the surface of the object, the angle between the normal of the surface and the direction of light must be compared."),o.createElement(s.A,{type:"h4"},"The mathematics"),o.createElement("p",null,"If the direction of the light is perpendicular to the surface, then the angle between the direction of light and the normal of the surface will equal 0 degrees, resulting in the brightness at that point should be brightest."),o.createElement("p",null,"Conversely, if the direction of the light is parallel to the surface, then the angle between the direction of light and the normal of the surface will be 90 degrees, which results in no light hitting the surface and its brighness being zero."),o.createElement("p",null,"Consider brightness as a factor from 0 to 1, where at 1, the brightness is at its highest possible value, and at 0, it is at it's lowest possible value."),o.createElement("p",null,"So a mathematical operation is required which, when given an angle of 0 degrees provides a result of 1, and when given an angle of 0 degrees provides a result of 0."),o.createElement("p",null,"The best operation for this is the trignometric function"," ",o.createElement(l.A,{text:"cos(theta)"}),", where ",o.createElement(l.A,{text:"theta"})," is the angle between the two directions."),o.createElement("p",null,"Do note that if the angle between the normal and the light is greater than 90 and upto 180, the result of this operation goes upto -1. So the result of the operation needs to be clamped to 0 to prevent the diffuse factor from being negative, since you can't have a negative amount of light."),o.createElement("p",null,"In the GPU, we'll be representing the directions of the surface normal and light direction in the form of vectors. So a mathematical operation is required between two vectors, which can provide us with the"," ",o.createElement(l.A,{text:"cos(theta)"})," result of the angle between them. This operation is the ",o.createElement("code",null,"dot")," product."),o.createElement("p",null,"Let us take two vectors ",o.createElement(l.A,{text:"vec v_1"})," and"," ",o.createElement(l.A,{text:"vec v_2"}),". The ",o.createElement("code",null,"dot")," product of these two vectors would be"," ",o.createElement(l.A,{text:"vec v_1 cdot vec v_2 = norm(vec v_1) norm(vec v_2) cos(theta)"}),", where ",o.createElement(l.A,{text:"norm(vec v_1)"})," and"," ",o.createElement(l.A,{text:"norm(vec v_2)"})," represent the magnitute of"," ",o.createElement(l.A,{text:"vec v_1"})," and ",o.createElement(l.A,{text:"vec v_2"})," ","respectively."),o.createElement("p",null,"The magnitude of a vector can be considered as a certain quantity that is required to move a point from one place to another. The magnitude combined with the direction of the vector forms the vector itself."),o.createElement("p",null,"If we move around parts of this equation, we can represent this as equation as"," ",o.createElement(l.A,{text:"(vec v_1) / norm(vec v_1) cdot (vec v_2) / norm(vec v_2) = cos(theta)"}),", where ",o.createElement(l.A,{text:"(vec v) / norm(vec v)"})," is considered the unit vector of the vector (represented as ",o.createElement(l.A,{text:"hat(v)"}),"), because the magnitude of the vector is removed from the vector itself, leaving it as a single unit of itself that purely represents its direction."),o.createElement("p",null,"This results in the final equation being"," ",o.createElement(l.A,{text:"hat(v_1) cdot hat(v_2) = cos(theta)"}),", where"," ",o.createElement(l.A,{text:"hat(v_1)"})," and ",o.createElement(l.A,{text:"hat(v_2)"})," ","represent the unit vectors of the vectors ",o.createElement(l.A,{text:"vec v_1"})," ","and ",o.createElement(l.A,{text:"vec v_2"}),". So we can determine the"," ",o.createElement(l.A,{text:"cos(theta)"})," of two vectors by finding the dot product of their unit vectors. This can be done easily, because there are built-in functions that let us calculate the unit vector of a given vector."),o.createElement("p",null,"Including the other factors that affect the diffuse reflection, the final equation is:"),o.createElement("p",{className:"util text-center"},o.createElement(l.A,{text:'"diffuseLight" = ((hat "lightDirection" cdot hat "surfaceNormal") times "lightColor" times "lightIntensity") / "distance" ^ 2'})),o.createElement("p",null,"The factors are combined through multiplication and division and not addition and subtraction, because addition would mean that these factors pile up on each other. However, these factors mix with each other to determine the final factor of the diffuse reflection, which is done through multiplcation and division."),o.createElement("p",null,"Let us look at the code to see how this equation is implemented."),o.createElement(c.A,{code:p.trim(),type:"Vertex"}),o.createElement(c.A,{code:x.trim(),type:"Fragment"}),o.createElement("p",null,"In the vertex shader, the lines 17-21 are the standard operations we've seen in previous chapters, so they can be mostly ignored."),o.createElement("p",null,"The important things to note from them is that the results of the position of the vertex in the world-space and view-space (see the"," ",o.createElement(r.Link,{to:"/basics/vertex-shader/"},"Vertex Shader Basics")," if you need to recollect) are saved in certain variables which will be required later."),o.createElement("p",null,"After those lines, we first calculate the combined product of the light color and intensity, which is a simple multiplication. This result is stored in a ",o.createElement("code",null,"vec3")," named ",o.createElement("code",null,"lightColorIntensity"),", since it stores the intensity of each color (R, G, and B) of the light."),o.createElement("p",null,"The distance between the light source and object is very simple. Since the positions of both are already stored in vectors, the distance between them can be calculated through a built-in function available in shading languages. In GLSL, this function is ",o.createElement("code",null,"distance"),"."),o.createElement("p",null,"Alternatively, the two vectors can be subtracted into another vector, and the magnitude of that resultant vector would give us the distance between the two points. The magnitude of a vector can be calculated in GLSL using the built-in function ",o.createElement("code",null,"length"),"."),o.createElement("p",null,"The direction of the normal of the vertex is required to be known respective to the camera, which is why the calculation of the normal in view-space (multiplying the model and view matrices) is performed and stored in ",o.createElement("code",null,"normal_viweSpace"),". This is similarly done for the direction of the light and stored in the"," ",o.createElement("code",null,"lightDirection_viweSpace"),"."),o.createElement("p",null,"A point of note is that the direction of the light is stored as the direction from the object to the light source. This allows our calculations to be accurate, since if the light is falling perpendicular to the surface, then the direction of the light is the same as the normal of the vertex. This results in the ",o.createElement("code",null,"dot")," product of the two directions equaling ",o.createElement("code",null,"1"),", which is what we require."),o.createElement("p",null,"If the direction of the light was stored as the direction from the light source to the object, then the resulting ",o.createElement("code",null,"dot")," product of the direction of the light and the vertex normal would be ",o.createElement("code",null,"-1"),", because the two vectors are pointing in the opposite direction."),o.createElement("p",null,"The vectors calculate for the vertex normal and light direction in view-space are converted into a unit vector, which is used to calculate the diffuse factor by the angle of the light and the normal of the surface. In GLSL, the built-in function for this calculation is"," ",o.createElement("code",null,"normalize"),"."),o.createElement("p",null,"The reason for normalizing vectors is so that we remove the influence of magnitudes of vectors from calculations. A normalized vector only provides information regarding its direction, but not the magnitude of the direction. Since certain calculations we perform only require the directions of vectors, those vectors are normalized."),o.createElement("p",null,"The diffuse strength (strength of the diffuse reflection from the angle of the light and the surface) is calculated by finding the dot product of ",o.createElement("code",null,"normal_viewSpace")," and"," ",o.createElement("code",null,"lightDirection_viewSpace")," (done through the built-in function ",o.createElement("code",null,"dot")," in GLSL). This is clamped between 0 and 1 to prevent a negative diffuse strength."),o.createElement("p",null,"The final diffuse reflection factor of the object is calculated by multiplying the diffuse strength calculated in the previous step with the product of the light color and intensity."),o.createElement("p",null,"This result is then divided by the square of the distance between the light and the object, which is required due to the inverse-square law."),o.createElement("p",null,"This final diffuse factor is then passed to the fragment shader, allowing the value to be interpolated per fragment. The diffuse factor is multiplied with the surface color of the fragment to determine the final color of that fragment."),o.createElement("p",null,"Do note that the alpha value of the fragment color is not multiplied, since the transparency of an object won't change based upon the light falling on it."),o.createElement(s.A,{type:"h2"},"The Ambient Component"),o.createElement("p",null,"The ambient component is the second component of lighting reflection, and is generally a much more subtle form of reflection. Ambient reflection is not from direct interaction with the light source, but interaction with the rest of the environment."),o.createElement("p",null,"The rays of light from the light source hit other objects as well, and the light reflected from these other objects in the environment bounce around and eventually hit the primary object as well."),o.createElement("p",null,"This light that comes indirectly through light bouncing of other objects form the ambient component of lighting of an object, causing the object to always have a minimum amount of brightness, either over the entire object or over a certain area."),o.createElement("p",null,"Since this the minimum brightness of an object caused due to the environment, the diffuse lighting component adds on top of the ambient component."),o.createElement(s.A,{type:"h2"},"Example - Cube with ambient and diffuse reflections"),o.createElement(J,null),o.createElement(c.A,{code:Y.trim(),type:"Fragment"}),o.createElement(s.A,{type:"h3"},"How it works"),o.createElement("p",null,"Since the ambient component of lighting is just a minimum brightness of the object due to the environment, the ambient factor doesn't need any calculation, so the vertex shader requires no modification."),o.createElement("p",null,"The ambient color is the color that the object produces when hit with ambient light. This is the same as the diffuse color of an object in most cases, which is why we're setting the ambient color the same as the diffuse color. However, you could set this to a different color to create interesting effects."),o.createElement("p",null,"The ambient factor of the environment is directly passed to the fragment shader, which is then multiplied with the ambient color of the fragment to introduce the minimum brightness."),o.createElement("p",null,"This is then added along with the diffusion component of lighting, since the ambient lighting is the base brightness of the object, and the diffusion component is an addition on top of it to further increase the brightness of surfaces being hit by the light."),o.createElement(s.A,{type:"h2"},"The Specular Component"),o.createElement("p",null,'The specular component is the final component of lighting reflection and is what gives objects a "shine".'),o.createElement("p",null,"Specular reflection is similar to reflection by a mirror. When a ray of light hits the surface, depending on the smoothness of the surface, this light may be completely reflected, like as if the surface were a mirror."),o.createElement("div",{className:"util text-center"},o.createElement("img",{src:"https://www.opengl-tutorial.org/assets/images/tuto-8-basic-shading/specular.png",alt:"Specular Lighting Main Example"}),o.createElement("br",null),o.createElement("a",{href:"https://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/",target:"_blank",rel:"noopener noreferrer"},"Source")),o.createElement("p",null,"If the reflected light is seen by the viewer, it would look like all, or a part of the light was reflected by the object, giving the impression the object has a shiny surface. This is specular reflection."),o.createElement("p",null,"Just like how with diffuse reflection the brightness is dependent on the angle of the light and the surface, with specular reflection the brightness is dependent on the direction of the reflected light and the direction of the camera."),o.createElement("p",null,"Other than this factor, specular reflection is also dependent on all the other factors that diffuse reflection is."),o.createElement(s.A,{type:"h2"},"Example - Cube with all lighting components"),o.createElement(oe,null),o.createElement(s.A,{type:"h3"},"How it works"),o.createElement("p",null,"We can reuse the principles we've learnt from diffuse reflection. We know that a factor of diffuse lighting is the angle of the reflected light with the direction of the camera."),o.createElement(s.A,{type:"h4"},"The mathematics"),o.createElement("p",null,"If the direction of the camera is known, as well as the direction of the reflected light, by applying the ",o.createElement("code",null,"dot")," operation we've learnt, we can calculate the the ",o.createElement(l.A,{text:"cos(theta)"})," angle between them, which gives us the strength of the specular reflection."),o.createElement("p",null,"The same ",o.createElement(l.A,{text:"cos(theta)"})," operation is required here since the same principle applies - the closer the light reflection and the camera are in the same direction, the brighter the specular reflection will appear to be."),o.createElement("p",null,"Another point to note is when calculating the ",o.createElement("code",null,"dot")," product of these two vectors, they must be in the relatively same direction."),o.createElement("p",null,"What is meant by this is, if the direction of the camera is taken as the direction from the camera to the object, then the direction of the reflected light has to also be taken from the point the light is travelling towards to the object."),o.createElement("p",null,"If this condition is not satisfied, the two directions will appear to be completely opposite to each other, resulting in their dot product being in the opposite sign than they should be (negative when it should be positive and vice-versa)."),o.createElement("p",null,"Another alternate solution to this issue is to multiply the result of the dot product with -1 to get the correct result. Either solution can be applied."),o.createElement("p",null,"According to the law of reflection, the angle at which a ray of light hits a surface (angle of incidence) is equal to the angle at which the light reflects off the surface (angle of reflection)."),o.createElement("p",null,"Since the normal of a surface is always perpendicular to the surface, this angle of incidence and angle of reflection are against the normal of the surface."),o.createElement("p",null,"An image showing this law is below:"),o.createElement("div",{className:"util text-center"},o.createElement("img",{src:"https://www.asu.edu/courses/phs208/patternsbb/PiN/rdg/reflection/opticsRDG1.gif",alt:"Law Of Reflection"}),o.createElement("br",null),o.createElement("a",{href:"https://www.asu.edu/courses/phs208/patternsbb/PiN/rdg/reflection/reflection.shtml",target:"_blank",rel:"noopener noreferrer"},"Source")),o.createElement("p",null,"We've already know the direction of the light to the object when calculating diffuse reflection. Using the normal of the surface, the direction of the reflected light can be calculated."),o.createElement("p",null,"Once the dot product of the direction of the reflected light and direction of the camera is calculated, it is combined with other factors resulting in the final equation:"),o.createElement("p",{className:"util text-center"},o.createElement(l.A,{text:'"specularLight" = ((hat "lightDirection" cdot hat "cameraDirection")^"Lobe Density" times "lightColor" times "lightIntensity") / "distance" ^ 2'})),o.createElement("p",null,"The lobe density defines how concentrated the specular reflection is over a surface. A lower value means that the light is reflecting over a larger surface area, and a higher value means that the light is reflecting over a smaller surface area."),o.createElement("p",null,"Let us look at the code to see how this equation is implemented."),o.createElement(c.A,{code:K.trim(),type:"Vertex"}),o.createElement(c.A,{code:$.trim(),type:"Fragment"}),o.createElement("p",null,"In the vertex shader, the new code is from line 33. First the direction of the camera is calculated. Since the object is in view, the direction of the camera would be everywhere in view of the camera."),o.createElement("p",null,"A direction vector is calculated by subtracting the vector that represents the source point from the vector that represents the point the direction is pointing towards."),o.createElement("p",null,"In the case for calculating the direction of the camera, it is calculated by subtracting the position of the camera from the direction of the object."),o.createElement("p",null,"In view-space, the camera is always at the center of the world, since in view-space, everything is positioned relative to the camera. This is why the position of the camera is taken as ",o.createElement("code",null,"vec3(0.0, 0.0, 0.0)"),"."),o.createElement("p",null,"This direction is normalized so that the resultant vector calculated is the unit vector that represents the just direction of the camera, with no magnitude."),o.createElement("p",null,"The light direction in view-space is known, along with the direction of the normal of the surface. Using a built-in function, the reflection of the direction of light w.r.t to the normal can be calculated. In GLSL, this function is ",o.createElement("code",null,"reflect"),"."),o.createElement("p",null,"The result of the reflection calculation is not normalized since the direction of the incident light is already a unit vector, so it's resultant reflection will also be a unit vector."),o.createElement("p",null,"A point of note is that with ",o.createElement("code",null,"reflect")," in GLSL, the light direction still points away from the object, not towards it."),o.createElement("p",null,"Imagine the normal of the surface as a mirror. When calculating the reflection of the light direction relative to the normal, the reflection would appear on the other side of the normal, but the direction won't change."),o.createElement("p",null,"This is shown in the illustration below:"),o.createElement("div",{className:"image util text-center"},o.createElement(n.S,{src:"../../images/intermediates/glsl-reflect.png",alt:"GLSL Reflect Function Result Illustration",style:{maxWidth:"65%"},__imageData:i(2028)})),o.createElement("p",null,"Since the direction calculated for the camera is from the object to the camera, the calculation of the ",o.createElement("code",null,"dot")," product of the camera direction and the light direction will still be accurate, since they are both pointing away from the object."),o.createElement("p",null,"This calculation is done in the next step to determine the strength of the specular reflection. Similar to the same calculation for the diffusion strength, this result is also clamped to between 0 and 1 to prevent a negative strength result."),o.createElement("p",null,"The final specular reflection factor is then calculated in the same way as the diffusion factor - multiply the specular strength with the light color and intensity, and divide it by the square of the distance of the light source from the object."),o.createElement("p",null,"Since the specular factor is also dependent on the specular lobe density of the light, it is increased to the power of the lobe density. So the more dense the light specular lobe is, the specular factor of the light on the surface increases exponentially."),o.createElement("p",null,"The result is then passed to the fragment shader, allowing it to be interpolated per fragment."),o.createElement("p",null,"The specular reflectivity is the value that determines how reflective or smooth the surface of the object is."),o.createElement("p",null,"The surfaces of objects aren't always perfectly smooth, but have very small bumps in them. When light falls on an object, only a portion of the light would be reflected by these bumps perfectly towards the camera. The rest of the light would be reflected in other directions and not contribute to the specular lighting component."),o.createElement("p",null,"If we set the specular reflectivity of the surface to 1.0, it means that all of the light is reflected by the surface of the object towards the camera, making the surface of the object perfectly smooth."),o.createElement("p",null,"However, if we set the specular reflectivity to 0.5, only 50% of the light is reflected towards the camera by the surface of the object, with the rest being reflected in other directions."),o.createElement("p",null,"In our case, we've set the specular reflectivity to 0.5, meaning that the cube only reflects 50% of the light falling on it."),o.createElement("p",null,"The color of specular lighting is also dependent on the specular color that the surface emits during specular reflection, as the surface can absorb part of the light, and reflect the rest of it, resulting in it having a different color."),o.createElement("p",null,"The specular color value is generally set to the color of the object, but we set the specular color value to"," ",o.createElement(l.A,{text:"(1.0, 1.0, 1.0)"})," as we want all the light falling on the surface to be reflected without any parts being absorbed."),o.createElement("p",null,"The specular factor is multiplied against the specular reflectivity and the specular color of the fragment, and then added to the other lighting reflection components to set the final color value of the fragment."),o.createElement(s.A,{type:"h2"},"Per-vertex vs Per-fragment lighting"),o.createElement("p",null,'All lighting factors we calculated was done on the vertex shader, which is then passed to the fragment shader, allowing the GPU to interpolate the factor for each fragment. This is doing lighting calculations "per-vertex".'),o.createElement("p",null,"The reason that this is done on the vertex shader and not the fragment shader is to reduce the number of calculations, similar to why the MVP matrix is passed directly instead of the multiplication being done on the GPU."),o.createElement("p",null,"There will always be considerably more fragments that a fragment shader would have to process than vertices that a vertex shader would have to process."),o.createElement("p",null,"This means that any calculations done on a fragment shader will be done much more in comparison to a calculation done on the vertex shader."),o.createElement("p",null,"To save on computation time, if there is a calculation on the fragment shader can be performed on the vertex shader and then interpolated for each fragment, it is recommended to perform that calculation on the vertex shader."),o.createElement("p",null,"This optimization reduces the number of overall computations performed and relies on the GPU interpolating values correctly."),o.createElement("p",null,"However, this may not always produce accurate results. Since the GPU has to interpolate the lighting values of the fragments inside the polygon based on the values returned for each vertex, it is possible for inaccuracies to be present."),o.createElement("p",null,"Let's illustrate with an example to show how per-vertex lighting can produce incorrect results compared to per-fragment lighting."),o.createElement(W,null),o.createElement("p",null,"Here we have a light source (represented as the red triangle) present near the center of a wall, shining towards it. The light is focused towards the center of the wall, making the inside of the wall brighter than the corners and edges."),o.createElement("p",null,'This is rendered by performing the lighting calculations on the fragment instead of on the vertex, meaning that the light is calculated on a "per-fragment" basis.'),o.createElement("p",null,"Calculating the lighting on the fragment shader results in a much more accurate result since the light values of the fragments inside the polygon aren't interpolated from the vertex."),o.createElement("p",null,"Only the locations of the fragments, and their normals are interpolated from there, which has no issues since interpolating the position of a fragment based on the position of its vertices is simple for GPUs to do."),o.createElement("p",null,"Now lets look at how the lighting looks if we perform the lighting calculation for each vertex instead and let the GPU interpolate those lighting values for the fragments inside the polygons."),o.createElement(ue,null),o.createElement("p",null,"The results when performing lighting calculations per-vertex are much more inaccurate compared to if the calculations are performed per-fragment."),o.createElement("p",null,"The reason for this is simple: the amount of light falling on the corners of the wall is lower than the amount of light falling at the center of the wall."),o.createElement("p",null,"This means that when calculating the lighting values at the vertices, since the amount of light is lower due to the further distance from the light source, the results will be low."),o.createElement("p",null,"Now the GPU only has information on the lighting values for each vertex. It has no information regarding the light source or how these values are calculated."),o.createElement("p",null,"As a result, when it needs to interpolate the lighting values at the center of the wall, it can only assume that the amount of light falling on the center of the screen is somewhere in between the amount of light falling on each vertex."),o.createElement("p",null,"The resolution (amount of detail) in per-vertex lighting is dependent on the number of vertices being drawn. The more vertices being processed, the more data the GPU has available to interpolate the values for the rest of the fragments."),o.createElement("p",null,"However, the resolution for per-fragment lighting is equal to the number of fragments being drawn. Since we perform the lighting calculation for each fragment, we know that the final lighting calculation will be accurate for that fragment."),o.createElement("p",null,"The only thing really required for per-fragment lighting is interpolating the position of a fragment in a polygon. This can always be easily interpolated by the GPU since the position of a fragment can always be interpolated using the positions of the vertices and where the fragment is present relative to those vertices."),o.createElement("p",null,"Now let's look at our cube example, but with per-fragment lighting calculations."),o.createElement(N,null),o.createElement(c.A,{code:A.trim(),type:"Vertex"}),o.createElement(c.A,{code:T.trim(),type:"Fragment"}),o.createElement("p",null,"You can see that the lighting in this example is different compared to the previous cube example, and shows how per-vertex lighting can produce incorrect results if not used correctly."),o.createElement("p",null,"In our code, we've moved all lighting calculations onto the fragment shader. The vertex shader only provides the fragment shader with values that the GPU should always be able to correctly interpolate for each fragment."),o.createElement("p",null,"The fragment shader can then calculate the final lighting values for each fragment using the interpolated results."),o.createElement("p",null,"The values being passed to the fragment shader from the vertex shader are:"),o.createElement("ul",null,o.createElement("li",null,o.createElement("code",null,"vertexPosition_viewSpace"),o.createElement("div",{style:{paddingLeft:"2.5rem"}},"The position of the vertex in view-space. This is interpolated into the position of the fragment in view-space."),o.createElement("div",{style:{paddingLeft:"2.5rem"}},"Since the vertex position describes where a vertex is located, and the position of each vertex determine where a polygon is located, the position of a fragment can be interpolated through the position of each vertex of the polygon it is present in.")),o.createElement("li",null,o.createElement("code",null,"vertexNormal_viewSpace"),o.createElement("div",{style:{paddingLeft:"2.5rem"}},"The position of the vertex in world-space. This is interpolated into the normal of the fragment in view-space."),o.createElement("div",{style:{paddingLeft:"2.5rem"}},"Since the vertex normal describes which direction a vertex is facing, and the normals of each vertex determine which direction a polygon faces, the normal of a fragment can be interpolated through the normals of each vertex of the polygon it is present in."))),o.createElement("p",null,"In future examples with lighting, we'll be performing the lighting calculations per-fragment instead of per-vertex for more accuracy."),o.createElement(s.A,{type:"h2"},"Additional Notes"),o.createElement("p",null,'This process can also be called shading, since we are "shading" an object based on how light falls on it. Certain topics taught later also fall under the process of shading since the contribute to the way an object is "shaded".'),o.createElement("p",null,"A point of note is that for specular lighting we provided a value to control how much of the light is reflected towards the camera (the specular reflectivity)."),o.createElement("p",null,"For diffuse lighting, the roughness of the surface should also be considered when calculating how much of the light is diffused by the object, since a rougher surface would diffuse more light than a smooth one."),o.createElement("p",null,'However, the roughness of the surface can be multiplied against the color of the surface and stored as part of the color map itself, resulting in a map called a "diffuse map".'),o.createElement("p",null,"In later chapters, we'll be using a diffuse map instead of a simple color map to provide diffuse color information."),o.createElement(s.A,{type:"h2"},"Summary"),o.createElement("ul",null,o.createElement("li",null,"Lighting helps to make an object seem more in place with the world"),o.createElement("li",null,"There are three reflection components when lighting an object:",o.createElement("ul",null,o.createElement("li",null,o.createElement("strong",null,"Diffuse Component")," - The component that shows us the color and look of the object. Brightness depends on at what angle the light hits the surface."),o.createElement("li",null,o.createElement("strong",null,"Ambient Component")," - The component that is resultant from the light reflected by the rest of the environment onto the object. Results in the object always having a minimum amount of brightness."),o.createElement("li",null,o.createElement("strong",null,"Specular Component")," - The component that is resultant from the light reflected by the object towards the camera. Results in the object looking like it has a reflective surface."))),o.createElement("li",null,"When the main three lighting components are combined, they simulate realistic lighting of an object in a basic form."))),o.createElement(me.A,{previous:"/intermediates/color-mapping/",next:"/intermediates/normal-mapping/"}))}},6018:function(e,t,i){t.A=i.p+"static/texture-d46d879879755d42e588c10e2b6c3335.png"},2028:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/a8db33c054e996a9e426a5877167ce97/8b59e/glsl-reflect.png","srcSet":"/static/a8db33c054e996a9e426a5877167ce97/3b71a/glsl-reflect.png 140w,\\n/static/a8db33c054e996a9e426a5877167ce97/a0e40/glsl-reflect.png 279w,\\n/static/a8db33c054e996a9e426a5877167ce97/8b59e/glsl-reflect.png 558w","sizes":"(min-width: 558px) 558px, 100vw"},"sources":[{"srcSet":"/static/a8db33c054e996a9e426a5877167ce97/dc2ed/glsl-reflect.webp 140w,\\n/static/a8db33c054e996a9e426a5877167ce97/fb02b/glsl-reflect.webp 279w,\\n/static/a8db33c054e996a9e426a5877167ce97/7cb21/glsl-reflect.webp 558w","type":"image/webp","sizes":"(min-width: 558px) 558px, 100vw"}]},"width":558,"height":339}')}}]);
//# sourceMappingURL=component---src-pages-intermediates-lighting-js-b74abbde1c242fc4d958.js.map