{"version":3,"file":"component---src-pages-basics-render-pipeline-js-3d0dd2b65ec85a2676fc.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/heading.js","webpack://shader-tutorial/./src/images/link.svg","webpack://shader-tutorial/./src/components/page-change.js","webpack://shader-tutorial/./src/pages/basics/render-pipeline.js"],"sourcesContent":["import PropTypes from \"prop-types\";\nimport React from \"react\";\n\nimport linkImage from \"../images/link.svg\";\n\nconst slugify = (text) => {\n  return text\n    .toString()\n    .trim()\n    .toLowerCase()\n    .replace(/\\s+/g, \"-\")\n    .replace(/[^\\w\\-]+/g, \"\")\n    .replace(/\\-\\-+/g, \"-\")\n    .replace(/^-+/, \"\")\n    .replace(/-+$/, \"\");\n};\n\nconst Heading = ({ type, children }) => {\n  const HeaderComponent = type;\n  const slugLink = `${type[1]}-${slugify(children)}`;\n\n  return (\n    <HeaderComponent id={slugLink}>\n      {children}\n      <a href={`#${slugLink}`} aria-label={`Link to section \"${children}\"`}>\n        <img alt=\"\" role=\"presentation\" src={linkImage} />\n      </a>\n    </HeaderComponent>\n  );\n};\n\nHeading.propTypes = {\n  type: PropTypes.oneOf([\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]).isRequired,\n  children: PropTypes.string.isRequired,\n};\n\nexport default Heading;\n","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUxMiA1MTIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDU5LjY1NCwyMzMuMzczbC05MC41MzEsOTAuNWMtNDkuOTY5LDUwLTEzMS4wMzEsNTAtMTgxLDBjLTcuODc1LTcuODQ0LTE0LjAzMS0xNi42ODgtMTkuNDM4LTI1LjgxMwoJbDQyLjA2My00Mi4wNjNjMi0yLjAxNiw0LjQ2OS0zLjE3Miw2LjgyOC00LjUzMWMyLjkwNiw5LjkzOCw3Ljk4NCwxOS4zNDQsMTUuNzk3LDI3LjE1NmMyNC45NTMsMjQuOTY5LDY1LjU2MywyNC45MzgsOTAuNSwwCglsOTAuNS05MC41YzI0Ljk2OS0yNC45NjksMjQuOTY5LTY1LjU2MywwLTkwLjUxNmMtMjQuOTM4LTI0Ljk1My02NS41MzEtMjQuOTUzLTkwLjUsMGwtMzIuMTg4LDMyLjIxOQoJYy0yNi4xMDktMTAuMTcyLTU0LjI1LTEyLjkwNi04MS42NDEtOC44OTFsNjguNTc4LTY4LjU3OGM1MC00OS45ODQsMTMxLjAzMS00OS45ODQsMTgxLjAzMSwwCglDNTA5LjYyMywxMDIuMzQyLDUwOS42MjMsMTgzLjM4OSw0NTkuNjU0LDIzMy4zNzN6IE0yMjAuMzI2LDM4Mi4xODZsLTMyLjIwMywzMi4yMTljLTI0Ljk1MywyNC45MzgtNjUuNTYzLDI0LjkzOC05MC41MTYsMAoJYy0yNC45NTMtMjQuOTY5LTI0Ljk1My02NS41NjMsMC05MC41MzFsOTAuNTE2LTkwLjVjMjQuOTY5LTI0Ljk2OSw2NS41NDctMjQuOTY5LDkwLjUsMGM3Ljc5Nyw3Ljc5NywxMi44NzUsMTcuMjAzLDE1LjgxMywyNy4xMjUKCWMyLjM3NS0xLjM3NSw0LjgxMy0yLjUsNi44MTMtNC41bDQyLjA2My00Mi4wNDdjLTUuMzc1LTkuMTU2LTExLjU2My0xNy45NjktMTkuNDM4LTI1LjgyOGMtNDkuOTY5LTQ5Ljk4NC0xMzEuMDMxLTQ5Ljk4NC0xODEuMDE2LDAKCWwtOTAuNSw5MC41Yy00OS45ODQsNTAtNDkuOTg0LDEzMS4wMzEsMCwxODEuMDMxYzQ5Ljk4NCw0OS45NjksMTMxLjAzMSw0OS45NjksMTgxLjAxNiwwbDY4LjU5NC02OC41OTQKCUMyNzQuNTYxLDM5NS4wOTIsMjQ2LjQyLDM5Mi4zNDIsMjIwLjMyNiwzODIuMTg2eiIvPgo8L3N2Zz4K\"","import { Link } from \"gatsby\";\nimport PropTypes from \"prop-types\";\nimport React from \"react\";\n\nconst PageChange = ({ previous, next }) => (\n  <div className=\"page-change\">\n    {previous ? (\n      <div className=\"page-previous util text-left\">\n        <Link to={previous}>&#x2190; Previous Chapter</Link>\n      </div>\n    ) : null}\n    {next ? (\n      <div className=\"page-next util text-right\">\n        <Link to={next}>Next Chapter &#x2192;</Link>\n      </div>\n    ) : null}\n  </div>\n);\n\nPageChange.propTypes = {\n  previous: PropTypes.string,\n  next: PropTypes.string,\n};\n\nPageChange.defaultProps = {\n  previous: ``,\n  next: ``,\n};\n\nexport default PageChange;\n","import { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport Content from \"../../components/content\";\nimport Heading from \"../../components/heading\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst RenderPipelinePage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Basics - The GPU Render Pipeline\"\n      description=\"A look into the GPU render pipeline and how it renders images.\"\n      keywords={[\"shader\", \"basics\", \"gpu\", \"render\", \"pipeline\"]}\n    />\n    <Content>\n      <h1>Shader Basics - The GPU Render Pipeline</h1>\n      <p>\n        GPUs, when rendering images, primarily work on a set of vertex data. If\n        we have an object (for example, a teapot) that we wish to render an\n        image of, the teapot first needs to be divided into small components\n        called primitives.\n      </p>\n      <p>\n        Primitives are basic shapes that can, when combined together, form\n        objects. Like how atoms are the building blocks of physical objects,\n        primitives can be considered the building blocks of digital objects.\n      </p>\n      <p>\n        A primitive can be described by the vertices of that primitive, along\n        with certain other information.\n      </p>\n      <p>\n        So in order to tell the GPU to render an object, we have to provide the\n        GPU the set of vertices that describe the primitives forming that\n        object, along with what kind of primitives do the vertices form.\n      </p>\n      <p>\n        Only one kind of primitive is generally used to form objects, although\n        multiple can technically be used.\n      </p>\n      <p>\n        Along with this, the GPU is also provided with a shader program that\n        will aid the GPU in interpreting this data and visualizing it.\n      </p>\n      <p>\n        The GPU is then told to perform an operation. It goes through a render\n        pipeline, starting multiple instances of the shader program to process\n        the data in parallel, processing the data during intermediate stages as\n        required, and finally outputting a rendered image.\n      </p>\n      <p>\n        Below is an overview of the render pipeline, showing the stages the GPU\n        goes through to render the final image (note that stages in blue are\n        programmable, stages in yellow are not):\n      </p>\n      <div className=\"util text-center\">\n        <StaticImage\n          src=\"../../images/basics/render-pipeline-1.png\"\n          alt=\"Render Pipeline Visual\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        <a\n          href=\"https://www.khronos.org/opengl/wiki/File:RenderingPipeline.png\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source\n        </a>\n      </div>\n      <p>\n        This may seem a little daunting at first, but let's walk through it step\n        by step:\n      </p>\n      <dl>\n        <dt>\n          <Heading type=\"h3\">Vertex Specification</Heading>\n        </dt>\n        <dd>\n          <p>\n            This is the set of data that the GPU will be working with. For\n            rendering, the GPU primarily works with a set of vertices.\n          </p>\n          <p>\n            Additional data can be be sent as well, but they have to be constant\n            for all vertices passed to the GPU, or need to have a 1-to-1\n            relation with the vertices (each piece of data should relate to a\n            vertex and vice-versa).\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Vertex Shader</Heading>\n        </dt>\n        <dd>\n          <p>\n            This is the first shader that is executed on the data provided to\n            the GPU. It receives a single vertex as an input and provides a\n            coordinate in \"clip-space\" as an output. More of this will be\n            discussed in the chapter on the basics of the vertex shader.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Tesellation</Heading>\n        </dt>\n        <dd>\n          <p>\n            Tessellation is an optional stage that can be performed on the\n            resultant vertices with their coordinates to determine and\n            \"tessellate\" the object being rendered. Tessellation is the process\n            of splitting a primitive into sub-primitives in order to improve\n            detail.\n          </p>\n          <p>\n            The tessellation stage consists of two shaders, one that determines\n            if a primitive needs to be tessellated, and one that performs the\n            actual tessellation.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Geometry Shader</Heading>\n        </dt>\n        <dd>\n          <p>\n            This is an optional shader that can receive a set of primitives, and\n            outputs a set of primitives that can be same or different to the\n            ones received by it.\n          </p>\n          <p>\n            This is useful for a variety of tasks, from{\" \"}\n            <a\n              href=\"https://upvoid.com/devblog/2013/02/prototype-grass/\"\n              rel=\"noopener noreferrer\"\n              target=\"_blank\"\n            >\n              generating grass on terrain geometry\n            </a>{\" \"}\n            to creating{\" \"}\n            <a\n              href=\"https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch11.html\"\n              rel=\"noopener noreferrer\"\n              target=\"_blank\"\n            >\n              volumetric shadows\n            </a>\n            .\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Vertex Post-Processing</Heading>\n        </dt>\n        <dd>\n          <p>\n            In this stage, the results from the processing done in the previous\n            stages is saved in a separate buffer, allowing the results to be\n            operated on by the initial stages as a feedback loop, or letting the\n            CPU read the results.\n          </p>\n          <p>\n            The data of the output from the previous stages is in the same order\n            as the input data provided to it, so that the input data and output\n            result can be related easily.\n          </p>\n          <p>\n            The output undergoes clipping after the previous step, where every\n            primitive completely outside the view of the screen is removed,\n            every primitive completely inside is kept, and primitives in between\n            are subdivided in such a way that they split into primitives that\n            are completely outside and inside, allowing for the unneeded parts\n            of the primitive to be removed.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Primitive Assembly</Heading>\n        </dt>\n        <dd>\n          <p>\n            This stages takes the primitives that have to be rendered and splits\n            them up into simple/base primitives (points, lines, or triangles).\n            The reason for this is because these are the simplest and sets of\n            primitives that the GPU can work with, as well as being the smallest\n            type (they cannot be represented by shapes with fewer vertices).\n          </p>\n          <p>\n            Culling is performed during this stage as well, to remove base\n            primitives that won't be rendered onto the screen.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Rasterization</Heading>\n        </dt>\n        <dd>\n          <p>\n            The final primitives are broken down into small samples called\n            fragments, which contain information that is used to color the\n            pixels of the rendered image. More of this will be discussed in the\n            chapter on the basics of the fragment shader.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Fragment Shader</Heading>\n        </dt>\n        <dd>\n          <p>\n            This shader processes the fragments generated by the rasterization\n            process and determines what the color of each fragment is, which\n            contributes to the final color of the pixel the fragment is under.\n            More of this will be discussed in the chapter on the basics of the\n            fragment shader.\n          </p>\n          <p>\n            This stage is <em>*technically*</em> optional, but it is required if\n            you want to render an actual image with some color.\n          </p>\n        </dd>\n        <dt>\n          <Heading type=\"h3\">Per-Sample Operations</Heading>\n        </dt>\n        <dd>\n          <p>\n            This the final stage that consists of multiple tests in order to\n            remove fragments that are not part of the final image. The tests\n            are:\n          </p>\n          <ul>\n            <li>\n              <strong>Pixel ownership test</strong>: Tests if the pixel the\n              fragment is under is \"owned\" by the renderer (applicable in cases\n              where a window is overlapping the view).\n            </li>\n            <li>\n              <strong>Scissor test</strong>: Tests if the fragment lies within a\n              specific section of the screen.\n            </li>\n            <li>\n              <strong>Stencil test</strong>: An optional test that, when\n              enabled, checks if the fragment is blocked by a stencil\n              image/mask.\n            </li>\n            <li>\n              <strong>Depth test</strong>: Tests if the fragment's is below or\n              above certain fragments, and whether they need to be discarded\n              accordingly.\n            </li>\n          </ul>\n          <p>\n            A certain number of these steps can be performed before running the\n            fragment shader under certain conditions to improve performance.\n          </p>\n          <p>\n            After the tests are completed, the final color of the pixel is\n            determined by blending the colors of all fragments part of the pixel\n            that passed the tests.\n          </p>\n          <p>\n            The result is then copied to a framebuffer, which is a buffer of the\n            generated image, and can either be copied from the GPU by the CPU,\n            or sent to the monitor to show to the user.\n          </p>\n        </dd>\n      </dl>\n      <p>\n        The flow of the pipeline also allows for data to be passed from certain\n        shaders to others, which can be used in interesting ways, which will be\n        explored later.\n      </p>\n      <p>\n        Understanding how a GPU renders is important, since this helps\n        understand the purpose of each type of shader and why they perform the\n        operations that they do.\n      </p>\n      <p>\n        To learn about the graphics rendering pipeline in a lot more detail,\n        check out{\" \"}\n        <a\n          href=\"https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/\"\n          rel=\"noopener noreferrer\"\n          target=\"_blank\"\n        >\n          A trip through the Graphics Pipeline 2011\n        </a>\n        .\n      </p>\n      <p>\n        The basics section will be focusing primarily on vertex shaders and\n        fragment shaders, which are vital for rendering an image on to the\n        screen, or onto a buffer for use later. The next chapter will begin with\n        the vertex shader.\n      </p>\n    </Content>\n    <PageChange previous=\"/basics/introduction/\" next=\"/basics/mathematics/\" />\n  </Layout>\n);\n\nexport default RenderPipelinePage;\n"],"names":["_ref","type","children","HeaderComponent","slugLink","toString","trim","toLowerCase","replace","React","id","href","alt","role","src","PageChange","previous","next","className","Link","to","defaultProps","location","pathname","Layout","Seo","title","description","keywords","Content","StaticImage","style","maxWidth","__imageData","require","target","rel","Heading"],"sourceRoot":""}