{"version":3,"file":"component---src-pages-intermediates-color-mapping-js-0252a1f0d4411481ffc7.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/intermediates/color-mapping/common/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/color-mapping/first-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/color-mapping/first-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/color-mapping/first-example.js","webpack://shader-tutorial/./src/components/intermediates/color-mapping/second-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/color-mapping/second-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/color-mapping/second-example.js","webpack://shader-tutorial/./src/pages/intermediates/color-mapping.js","webpack://shader-tutorial/./src/images/intermediates/texture.png"],"sourcesContent":["export default \"attribute vec4 vertexPosition;\\nattribute vec2 vertexUv;\\n\\nuniform mat4 mvpMatrix;\\n\\nvarying highp vec2 uv;\\n\\nvoid main() {\\n  gl_Position = mvpMatrix * vertexPosition;\\n  uv = vertexUv;\\n}\";","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./first-example/fragment.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","export default \"varying highp vec2 uv;\\n\\nuniform sampler2D colorTextureSampler;\\n\\nvoid main() {\\n  gl_FragColor = texture2D(colorTextureSampler, uv);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate, uvArrToString } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst ColorMappingFirstExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    indices: null,\n    texture: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const time = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle = (((time / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, rotatedModelMatrix);\n            mat4.multiply(mvpMatrix, projectionMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    Vertices:\n        Vertex 1: ${coordArrToString(cube.vertices[0])}\n        Vertex 2: ${coordArrToString(cube.vertices[1])}\n        Vertex 3: ${coordArrToString(cube.vertices[2])}\n        Vertex 4: ${coordArrToString(cube.vertices[5])}\n        Vertex 5: ${coordArrToString(cube.vertices[30])}\n        Vertex 6: ${coordArrToString(cube.vertices[31])}\n        Vertex 7: ${coordArrToString(cube.vertices[32])}\n        Vertex 8: ${coordArrToString(cube.vertices[35])}\n    Face UV:\n        Vertex 1: ${uvArrToString(cubeFaceUvs[0])}\n        Vertex 2: ${uvArrToString(cubeFaceUvs[1])}\n        Vertex 3: ${uvArrToString(cubeFaceUvs[2])}\n        Vertex 4: ${uvArrToString(cubeFaceUvs[3])}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(ColorMappingFirstExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./second-example/fragment.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"varying highp vec2 uv;\\n\\nuniform highp float time;\\nuniform sampler2D colorTextureSampler;\\n\\nhighp float getColorShiftFactor(highp vec3 color) {\\n  return clamp(ceil(3.0 - (color.r + color.g + color.b)), 0.0, 1.0);\\n}\\n\\nvoid main() {\\n  highp float colorShift = cos(time / 500.0);\\n  highp vec4 textureColor = texture2D(colorTextureSampler, uv);\\n  highp float finalColorShift = getColorShiftFactor(textureColor.rgb) * colorShift;\\n  gl_FragColor = vec4(clamp(textureColor.rgb - finalColorShift, 0.0, 1.0), textureColor.a);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport texture from \"../../../images/intermediates/texture.png\"\nimport { coordArrToString, runOnPredicate, uvArrToString } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexUv: \"vec2\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      time: \"float\",\n      colorTextureSampler: \"sampler2D\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\nconst cubeFaceUvs = [\n  [0.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [0.0, 1.0],\n  [1.0, 0.0],\n  [1.0, 1.0],\n];\n\nconst ColorMappingSecondExample = () => {\n  const cube = {\n    vertices: [\n      // Front vertices\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      // Left vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [-1.0, 1.0, 1.0],\n      // Right vertices\n      [1.0, -1.0, 1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      // Top vertices\n      [-1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [-1.0, 1.0, -1.0],\n      [1.0, 1.0, 1.0],\n      [1.0, 1.0, -1.0],\n      // Bottom vertices\n      [-1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [-1.0, -1.0, 1.0],\n      [1.0, -1.0, -1.0],\n      [1.0, -1.0, 1.0],\n      // Back vertices\n      [1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [1.0, 1.0, -1.0],\n      [-1.0, -1.0, -1.0],\n      [-1.0, 1.0, -1.0],\n    ],\n    uvs: [\n      // Front UVs\n      ...cubeFaceUvs,\n      // Left UVs\n      ...cubeFaceUvs,\n      // Right UVs\n      ...cubeFaceUvs,\n      // Top UVs\n      ...cubeFaceUvs,\n      // Bottom UVs\n      ...cubeFaceUvs,\n      // Back UVs\n      ...cubeFaceUvs,\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n      [12, 13, 14, 15, 16, 17],\n      [18, 19, 20, 21, 22, 23],\n      [24, 25, 26, 27, 28, 29],\n      [30, 31, 32, 33, 34, 35],\n    ],\n    texture: texture,\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    uvs: null,\n    indices: null,\n    texture: null,\n  });\n\n  const [time, updateTime] = useState(\n    typeof performance !== \"undefined\" ? performance.now() : 0.0,\n  );\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        uvs: webGlRef.createStaticDrawArrayBuffer(\n          cube.uvs.flat(),\n          cubeBuffer.uvs,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n        texture: webGlRef.createImageTexture(cube.texture, cubeBuffer.texture),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n      let then = parseInt(\n        typeof performance !== \"undefined\"\n          ? performance.now()\n          : (0.0).toString(),\n      );\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const currentTime = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            if (currentTime - then > 100) {\n              then = currentTime;\n              updateTime(currentTime);\n            }\n\n            const rotatedModelMatrix = mat4.create();\n            const rotationAngle =\n              (((currentTime / 30) % (360 * 6)) * Math.PI) / 180;\n            mat4.rotateZ(rotatedModelMatrix, modelMatrix, rotationAngle);\n            mat4.rotateX(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 2,\n            );\n            mat4.rotateY(\n              rotatedModelMatrix,\n              rotatedModelMatrix,\n              rotationAngle / 3,\n            );\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, rotatedModelMatrix);\n            mat4.multiply(mvpMatrix, projectionMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.uvs);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n              2,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexUv,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.time,\n              currentTime,\n            );\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, cubeBuffer.texture);\n            gl.uniform1i(\n              shaderInfo.fragment.uniformLocations.colorTextureSampler,\n              0,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nCube:\n    Vertices:\n        Vertex 1: ${coordArrToString(cube.vertices[0])}\n        Vertex 2: ${coordArrToString(cube.vertices[1])}\n        Vertex 3: ${coordArrToString(cube.vertices[2])}\n        Vertex 4: ${coordArrToString(cube.vertices[5])}\n        Vertex 5: ${coordArrToString(cube.vertices[30])}\n        Vertex 6: ${coordArrToString(cube.vertices[31])}\n        Vertex 7: ${coordArrToString(cube.vertices[32])}\n        Vertex 8: ${coordArrToString(cube.vertices[35])}\n    Face UV:\n        Vertex 1: ${uvArrToString(cubeFaceUvs[0])}\n        Vertex 2: ${uvArrToString(cubeFaceUvs[1])}\n        Vertex 3: ${uvArrToString(cubeFaceUvs[2])}\n        Vertex 4: ${uvArrToString(cubeFaceUvs[3])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">Time: {time}</pre>\n    </div>\n  );\n};\n\nexport default wrapExample(ColorMappingSecondExample);\n","import { Link } from \"gatsby\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport Content from \"../../components/content\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport TexturingFirstExample from \"../../components/intermediates/color-mapping/first-example\";\nimport {\n  firstFragmentShaderSource,\n  firstVertexShaderSource,\n} from \"../../components/intermediates/color-mapping/first-example-shaders\";\nimport TexturingSecondExample from \"../../components/intermediates/color-mapping/second-example\";\nimport { secondFragmentShaderSource } from \"../../components/intermediates/color-mapping/second-example-shaders\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst ColorMappingPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Intermediates - Color Mapping\"\n      description=\"A look into the how color textures are used to color objects in shaders.\"\n      keywords={[\"color\", \"mapping\", \"texturing\", \"shader\", \"intermediates\"]}\n    />\n    <Content>\n      <h1>Shader Intermediates - Color Mapping</h1>\n      <p>\n        So far we've passed direct color information of vertices to the fragment\n        shader, which was then interpolated for each fragment and then set as\n        the pixel color.\n      </p>\n      <p>\n        As learnt in the{\" \"}\n        <Link to=\"/basics/fragment-shader/\">fragment shader basics</Link>, color\n        information can only be mapped to the vertices of an object, with color\n        values of parts of the object between the vertices being interpolated.\n      </p>\n      <p>\n        However, as we learnt in the{\" \"}\n        <Link to=\"/intermediate/mapping/\">mapping</Link> chapter, we can use a\n        texture to add much more detail to an object through the process of UV\n        mapping.\n      </p>\n      <p>\n        We can use the process of mapping to map colors of a fragment from the\n        color data stored in a texture/color map. This process is called color\n        mapping.\n      </p>\n      <p>\n        Color mapping is also referred to as texturing due to the fact that\n        textures only hold color data, and are primarily used to color fragments\n        in an image.\n      </p>\n      <p>\n        Let's look at an example of color mapping where an image is used as a\n        texture to color the faces of a cube.\n      </p>\n      <Heading type=\"h2\">An example - A cube</Heading>\n      <TexturingFirstExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        The following texture is used to color the each face of the rendered\n        cube:\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/texture.png\"\n          alt=\"Cube Face Texture\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        The vertices of each face are mapped to the corners of the texture. You\n        can look at the cube details below the rendered image to see the UV\n        coordinates of the vertices of a single face.\n      </p>\n      <p>\n        <em>\n          Note: For OpenGL/WebGL, the origin for UV coordinates is the\n          lower-left corner of an image. For DirectX, the origin for UV\n          coordinates is the upper-left corner of an image. When translating\n          shader code between these languages, take care of the Y-axis values of\n          the UV coordinates.\n        </em>\n      </p>\n      <p>\n        These UV coordinates are passed as part of the vertex data to the GPU.\n        When these coordinates are passed to the fragment shader through the\n        vertex shader, the GPU interpolates the UV coordinates of the fragments.\n      </p>\n      <p>\n        For example, a fragment in the center of the face is equi-distant from\n        all four vertices of the face. Since the vertices are mapped to the\n        corners of the texture, the fragment will receive an interpolated UV\n        coordinate at the center of the texture.\n      </p>\n      <p>\n        Using these interpolated UV coordinates, the color of the texture at\n        that point can be read by the fragment shader, which will represent the\n        final color of that fragment, since the UV coordinate represents the\n        location of the fragment within the texture.\n      </p>\n      <GlslCodeHighlight\n        code={firstVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={firstFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        In the vertex shader code above, the UV coordinates of the vertex is\n        provided through the <code>vertexUv</code> attribute, which is then\n        passed to the fragment shader through <code>uv</code>, allowing the GPU\n        to interpolate the UV coordinates for each fragment.\n      </p>\n      <p>\n        In the fragment shader, the pixel color value of the texture at the\n        given UV coordinates is retrieved through the 2D sampler{\" \"}\n        <code>colorTextureSampler</code>, which is then the final color assigned\n        to the fragment.\n      </p>\n      <p>\n        <code>colorTextureSampler</code> is defined as <code>sampler2D</code>{\" \"}\n        because the texture is a 2D image which is being sampled for color\n        values at specific coordinates.\n      </p>\n      <Heading type=\"h2\">Another example - A (mostly) pulsing cube</Heading>\n      <TexturingSecondExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Similar to how the pulsing triangle was made in the last example of the{\" \"}\n        <Link to=\"/basics/fragment-shader/\">fragment shader basics</Link>, a{\" \"}\n        <code>colorShift</code> value is subtracted from the color values\n        retrieved from the texture (except for alpha), and then set as the final\n        color of the fragment.\n      </p>\n      <p>\n        One unique change is the white edges of the cube, which do not pulse and\n        always stay constant.\n      </p>\n      <GlslCodeHighlight\n        code={secondFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        In the code, a new function <code>getColorShiftFactor</code> accepts an\n        RGB <code>color</code> variable, and using a formula, decides whether\n        the color shift should be factored by 0 or 1.\n      </p>\n      <p>\n        If 0 is returned, the final color shift value is nullified, not\n        affecting the value of the texture color when it is set to the final\n        fragment color value.\n      </p>\n      <p>\n        If 1 is returned, the final color shift value is in full effect,\n        affecting the texture color value as it normally would when setting the\n        final fragment color value.\n      </p>\n      <p>The color shift factor formula works as follows:</p>\n      <ul>\n        <li>\n          Combine the values of the red, green, and blue components of the\n          texture color.\n        </li>\n        <li>Subtract this value from 3.0</li>\n        <li>\n          Ceil the difference at or above it (ex: it would change the number 2.1\n          to 3).\n        </li>\n        <li>Clamp the resultant value so that it is within the range 0 - 1</li>\n      </ul>\n      <p>\n        When a color is white, it's RGB components would all be at their highest\n        value, which is 1. As a result, their sum would be 3. When this sum is\n        subtracted from the value 3, any color value that is not white would\n        result in a difference greater than 0.\n      </p>\n      <p>\n        This will result in the ceiling value of any color that is not white be\n        least 1 or higher, which is then clamped to 1.\n      </p>\n      <p>\n        As a result, this equation ensures that all texture color values that\n        are white have a color shift factor of 0, and the rest have a value of\n        1.\n      </p>\n      <Heading type=\"h2\">Additional Notes</Heading>\n      <p>\n        If you're working with OpenGL/WebGL, there is one thing you will need to\n        remember when working with textures.\n      </p>\n      <p>\n        Typically when images are read, their starting coordinates are at the\n        top-left of the image. This means that the origin coordinates{\" \"}\n        <code>(0, 0, 0)</code> represents the top-left most pixel of the image.\n      </p>\n      <p>\n        However, in OpenGL/WebGL the starting coordinate is instead the\n        bottom-left of the image. This means that if you try to load an image\n        the same way in OpenGL as in DirectX, you will find that the image is\n        flipped vertically when sampling and rendering it in your shader.\n      </p>\n      <p>As a result, you have two possible options:</p>\n      <ul>\n        <li>\n          Flip the image vertically when loading it in OpenGL to keep things\n          consistent in the shader.\n        </li>\n        <li>\n          Invert the Y-axis of your UV coordinates when sampling from the image\n          texture.\n        </li>\n      </ul>\n      <p>\n        Since our tutorial uses WebGL, we need to use one of these options to\n        prevent textures from appearing inverted. We've gone with the first\n        option to keep the shader logic more consistent. If you're using\n        OpenGL/WebGL, you'll need to keep this in mind as well.\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          Through the process of UV mapping, we can define the color of each\n          fragment of an object through the use of a texture.\n        </li>\n        <li>\n          Each vertex is assigned a UV coordinate on the texture, which is then\n          interpolated by the GPU for each fragment.\n        </li>\n        <li>\n          The fragment shader can then read the color value of the texture at\n          the interpolated UV coordinate for the fragment to determine and set\n          the final color of that fragment.\n        </li>\n      </ul>\n    </Content>\n    <PageChange\n      previous=\"/intermediates/mapping/\"\n      next=\"/intermediates/lighting/\"\n    />\n  </Layout>\n);\n\nexport default ColorMappingPage;\n","export default __webpack_public_path__ + \"static/texture-d46d879879755d42e588c10e2b6c3335.png\";"],"names":["firstVertexShaderSource","vertexShader","firstFragmentShaderSource","shaderProgramInfo","vertex","attributeLocations","vertexPosition","vertexUv","uniformLocations","mvpMatrix","fragment","colorTextureSampler","cubeModelPosition","mat4","cubeFaceUvs","wrapExample","ColorMappingFirstExample","cube","vertices","uvs","concat","indices","texture","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","cubeBuffer","updateCubeBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","createElementArrayBuffer","createImageTexture","shouldRender","renderScene","_ref","gl","projectionMatrix","viewMatrix","modelMatrix","time","parseInt","performance","now","toString","rotatedModelMatrix","rotationAngle","Math","PI","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","useProgram","uniformMatrix4fv","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniform1i","drawElements","TRIANGLES","length","UNSIGNED_SHORT","requestAnimationFrame","React","className","style","padding","width","height","ref","coordArrToString","uvArrToString","trim","secondVertexShaderSource","secondFragmentShaderSource","ColorMappingSecondExample","updateTime","then","currentTime","uniform1f","location","pathname","Layout","Seo","title","description","keywords","Content","Link","to","Heading","type","TexturingFirstExample","StaticImage","src","alt","maxWidth","__imageData","require","GlslCodeHighlight","code","TexturingSecondExample","PageChange","previous","next"],"sourceRoot":""}