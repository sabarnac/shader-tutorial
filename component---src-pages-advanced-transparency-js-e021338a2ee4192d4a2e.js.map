{"version":3,"file":"component---src-pages-advanced-transparency-js-e021338a2ee4192d4a2e.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/advanced/transparency/common-shaders.js","webpack://shader-tutorial/./src/components/advanced/transparency/common/vertex.glsl","webpack://shader-tutorial/./src/components/advanced/transparency/common/fragment.glsl","webpack://shader-tutorial/./src/components/advanced/transparency/first-example.js","webpack://shader-tutorial/./src/components/advanced/transparency/opengl-blend.js","webpack://shader-tutorial/./src/components/advanced/transparency/second-example.js","webpack://shader-tutorial/./src/components/advanced/transparency/third-example.js","webpack://shader-tutorial/./src/pages/advanced/transparency.js","webpack://shader-tutorial/./src/components/advanced/transparency/webgl-blend.js","webpack://shader-tutorial/./src/components/advanced/transparency/directx-blend.js"],"sourcesContent":["import fragmentShader from \"!raw-loader!./common/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./common/vertex.glsl\";\n\nexport const vertexShaderSource = vertexShader;\nexport const fragmentShaderSource = fragmentShader;\n","export default \"attribute vec4 vertexPosition;\\nattribute vec3 vertexColor;\\n\\nuniform mat4 mvpMatrix;\\n\\nvarying highp vec3 color;\\n\\nvoid main() {\\n  gl_Position = mvpMatrix * vertexPosition;\\n  color = vertexColor;\\n}\";","export default \"varying highp vec3 color;\\n\\nvoid main() {\\n  gl_FragColor = vec4(color, 0.5);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fragmentShaderSource, vertexShaderSource } from \"./common-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexColor: \"vec3\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\n\nconst TransparencyFirstExample = () => {\n  const cube = {\n    vertices: [\n      // Green Face\n      [1.5, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [-1.0, -1.0, -1.0],\n      // Red Face\n      [-1.5, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [1.0, 1.0, 1.0],\n    ],\n    colors: [\n      // Green Face\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Red Face\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    colors: null,\n    indices: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n        true,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(vertexShaderSource, fragmentShaderSource),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        colors: webGlRef.createStaticDrawArrayBuffer(\n          cube.colors.flat(),\n          cubeBuffer.colors,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderSceneOrtho(\n          ({ gl, orthoMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n            mat4.multiply(mvpMatrix, orthoMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition.reverse,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.colors);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nOrder of Faces:\n    Depth-wise:\n        Red Square (Front)\n        Green Square (Back)\n    Passed to GPU:\n        Green Square (First)\n        Red Square (Second)\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(TransparencyFirstExample);\n","export const openglCode = `\nvoid enableBlending() {\n  glEnable(GL_BLEND);\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n}\n`;\n","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fragmentShaderSource, vertexShaderSource } from \"./common-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexColor: \"vec3\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\n\nconst TransparenceySecondExample = () => {\n  const cube = {\n    vertices: [\n      // Green Face\n      [-1.5, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [1.0, 1.0, 1.0],\n      // Red Face\n      [1.5, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [-1.0, -1.0, -1.0],\n    ],\n    colors: [\n      // Green Face\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      // Red Face\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    colors: null,\n    indices: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n        true,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(vertexShaderSource, fragmentShaderSource),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        colors: webGlRef.createStaticDrawArrayBuffer(\n          cube.colors.flat(),\n          cubeBuffer.colors,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderSceneOrtho(\n          ({ gl, orthoMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n            mat4.multiply(mvpMatrix, orthoMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition.reverse,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.colors);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nOrder of Faces:\n    Depth-wise:\n        Green Square (Front)\n        Red Square (Back)\n    Passed to GPU:\n        Green Square (First)\n        Red Square (Second)\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(TransparenceySecondExample);\n","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fragmentShaderSource, vertexShaderSource } from \"./common-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexColor: \"vec3\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n};\n\nconst cubeModelPosition = mat4.create();\n\nconst TransparencyThirdExample = () => {\n  const cube = {\n    vertices: [\n      // Red Face\n      [1.5, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [1.5, -1.0, -1.0],\n      [-1.0, 1.5, -1.0],\n      [-1.0, -1.0, -1.0],\n      // Green Face\n      [-1.5, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [-1.5, 1.0, 1.0],\n      [1.0, -1.5, 1.0],\n      [1.0, 1.0, 1.0],\n    ],\n    colors: [\n      // Red Face\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      [1.0, 0.0, 0.0],\n      // Green Face\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 1.0, 0.0],\n    ],\n    indices: [\n      [0, 1, 2, 3, 4, 5],\n      [6, 7, 8, 9, 10, 11],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [cubeBuffer, updateCubeBuffer] = useState({\n    vertices: null,\n    colors: null,\n    indices: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        cubeModelPosition,\n        true,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(vertexShaderSource, fragmentShaderSource),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateCubeBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          cube.vertices.flat(),\n          cubeBuffer.vertices,\n        ),\n        colors: webGlRef.createStaticDrawArrayBuffer(\n          cube.colors.flat(),\n          cubeBuffer.colors,\n        ),\n        indices: webGlRef.createElementArrayBuffer(\n          cube.indices.flat(),\n          cubeBuffer.indices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(cubeBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderSceneOrtho(\n          ({ gl, orthoMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n            mat4.multiply(mvpMatrix, orthoMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition.reverse,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.colors);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n            );\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n\n            gl.drawElements(\n              gl.TRIANGLES,\n              cube.indices.length * cube.indices[0].length,\n              gl.UNSIGNED_SHORT,\n              0,\n            );\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [cubeBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nOrder of Faces:\n    Depth-wise:\n        Green Square (Front)\n        Red Square (Back)\n    Passed to GPU:\n        Red Square (First)\n        Green Square (Second)\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(TransparencyThirdExample);\n","import React from \"react\"\n\nimport { fragmentShaderSource } from \"../../components/advanced/transparency/common-shaders\"\nimport { directxCode } from \"../../components/advanced/transparency/directx-blend\"\nimport TransparencyFirstExample from \"../../components/advanced/transparency/first-example\"\nimport { openglCode } from \"../../components/advanced/transparency/opengl-blend\"\nimport TransparencySecondExample from \"../../components/advanced/transparency/second-example\"\nimport TransparencyThirdExample from \"../../components/advanced/transparency/third-example\"\nimport { webglCode } from \"../../components/advanced/transparency/webgl-blend\"\nimport Content from \"../../components/content\"\nimport GenericCodeHighlight from \"../../components/generic-code-highlight\"\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\"\nimport Heading from \"../../components/heading\"\nimport Layout from \"../../components/layout\"\nimport PageChange from \"../../components/page-change\"\nimport Seo from \"../../components/seo\"\n\nconst TransparencyPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Advanced - Transparency\"\n      description=\"A look into the implementing transparency and certain quirks about it.\"\n      keywords={[\n        \"shader\",\n        \"advanced\",\n        \"transparency\",\n        \"transparent\",\n        \"transluscent\",\n      ]}\n    />\n    <Content>\n      <h1>Shader Advanced - Transparency</h1>\n      <p>\n        Implementing support for transparency in shader code is not a complex\n        task. The fragment shader returns a color vector of 4 components, with\n        the 4th component representing opaqueness of the color.\n      </p>\n      <p>\n        By setting the opaqueness value of the color of the fragments, you can\n        make fragments transparent. The GPU can be told how transluscent colors\n        returned by the fragment shader should be blended, and based upon that\n        get a final result.\n      </p>\n      <GlslCodeHighlight code={fragmentShaderSource.trim()} type=\"Fragment\" />\n      <p>\n        As seen in this fragment shader code, the color of the fragment is set\n        using whatever color value is received, and the alpha value of the color\n        is set to 0.5. This means that the fragment is 50% opaque.\n      </p>\n      <p>\n        However, just setting the alpha value isn't enough. You will have to\n        explicitly tell the graphics API you use to enable color/alpha blending.\n      </p>\n      <p>\n        Color blending is an operation that the GPU can perform where it blends\n        the colors of multiple fragments into a final output color.\n      </p>\n      <p>\n        Alpha blending is a type of color blending where the colors from\n        different fragments are blended together depending on the alpha\n        component of each color.\n      </p>\n      <p>\n        GPUs can blend colors in multiple ways, each using their own specific\n        formula for how colors are mixed. However, while some can be used with\n        no issues, there are certain blending algorithms that have caveats\n        attached to them.\n      </p>\n      <p>\n        For the examples we'll be showing, the WebGL color blending\n        configuration is:\n      </p>\n      <GenericCodeHighlight\n        code={webglCode.trim()}\n        type=\"WebGL\"\n        language=\"js\"\n      />\n      <p>\n        The equivalent OpenGL and DirectX color blending configurations are:\n      </p>\n      <GenericCodeHighlight\n        code={openglCode.trim()}\n        type=\"OpenGL\"\n        language=\"cpp\"\n      />\n      <GenericCodeHighlight\n        code={directxCode.trim()}\n        type=\"DirectX\"\n        language=\"cpp\"\n      />\n      <p>\n        While this configuration is recommended for blending transparent colors,\n        it has a requirement that can severly impact performance. Let's look at\n        an example to see the limitations of the chosen color blending\n        algorithm.\n      </p>\n      <Heading type=\"h2\">Example - Red Square and Green Square</Heading>\n      <TransparencyFirstExample />\n      <p>\n        Here, we're drawing two squares, one in red, and one in green. In this\n        image, the red square is placed in front of the green square, but the\n        green square is passed to the GPU first for rendering.\n      </p>\n      <p>\n        The GPU first draws the green square onto the image. Once the green\n        square is drawn, it begins drawing the red square on top. When the red\n        square is being drawn, the parts of the red square that overlay on top\n        of the green square require the colors of both to be blended together.\n      </p>\n      <p>\n        The blending configuration that is being used, and was shown previously,\n        tells the GPU to blend the colors in such a way that the new fragment\n        color being added to the image should dominate over the color already\n        present in the image.\n      </p>\n      <p>\n        Since the red square is drawn after the green square, its color will\n        dominate over the green, making the color of the overlay section skew\n        more towards red.\n      </p>\n      <p>\n        This is in line with our expectations, since the red square is also in\n        front of the green square depth-wise, which should result in the common\n        area looking red with a green hue.\n      </p>\n      <p>\n        However, what if we wish to draw the image with the green square in\n        front? If we swap the vertex positions of the two squares, we get the\n        following result.\n      </p>\n      <TransparencySecondExample />\n      <p>\n        This result is completely inaccurate. The color of the green square\n        should be dominating over the red, but it is in fact the same as the\n        first example, giving the impression that the red square is still in\n        front.\n      </p>\n      <p>\n        Why is this the case? Because the blending operation has a major\n        requirement that we have failed to satisfy with the second example.\n      </p>\n      <p>\n        In the first image, the green square was drawn onto the image first, and\n        followed by the red square. The chosen blending operation operates in\n        such a way that new objects being drawn will have their colors dominate\n        over already existing colors in the image.\n      </p>\n      <p>\n        This means that the algorithm operates under the assumption that an\n        object already drawn onto the image is present behind the object that is\n        being drawn next.\n      </p>\n      <p>\n        Since the red square is being drawn second, its colors will dominate\n        over the green due to the blending operation selected - the operation\n        assumes that the red square is actually in front of the green square due\n        to it being drawn second.\n      </p>\n      <p>\n        In order to fix this result, the order in which the squares are passed\n        to the GPU should be sorted by the depth of the squares. Squares further\n        away from the camera should be drawn before squares closer to the\n        camera.\n      </p>\n      <TransparencyThirdExample />\n      <p>\n        Since the red square is now behind, by passing it first to the GPU to be\n        drawn, the error in our result is now fixed. The color of the green\n        square now dominates over the red, as it should have been.\n      </p>\n      <p>\n        In our example, the issue was very simple to fix since we were only\n        drawing two squares that are completely separated and can be sorted with\n        ease.\n      </p>\n      <p>\n        However, in cases of objects with multiple polygons that connect or\n        cross-over each other, each polygon needs to be sorted in the correct\n        order.\n      </p>\n      <p>\n        This issue can further be aggravated by a moving camera. Since all\n        transparent polygons have to be sorted by depth w.r.t. the camera, a\n        moving camera requires sorting each polygon in model-view-space, which\n        is expensive.\n      </p>\n      <p>\n        As we can see, the scope of transparency becomes exponentially more\n        difficulty with increasing complexity. This is why transparent objects\n        aren't abundantly found in video games, where real-time rendering is\n        crucial for a good experience.\n      </p>\n      <p>\n        The{\" \"}\n        <a\n          href=\"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          transparency chapter\n        </a>{\" \"}\n        of{\" \"}\n        <a\n          href=\"https://www.opengl-tutorial.org/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          OpenGL Tutorial\n        </a>{\" \"}\n        does provide possible steps that can be taken to reduce the performance\n        impact, and also provides links on order-independent transparency\n        techniques that can achieve the same effect, although they are not\n        simple to implement.\n      </p>\n      <p>\n        There are also other possible configuration options to use that don't\n        have such performance degrading requirements, but each blending\n        algorithm produces a different output, so we recommend experimenting to\n        see which configuration works best for your use-case.\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          Transparency on the shader side is simple to add, through the use of\n          the 4th component of the color value, which represents the alpha (or\n          opacity) of the color.\n        </li>\n        <li>\n          The GPU needs to be told how colors should be blended together to form\n          a final color. This is required for color transparency, since\n          translucent colors need to be blended to form a resultant.\n        </li>\n        <li>\n          While graphics APIs have multiple functions to blend colors in various\n          ways, some of these have caveats that can cause significant\n          performance degregation if an accurate result is required.\n        </li>\n        <li>\n          To learn more about how transparency in various graphics APIs, check\n          out the links below:\n          <ul>\n            <li>\n              <a\n                href=\"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                OpenGL/WebGL\n              </a>\n              .\n            </li>\n            <li>\n              <a\n                href=\"http://www.directxtutorial.com/Lesson.aspx?lessonid=9-4-10\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                DirectX\n              </a>\n              .\n            </li>\n          </ul>\n        </li>\n      </ul>\n    </Content>\n    <PageChange\n      previous=\"/advanced/color-banding-dithering/\"\n      next=\"/advanced/shadow-mapping/\"\n    />\n  </Layout>\n);\n\nexport default TransparencyPage;\n","export const webglCode = `\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n`;\n","export const directxCode = `\nvoid enableBlending() {\n  d3dDevice->SetRenderState(D3DRS_ALPHABLENDENABL, TRUE);\n  d3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR);\n  d3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);\n}\n`;\n"],"names":["vertexShaderSource","fragmentShaderSource","shaderProgramInfo","vertex","attributeLocations","vertexPosition","vertexColor","uniformLocations","mvpMatrix","cubeModelPosition","mat4","wrapExample","TransparencyFirstExample","cube","vertices","colors","indices","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","cubeBuffer","updateCubeBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","createElementArrayBuffer","shouldRender","renderScene","renderSceneOrtho","_ref","gl","orthoMatrix","viewMatrix","modelMatrix","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","reverse","FLOAT","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","useProgram","uniformMatrix4fv","drawElements","TRIANGLES","length","UNSIGNED_SHORT","requestAnimationFrame","React","className","style","padding","width","height","ref","trim","TransparenceySecondExample","TransparencyThirdExample","location","pathname","Layout","Seo","title","description","keywords","Content","GlslCodeHighlight","code","type","GenericCodeHighlight","language","Heading","TransparencySecondExample","href","target","rel","PageChange","previous","next"],"sourceRoot":""}