{"version":3,"file":"component---src-pages-intermediates-image-generation-js-db9722606bb210aa4aa8.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/intermediates/image-generation/common/vertex.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/eighth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/eighth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/eighth-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/fifth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/fifth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/fifth-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/first-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/first-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/first-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/fourth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/fourth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/fourth-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/ninth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/ninth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/ninth-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/second-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/second-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/second-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/seventh-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/seventh-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/seventh-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/sixth-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/sixth-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/sixth-example.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/third-example-shaders.js","webpack://shader-tutorial/./src/components/intermediates/image-generation/third-example/fragment.glsl","webpack://shader-tutorial/./src/components/intermediates/image-generation/third-example.js","webpack://shader-tutorial/./src/pages/intermediates/image-generation.js"],"sourcesContent":["export default \"attribute vec4 vertexPosition;\\n\\nvoid main() {\\n  gl_Position = vertexPosition;\\n}\";","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./eighth-example/fragment.glsl\";\n\nexport const eighthVertexShaderSource = vertexShader;\nexport const eighthFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nhighp float random(highp vec2 coords) {\\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\\n\\n  highp vec2 randomizedBlockCenter = vec2(mix(0.1, 0.9, random(tileCoord / tilingResolution)));\\n\\n  highp float distanceFromCenter = distance(randomizedBlockCenter, blockCoordinates);\\n  highp float centerFactor = 1.0 - distanceFromCenter;\\n\\n  highp float fragmentColor = pow(centerFactor, 2.0);\\n  gl_FragColor = vec4(vec3(fragmentColor), 3);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { eighthFragmentShaderSource, eighthVertexShaderSource } from \"./eighth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationEighthExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          eighthVertexShaderSource,\n          eighthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationEighthExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./fifth-example/fragment.glsl\";\n\nexport const fifthVertexShaderSource = vertexShader;\nexport const fifthFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCenter = vec2(0.5, 0.5);\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n\\n  highp float distanceFromCenter = distance(blockCenter, blockCoordinates);\\n  highp float centerFactor = 1.0 - distanceFromCenter;\\n\\n  highp vec2 coordFromCenter = abs(blockCenter - blockCoordinates);\\n  highp float distanceFromDiagonals = abs(coordFromCenter.x - coordFromCenter.y);\\n  highp float diagonalFactor = 1.0 - distanceFromDiagonals;\\n\\n  highp float fragmentColor = pow(diagonalFactor * centerFactor, 3.0);\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fifthFragmentShaderSource, fifthVertexShaderSource } from \"./fifth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationFifthExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          fifthVertexShaderSource,\n          fifthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationFifthExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./first-example/fragment.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nvoid main() {\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp float fragmentColor = coordinates.x * coordinates.y;\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationFirstExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationFirstExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./fourth-example/fragment.glsl\";\n\nexport const fourthVertexShaderSource = vertexShader;\nexport const fourthFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCenter = vec2(0.5, 0.5);\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n\\n  highp vec2 coordFromCenter = abs(blockCenter - blockCoordinates);\\n  highp float distanceFromDiagonals = abs(coordFromCenter.x - coordFromCenter.y);\\n  highp float diagonalFactor = 1.0 - distanceFromDiagonals;\\n\\n  highp float fragmentColor = pow(diagonalFactor, 3.0);\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { fourthFragmentShaderSource, fourthVertexShaderSource } from \"./fourth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationFourthExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          fourthVertexShaderSource,\n          fourthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationFourthExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./ninth-example/fragment.glsl\";\n\nexport const ninthVertexShaderSource = vertexShader;\nexport const ninthFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nhighp float random(highp vec2 coords) {\\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nhighp float invert_step(highp float edge, highp float x) {\\n  return 1.0 - step(edge, x);\\n}\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCenter = vec2(0.5, 0.5);\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\\n\\n  highp vec2 coordFromCenter = blockCenter - blockCoordinates;\\n  highp float distanceFromDiagonal1 = abs(coordFromCenter.x - coordFromCenter.y);\\n  highp float distanceFromDiagonal2 = abs(coordFromCenter.x + coordFromCenter.y);\\n\\n  highp float diagonal1Color = (1.0 - distanceFromDiagonal1);\\n  highp float diagonal2Color = (1.0 - distanceFromDiagonal2);\\n\\n  highp float randomFactor = random(tileCoord / tilingResolution);\\n\\n  highp float diagonal1Factor = step(0.5, randomFactor) * diagonal1Color;\\n  highp float diagonal2Factor = invert_step(0.5, randomFactor) * diagonal2Color;\\n  // highp float diagonal1Factor = step(0.4, randomFactor) * diagonal1Color;\\n  // highp float diagonal2Factor = invert_step(0.6, randomFactor) * diagonal2Color;\\n  highp float diagonalFactor = max(diagonal1Factor, diagonal2Factor);\\n\\n  highp float fragmentColor = pow(diagonalFactor, 3.0);\\n  gl_FragColor = vec4(vec3(fragmentColor), 3);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { ninthFragmentShaderSource, ninthVertexShaderSource } from \"./ninth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationNinthExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          ninthVertexShaderSource,\n          ninthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" hninth=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationNinthExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./second-example/fragment.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n\\n  highp float fragmentColor = blockCoordinates.x * blockCoordinates.y;\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationSecondExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationSecondExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./seventh-example/fragment.glsl\";\n\nexport const seventhVertexShaderSource = vertexShader;\nexport const seventhFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nhighp float random(highp vec2 coords) {\\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\\n\\n  highp float fragmentColor = random(tileCoord / tilingResolution);\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { seventhFragmentShaderSource, seventhVertexShaderSource } from \"./seventh-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationSeventhExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          seventhVertexShaderSource,\n          seventhFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationSeventhExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./sixth-example/fragment.glsl\";\n\nexport const sixthVertexShaderSource = vertexShader;\nexport const sixthFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nhighp float random(highp vec2 coords) {\\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\\n}\\n\\nvoid main() {\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp float fragmentColor = random(coordinates);\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { sixthFragmentShaderSource, sixthVertexShaderSource } from \"./sixth-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationSixthExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          sixthVertexShaderSource,\n          sixthFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationSixthExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./third-example/fragment.glsl\";\n\nexport const thirdVertexShaderSource = vertexShader;\nexport const thirdFragmentShaderSource = fragmentShader;\n","export default \"uniform highp vec2 resolution;\\n\\nvoid main() {\\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\\n\\n  highp vec2 blockCenter = vec2(0.5, 0.5);\\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\\n\\n  highp float distanceFromCenter = distance(blockCenter, blockCoordinates);\\n  highp float centerFactor = 1.0 - distanceFromCenter;\\n\\n  highp float fragmentColor = pow(centerFactor, 3.0);\\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { thirdFragmentShaderSource, thirdVertexShaderSource } from \"./third-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {},\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      resolution: \"vec2\",\n    },\n  },\n};\n\nconst screenModelPosition = mat4.create();\n\nconst RandomImageGenerationThirdExample = () => {\n  const screen = {\n    vertices: [\n      [-1.0, -1.0, 0.0],\n      [-1.0, 1.0, 0.0],\n      [1.0, -1.0, 0.0],\n      [1.0, 1.0, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [screenBuffer, updateScreenBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        screenModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          thirdVertexShaderSource,\n          thirdFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateScreenBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          screen.vertices.flat(),\n          screenBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(screenBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(({ gl, resolution }) => {\n          if (!shouldRender) {\n            return;\n          }\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, screenBuffer.vertices);\n          gl.vertexAttribPointer(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n            3,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n          gl.enableVertexAttribArray(\n            shaderInfo.vertex.attributeLocations.vertexPosition,\n          );\n\n          gl.useProgram(shaderProgram);\n\n          gl.uniform2fv(\n            shaderInfo.fragment.uniformLocations.resolution,\n            resolution,\n          );\n\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, screen.vertices.length);\n\n          requestAnimationFrame(renderScene);\n        });\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [screenBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n    </div>\n  );\n};\n\nexport default wrapExample(RandomImageGenerationThirdExample);\n","import { Link } from \"gatsby\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport Content from \"../../components/content\";\nimport Equation from \"../../components/equation/equation\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport RandomImageGenerationEighthExample from \"../../components/intermediates/image-generation/eighth-example\";\nimport { eighthFragmentShaderSource } from \"../../components/intermediates/image-generation/eighth-example-shaders\";\nimport RandomImageGenerationFifthExample from \"../../components/intermediates/image-generation/fifth-example\";\nimport { fifthFragmentShaderSource } from \"../../components/intermediates/image-generation/fifth-example-shaders\";\nimport RandomImageGenerationFirstExample from \"../../components/intermediates/image-generation/first-example\";\nimport {\n  firstFragmentShaderSource,\n  firstVertexShaderSource,\n} from \"../../components/intermediates/image-generation/first-example-shaders\";\nimport RandomImageGenerationFourthExample from \"../../components/intermediates/image-generation/fourth-example\";\nimport { fourthFragmentShaderSource } from \"../../components/intermediates/image-generation/fourth-example-shaders\";\nimport RandomImageGenerationNinthExample from \"../../components/intermediates/image-generation/ninth-example\";\nimport { ninthFragmentShaderSource } from \"../../components/intermediates/image-generation/ninth-example-shaders\";\nimport RandomImageGenerationSecondExample from \"../../components/intermediates/image-generation/second-example\";\nimport { secondFragmentShaderSource } from \"../../components/intermediates/image-generation/second-example-shaders\";\nimport RandomImageGenerationSeventhExample from \"../../components/intermediates/image-generation/seventh-example\";\nimport { seventhFragmentShaderSource } from \"../../components/intermediates/image-generation/seventh-example-shaders\";\nimport RandomImageGenerationSixthExample from \"../../components/intermediates/image-generation/sixth-example\";\nimport { sixthFragmentShaderSource } from \"../../components/intermediates/image-generation/sixth-example-shaders\";\nimport RandomImageGenerationThirdExample from \"../../components/intermediates/image-generation/third-example\";\nimport { thirdFragmentShaderSource } from \"../../components/intermediates/image-generation/third-example-shaders\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst ImageGenerationPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Intermediates - Image Generation\"\n      description=\"A look into the how images can be generated using noise and patterns.\"\n      keywords={[\n        \"image\",\n        \"generation\",\n        \"noise\",\n        \"patterns\",\n        \"shader\",\n        \"intermediates\",\n      ]}\n    />\n    <Content>\n      <h1>Shader Intermediates - Image Generation</h1>\n      <p>\n        While images can be generated to render objects passed to a GPU, images\n        can also be generated where the image is drawn over the entire screen,\n        with the help of some logic for what color each pixel should be. Noise\n        can also be added in to the image to change the end result.\n      </p>\n      <p>\n        These generated images can be used as the final image to show to users,\n        or can be stored as a texture for use somewhere else, such as to color\n        the surface of a particular object.\n      </p>\n      <p>\n        Certain applications do generate textures using shaders instead of\n        having raw image files in order to save space or have a dynamic\n        resolution for its textures depending on the system it is running on.\n      </p>\n      <p>\n        Images can also be passed as textures to these shaders, which can then\n        apply filters or effects on such images, such as bluring, pixelating,\n        changing color temperature (warm/cool), etc.\n      </p>\n      <p>\n        Since vertices are still required to be sent to the vertex shader, the\n        vertices passed are:\n      </p>\n      <p className=\"util text-center\">\n        <Equation text={`vertices = ((-1, -1), (-1, 1), (1, 1), (1, -1))`} />\n      </p>\n      <p>\n        These four coordinates map to the vertices of the frame, so the vertex\n        shader returns the vertex value as it receives it. No modifications are\n        done to the received vertex since the passed vertices are already in the\n        form of clip-space coordinates.\n      </p>\n      <GlslCodeHighlight code={firstVertexShaderSource.trim()} type=\"Vertex\" />\n      <Heading type=\"h2\">Example - A coordinate gradient</Heading>\n      <RandomImageGenerationFirstExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={firstFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        This fragment shader generates a gradient that's darkest at one corner\n        and brightest at the opposite corner. The darkest corner will always be\n        at the origin, since that is the point where the coordinates of the\n        pixel will be 0 (or at least nearest to 0).\n      </p>\n      <p>\n        In GLSL, the coordinates of the current fragment can be accessed through\n        the <code>gl_FragCoord</code> constant. It contains the position of the\n        fragment as the X and Y values, and the depth of the fragment as the Z\n        value.\n      </p>\n      <p>\n        In cases where a single fragment is generated per pixel, the position of\n        this fragment will be the coordinates of the center of the pixel the\n        fragment belongs to.\n      </p>\n      <p>\n        This means that a fragment belonging to the lower-left most pixel, the\n        coordinates of the fragment is <Equation text={`(0.5, 0.5)`} />, when\n        the location of the pixel itself is <Equation text={`(0, 0)`} />.\n      </p>\n      <p>\n        The coordinates of the fragments range from <Equation text={`(0, 0)`} />{\" \"}\n        to the width and height of the frame. In order to normalize these\n        coordinates down to a range from 0 - 1, we can receive the total\n        resolution of the frame from outside the shader (the shader by default\n        has no way of knowing the resolution of the frame).\n      </p>\n      <p>\n        The fragment coordinates can then be divided by the resolution to get\n        the normalized coordinates of the fragment within the range from 0 - 1,\n        which can make calculations simpler since we now work within a constant\n        range.\n      </p>\n      <p>\n        The color of the fragment is simply set as the product of the normalized\n        X and Y coordinates of the fragment, and in grayscale (since R, G, and B\n        components are all set to the same value).\n      </p>\n      <p>\n        From this render, we can see that the origin of the X and Y axis is at\n        the lower-left corner. The value of X increases as you move right, and\n        the value of Y increases as you go up.\n      </p>\n      <p>Let's now look at the next example, where we tile the image.</p>\n      <Heading type=\"h2\">Example - A tiled coordinate gradient</Heading>\n      <RandomImageGenerationSecondExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Tiling an image is pretty simple. The image needs to be split into\n        blocks, and then each block can have operations performed on it.\n      </p>\n      <p>\n        As the fragment shader can only work on individual fragments, two values\n        need to be calculated for each of them:\n      </p>\n      <ul>\n        <li>The tile the fragment belongs to</li>\n        <li>\n          The position of the fragment within that tile (in the form of\n          normalized coordinates).\n        </li>\n      </ul>\n      <p>\n        Once these values are known, applying operations on each tile (or block)\n        is simple.\n      </p>\n      <p>\n        In order to understand how the math would work, let's look at the\n        current image that we have.\n      </p>\n      <p>\n        The current image we have is made up of pixels. The position of these\n        pixels can be easily determined. Taking an image of resolution{\" \"}\n        <Equation text={`(99, 99)`} />, if we consider the screen as a graph and\n        the lower-left corner pixel as the origin, then the center pixel would\n        be located at <Equation text={`(49, 49)`} />.\n      </p>\n      <p>\n        Similarly, the coordinates of the top-right corner would{\" \"}\n        <Equation text={`(98, 98)`} />, the coordinates of the top-left corner\n        would be <Equation text={`(0, 98)`} />, the coordinates of the\n        bottom-right corner would be <Equation text={`(0, 98)`} />, and the\n        coordinates of the bottom-left corner would be{\" \"}\n        <Equation text={`(0, 0)`} /> (since that's the origin).\n      </p>\n      <p>\n        We know that pixels contain multiple fragments. For this current\n        situation, let's consider each pixel only containing one fragment, with\n        its position at the center of the pixel.\n      </p>\n      <p>\n        Our previous explanation assumes that pixels are point sized (they have\n        no area). However, in reality, they do occupy a region of space, just\n        like tiles.\n      </p>\n      <p>\n        This means that the coordinates of the pixels don't exactly represent\n        the position of that pixel, but instead a particular part of that pixel.\n        As is with graphs and plotting, the coordinates of the pixel represents\n        where the lower-left corner of the pixel is positioned.\n      </p>\n      <p>\n        Since fragments belong to a particular pixel, their position is\n        generally determined relative to each pixel.\n      </p>\n      <p>\n        Since the coordinates of each pixel in an image is represented as an\n        integer, the coordinates of the fragments within the pixel can be\n        represented as decimal values of the integer coordinates.\n      </p>\n      <p>\n        For example, with the center pixel in our previous example, the\n        coordinates\n        <Equation text={`(49, 49)`} /> now represents the lower-left corner of\n        that pixel. As the position of the fragment lies at the center of the\n        pixel, its coordinates would become:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`\"fragment coordinates\" = (49 + 0.5, 49 + 0.5) = (49.5, 49.5)`}\n        />\n      </p>\n      <p>\n        <em>\n          Note: Since the coordinates of two consecutive pixels will have a\n          difference of 1, a fragment within a pixel has to have coordinates\n          within the range of 0 to 1 (excluding 1, including 0). As the fragment\n          in our example is at the centre, its coordinates would be{\" \"}\n          <Equation text={`50% \"of 1\" = 0.5`} />.\n        </em>\n      </p>\n      <p>Here we notice two interesting properties:</p>\n      <ul>\n        <li>\n          The integral part of the coordinates represents the pixel position.\n        </li>\n        <li>\n          The decimal part of the coordinates represents the fragment position\n          within that pixel. They are also considered as normalized coordinates\n          of the fragment w.r.t that pixel (we'll look into that later).\n        </li>\n      </ul>\n      <p>\n        An important note about these coordinates is that they are dependent on\n        the resolution of the image, which is <Equation text={`(99, 99)`} />.\n        This is evident through a simple check.\n      </p>\n      <p>\n        We saw that the coordinates of the center pixel of the image is{\" \"}\n        <Equation text={`(49, 49)`} />. However, the coordinates are relative to\n        the size of the image itself. If the size of the image changes, the\n        coordinates of the center pixel would also change.\n      </p>\n      <p>\n        These coordinates need to be converted into a format such that they are\n        no longer dependent on the resolution of the image. By doing so, the\n        coordinates become \"normalized\", and are independent of any resolution.\n      </p>\n      <p>\n        The value of the components of normalized coordinates is always within\n        the range of 0 to 1 (excluding 1, including 0).\n      </p>\n      <p>\n        This can be done through a simple division operation of the pixel\n        coordinates and the resolution of the image. The calculation is:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`text(normalized coordinates) = (text(pixel coordinates)_x / text(image resolution)_x, text(pixel coordinates)_y / text(image resolution)_y)`}\n        />\n      </p>\n      <p>\n        Once the normalized coordinates of any pixel are known, the coordinates\n        of a pixel relative to any screen resolution can be determined through\n        multiplication:\n      </p>\n      <p className=\"util text-center\">\n        <Equation\n          text={`text(new coordinates) = (text(pixel coordinates)_x / text(new resolution)_x, text(pixel coordinates)_y / text(new resolution)_y)`}\n        />\n      </p>\n      <p>\n        Now consider the pixels as tiles. Tiles have area as well, similar to\n        pixels as we've discussed. So this allows us to map the concepts\n        discussed so far into tiles.\n      </p>\n      <p>\n        Tiles also contain a group of points, similar to the concept of pixels,\n        where a fragment is be considered a point, and a pixel is considered a\n        group of fragments, in this case there being only one fragment in the\n        center.\n      </p>\n      <p>\n        By normalizing the coordinates of a fragment, all the fragments from the\n        original image are grouped into an image that is one pixel in size.\n      </p>\n      <p>\n        This is evident by looking at the value of the components of the\n        normalized coordinates. These coordinates will always have the integral\n        component set to 0, which means that they all belong to the same pixel.\n        It is the decimal component that determines where they are located\n        within that pixel.\n      </p>\n      <p>\n        If we took an image of resolution <Equation text={`(100, 100)`} /> with\n        one fragment per pixel, when the fragment coordinates are normalized,\n        the fragments are now simply mapped onto an image of resolution{\" \"}\n        <Equation text={`(1, 1)`} />.\n      </p>\n      <p>\n        This means the pixel in this \"new image\" will contain all the fragments\n        of the original image, which is{\" \"}\n        <Equation text={`100 times 100 = 10000`} />. The location of all these\n        fragments within that pixel are determined from the decimal part of the\n        values of the coordinates.\n      </p>\n      <p>\n        By multiplying the normalized coordinates against another resolution,\n        these fragments are again spread across all the pixels in that\n        resolution. This can result in a change in the number of fragments per\n        pixel, depending upon the new resolution.\n      </p>\n      <p>\n        This is also evident from the resultant coordinates. The integral part\n        of the coordinates will indicate which pixel the fragment belongs to,\n        and the decimal part indicates where they are located within that pixel.\n      </p>\n      <p>\n        If the fragments from the example are now spread across an image of\n        resolution <Equation text={`(10, 10)`} />, then each pixel in the new\n        image will contain{\" \"}\n        <Equation text={`10000 / (10 times 10) = 10000 / 100 = 100`} />{\" \"}\n        fragments.\n      </p>\n      <p>\n        A fragment present within pixel of coordinates{\" \"}\n        <Equation text={`(5, 5)`} /> will have coordinates{\" \"}\n        <Equation text={`(\"5.x\", \"5.y\")`} />, where <Equation text={`\"x\"`} />{\" \"}\n        and <Equation text={`\"y\"`} /> are the decimal parts that tell the\n        location of the fragment within that pixel.\n      </p>\n      <p>\n        We initially noted that the decimal part of the coordinates are the\n        normalized coordinates of the fragment. The reason for this is simple.\n      </p>\n      <p>\n        We've just discussed how with normalized coordinates, the integral part\n        is always constant, with the decimal part noting the actual location.\n      </p>\n      <p>\n        Similarly, with the fragment coordinates, since the decimal part\n        determines where within a specific pixel the fragment is located, it can\n        be considered as the normalized coordinates relative to the pixel the\n        fragment belongs to.\n      </p>\n      <p>\n        The concept of tiling uses these principles, with a tile representing a\n        pixel. When the coordinates of a fragment is normalized, it is grouped\n        into a single tile.\n      </p>\n      <p>\n        By multiplying this normalized coordinates with the \"tiling resolution\"\n        (number of tiles across the screen, similar to screen resolution and\n        pixels), the fragment is then placed into the tile that it should belong\n        to.\n      </p>\n      <p>\n        Using the final coordinates of the fragment (which we'll refer to as the\n        tiling coordinates), we can:\n      </p>\n      <ul>\n        <li>\n          Determine the tile the fragment is present in by looking at the\n          integral part of its tiling coordinates (which we'll refer to as tile\n          coordinates).\n        </li>\n        <li>\n          Determine its location within a tile (normalized coordinates w.r.t the\n          tile) by looking at the decimal part of its tiling coordinates (which\n          we'll refer to as tile normalized coordinates).\n        </li>\n      </ul>\n      <GlslCodeHighlight\n        code={secondFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        Looking at our code, we can see the application of the discussed\n        concepts. We set a tiling resolution of (\n        <Equation text={`(12.0, 9.0)`} />\n        ). The normalized coordinates of the fragment are then calculated.\n      </p>\n      <p>\n        The tiling coordinates of the fragment w.r.t. the tiling resolution is\n        then calculated through the multiplication operation.\n      </p>\n      <p>\n        However, for the color of the fragment, we only care about its tile\n        normalized coordinates, so we grab the decimal component of the\n        resultant coordinates.\n      </p>\n      <p>\n        In GLSL, this can be done using the built-in function <code>fract</code>\n        .\n      </p>\n      <p>\n        <em>\n          Note: In the shader code, any values w.r.t a parent tile will be\n          prefixed with <code>block</code>. Any values w.r.t the all tiles will\n          be prefixed with <code>tile</code>\n        </em>\n        . This is done to differentiate between them.\n      </p>\n      <p>\n        The tile normalized coordinates are then used to calculate the color of\n        the fragment, just like in the first example.\n      </p>\n      <p>Next, let's draw something else within the tiles.</p>\n      <Heading type=\"h2\">\n        Pattern Example - A tiled pattern with glowing center\n      </Heading>\n      <RandomImageGenerationThirdExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Now equipped with the information on how to tile an image, and get the\n        necessary values required to work within a tile, we can start drawing\n        within tiles.\n      </p>\n      <p>\n        The algorithm for drawing a glowing circle that dims as you move towards\n        the edge is simple:\n      </p>\n      <ul>\n        <li>\n          Determine the tile normalized coordinates for the center of the\n          circle.\n        </li>\n        <li>\n          Calculate the distance of the current fragments' tile normalized\n          coordinates from the center.\n        </li>\n        <li>\n          The distance from the center determines the brightness of the\n          fragment. The closer a fragment is to the center, the brighter it will\n          be.\n        </li>\n      </ul>\n      <GlslCodeHighlight\n        code={thirdFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        First, we need to determine the tile normalized coordinates center of a\n        tile. In a tile, the tile normalized coordinates of the center would be{\" \"}\n        <Equation text={`(0.5, 0.5)`} />, since the center would be located at\n        the 50% width and height mark of a tile.\n      </p>\n      <p>\n        We can then calculate the distance between the fragment and the center\n        of the tiles using their normalized coordinates. In GLSL, a built-in\n        function exists that can provide this value, called{\" \"}\n        <code>distance</code>.\n      </p>\n      <p>\n        Since we wish for fragments closer to the center of the tile to be\n        brighter, we calculate the factor for the brightness as 1.0 (which is\n        the maximum possible brightness) minus the distance of the fragment from\n        the center.\n      </p>\n      <p>\n        The result of this factor is stored in a variable called{\" \"}\n        <code>centerFactor</code>, since this brightness factor is based around\n        the center of the tile.\n      </p>\n      <p>\n        This brightness factor can now be set as the grayscale color of the\n        fragment. This will result in fragments further away from the center of\n        the tile becoming brighter.\n      </p>\n      <p>\n        One thing to note is that the brightness factor is multiplied to the\n        power of 3 (using the GLSL function <code>pow</code>), which is then set\n        as the grayscale color of the fragment.\n      </p>\n      <p>\n        There are two reasons this was done, and are also interlinked with each\n        other:\n      </p>\n      <ul>\n        <li>\n          It increases the range of brightness values that are possible for the\n          fragments.\n        </li>\n        <li>\n          It increases the dropoff in brightness exponentially with distance.\n        </li>\n      </ul>\n      <p>\n        Without using <code>pow</code>, the possible range for the brightness\n        values of fragments would be 1.0 - 0.3.\n      </p>\n      <ul>\n        <li>\n          Points at the center would have a distance of 0, their brightness\n          would be 1.0.\n        </li>\n        <li>\n          Points at the edges of a tile would have a maximum distance of 0.7\n          (the distance of the corners from the center), making their brightness\n          factor go down to 0.3.\n        </li>\n      </ul>\n      <p>\n        By multiplying the factor by the power of 3, this range increases\n        dramatically, to 1.0 - 0.027, since the lowest possible brightness gets\n        cubed.\n      </p>\n      <p>\n        This also means that the dropoff in brightness increases exponentially\n        with distance from the center. Since the edges are now darker, the\n        fragments in between will drop off in brightness a lot more to maintain\n        the transition and range.\n      </p>\n      <p>\n        Use this trick to your advantage if you need to exaggerate color values\n        of your fragments.\n      </p>\n      <Heading type=\"h2\">\n        Pattern Example - A tiled pattern with glowing diagonals\n      </Heading>\n      <RandomImageGenerationFourthExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Drawing a pattern of diagonal lines across a tile may seem complex but,\n        looking at the mathematics, we'll see that it's much more simple than it\n        appears to be.\n      </p>\n      <p>\n        In this pattern, we wish for fragments to grow dimmer the further they\n        are from a either diagonal line. This requires calculating the distance\n        of the fragment from either diagonal.\n      </p>\n      <p>\n        In our image, we are dealing with square tiles, so all our calculations\n        will be respective to that particular shape. For non-square tiles, the\n        calculations may differ slightly, but the same requirement exists.\n      </p>\n      <p>\n        Let's take the center of the tile as the origin of the graph. The tile\n        is a square, and the tile normalized coordinates of the center of the\n        tile is <Equation text={`(0.5, 0.5)`} />. This results in the boundaries\n        of the tile in our graph being 0.5 units away from the origin.\n      </p>\n      <p>The plot for this would be:</p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/tile-plot.png\"\n          alt=\"Tile Graph Plot\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        <a\n          href=\"https://www.transum.org/Maths/Activity/Graph/Desmos.asp\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Image Generation Source\n        </a>\n      </div>\n      <p>\n        Adding the diagonals of the tile to the graph would result in the plot:\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/tile-diagonal-plot.png\"\n          alt=\"Tile With Diagonals Graph Plot\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        <a\n          href=\"https://www.transum.org/Maths/Activity/Graph/Desmos.asp\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Image Generation Source\n        </a>\n      </div>\n      <p>\n        Here, we can notice a peculiar property of diagonals - the absolute\n        values of the X and Y coordinates of points on the diagonal are always\n        equal. This can be easily verified from the plot generated above.\n      </p>\n      <p>\n        So in order to determine if a point is on a diagonal line, we just need\n        to find the difference between the absolute values of its X and Y\n        coordinates. If it's zero, then we know it is on the diagonal.\n      </p>\n      <p>\n        This subtraction calculation also provides us with another info - an\n        approximate distance from the closest diagonal line.\n      </p>\n      <p>\n        Any point that has a difference greater than zero between its X and Y\n        coordinates are known to be present outside the line. This difference\n        provides us with an approximation of how far away the point is.\n      </p>\n      <p>\n        It will, in many cases, not equal to the closest distance between a\n        point and the closest diagonal line, but for our purposes it is a good\n        enough approximation.\n      </p>\n      <p>\n        Now that we can calculate the distance of a fragment from the closest\n        diagonal line, we can apply the same principles we learnt from the\n        previous shader example.\n      </p>\n      <GlslCodeHighlight\n        code={fourthFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        The first few lines in the shader are similar to the previous shader\n        example. After that, we first determine the tile normalized coordinates\n        of the fragment.\n      </p>\n      <p>\n        This is done through simple subtraction of the tile normalized\n        coordinates of the center of the tile from the tile normalized\n        coordinates of the fragment, thanks to the properties of vector\n        mathematics.\n      </p>\n      <p>\n        Since we don't care about the signs of the X and Y coordinates of the\n        fragment, just their absolute values, we remove the signs from the\n        resulting coordinates calculation. In GLSL, the built-in function{\" \"}\n        <code>abs</code> achieves this operation.\n      </p>\n      <p>\n        Next we determine the distance of the point from the diagonal through\n        the subtraction of the X and Y coordinates of the fragment. Only the\n        absolute value of this result matters, hence the use of the{\" \"}\n        <code>abs</code> function again.\n      </p>\n      <p>\n        Since the smaller this distance is, the closer the fragment is to the\n        diagonal, this value is subtracted from 1.0 so that points closer to the\n        diagonal are brighter (similar to the previous shader example).\n      </p>\n      <p>\n        This result is stored in a variable called <code>diagonalFactor</code>,\n        since this brightness factor is based on the distance from the diagonal.\n      </p>\n      <p>\n        From this point onwards, it is again similar to the previous shader -\n        using the brightness value to set the grayscale color of the fragment,\n        and exaggerating the color difference using <code>pow</code>.\n      </p>\n      <p>\n        Any pattern drawing that depends on tiling works on the same basics as\n        the two patterns shown - splitting the image into tiles, and then\n        operating within a single tile using the tile normalized coordinates.\n      </p>\n      <p>\n        A pattern may not necessarily be created through a completely unique set\n        of rules. Multiple patterns can be combined to form new patterns that\n        produce interesting effects.\n      </p>\n      <p>\n        Let's look at an example where we combine our previous two patterns into\n        one and see the results.\n      </p>\n      <Heading type=\"h2\">Pattern Example - A tiled combination pattern</Heading>\n      <RandomImageGenerationFifthExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={fifthFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        In this example, we can see that we perform the calculations for the\n        center brightness factor and diagonal brightness factor exactly as shown\n        previously.\n      </p>\n      <p>\n        The results of these two factors are combined (or merged) through a\n        multiplication operation. This results in the image that you see above.\n      </p>\n      <p>Looking at the image, you can see the effects of both factors:</p>\n      <ul>\n        <li>\n          The diagonal lines are visible, but are sharpened at the edges due to\n          the effect of the center brightness factor.\n        </li>\n        <li>\n          The brightness decreases closer to the edges of the tiles, but it\n          produces a more \"square-ish\" shape than a circular one due to the\n          diagonal brightness factor.\n        </li>\n      </ul>\n      <p>\n        Here we see the effects of both the diagonal brightness factor and\n        center brightness factor, but neither dominating over each other. The\n        reason for this is due to the multiplication operation.\n      </p>\n      <p>\n        A question that might be raised is why addition wasn't used instead.\n        Addition is an operation that basically stacks such effects, but doesn't\n        \"combine\" them into one.\n      </p>\n      <p>\n        Here's an analogy to explain the effects of addition and multiplication:\n      </p>\n      <ul>\n        <li>\n          Addition is like taking a cake, applying a layer of frosting over it,\n          and then adding a layer of chocolate sprinkles on top.\n          <ul>\n            <li>\n              The frosting and sprinkles are in visibly separate layers, with\n              the texture properties of both present only in their respective\n              layers.\n            </li>\n            <li>The frosting and sprinkles can be separated with ease.</li>\n            <li>\n              If enough sprinkles are spread evenly enough across the frosting,\n              it can obscure a majority of the frosting from the view.\n            </li>\n          </ul>\n        </li>\n        <li>\n          Multiplication is like taking a bowl, putting in the frosting and\n          chocolate sprinkles, and mixing it together into one mixture, and then\n          layering this mixture on top of the cake.\n          <ul>\n            <li>\n              The mixture combines the texture of the frosting and the\n              sprinkles.\n            </li>\n            <li>\n              The frosting and sprinkles are relatively much harder to separate.\n            </li>\n            <li>\n              A relatively much larger ratio of sprinkles vs frosting is\n              required to obscure the frosting.\n            </li>\n          </ul>\n        </li>\n      </ul>\n      <p>\n        By performing an addition operation between the two factors, one factor\n        could completely dominate over the other in certain fragments, and\n        appear to stack over each other instead.\n      </p>\n      <p>\n        By contrast, performing a multiplication operation \"melds\" the two\n        factors together into a result where being able to separate the\n        individual effects is harder to do visually.\n      </p>\n      <p>\n        In these types of cases, an addition operation stacks effects and\n        factors, whereas a multiplication operation mixes effects and factors\n        into one.\n      </p>\n      <p>\n        The effects of multiplication and addition for combining and stacking\n        effects will be more apparent in the{\" \"}\n        <Link to=\"/intermediates/lighting/\">\n          lighting and dithering chapter\n        </Link>\n        .\n      </p>\n      <p>\n        So far, we've looked into images generated through the use of patterns,\n        specifically tiling and patterns within tiles. Next, let's look at how\n        images can be generated using randomness and noise.\n      </p>\n      <Heading type=\"h2\">Randomness Example - Random noise</Heading>\n      <RandomImageGenerationSixthExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={sixthFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        In this example, for each fragment a random number is generated within\n        the range of 0 - 1 (excluding 1, including 0). For this, a user-defined{\" \"}\n        <code>random</code> was used to create a number from given 2D\n        coordinates.\n      </p>\n      <p>\n        The function is provided with the normalized coordinates of the fragment\n        as a parameter, and the random number returned is used as the grayscale\n        color value for the fragment.\n      </p>\n      <p>\n        The <code>random</code> function used here will always generate the same\n        random number given the same input, which allows for consistency.\n      </p>\n      <p>\n        However, if it is required to always be unique, modifying the passed 2D\n        coordinates with the current time can be done to make sure a new random\n        value is generated for every render.\n      </p>\n      <p>\n        <em>\n          Note: The random function code was taken from{\" \"}\n          <a\n            href=\"https://github.com/PistonDevelopers/shaders/wiki/Some-useful-GLSL-functions\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            this GitHub Wiki page\n          </a>\n          .\n        </em>\n      </p>\n      <Heading type=\"h2\">\n        Randomness Example - A tiled pattern of random (grayscale) colors\n      </Heading>\n      <RandomImageGenerationSeventhExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={seventhFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        For setting up a tile of random grayscale colors, we first setup the\n        tiles as learnt in the previous pattern examples, but make certain\n        changes.\n      </p>\n      <p>\n        In the pattern examples, we were only concerned with working within the\n        block itself. So, when we generated the tile normalized coordinates of\n        the fragment (<code>coordinates * tilingResolution</code>\n        ), we ignored the integer component and only kept the decimal component\n        using the function <code>fract</code>.\n      </p>\n      <p>\n        However, in the current situation, we will use the tile coordinates of\n        the fragment to determine what color the tile will be. This requires the\n        integer part of the fragment coordinates to be taken, with the\n        fractional part ignored.\n      </p>\n      <p>\n        In GLSL, by using the built-in function <code>floor</code> to floor a\n        value (round a number to the nearest integer value at or below it), we\n        remove the decimal component of the coordinates.\n      </p>\n      <p>\n        The resultant coordinates are the tile coordinates of the fragment.\n        Next, this tiling coordinates needs to be converted into normalized\n        coordinates, since its value is currently dependent on the tiling\n        resolution.\n      </p>\n      <p>\n        By dividing the tile coordinates by the tiling resolution, we get back\n        the normalized coordinates of the tile itself (to be specific, the\n        lower-left corner of the tile).\n      </p>\n      <p>\n        These normalized coordinates are then passed to the <code>random</code>{\" \"}\n        function, whose returned value is then used as the grayscale color value\n        of the tile.\n      </p>\n      <p>\n        All fragments within a tile will have the same tile coordinates as they\n        all belong to the same tile. This means that they will generate the same\n        random number, ensuring that the entire tile is the same color.\n      </p>\n      <Heading type=\"h2\">\n        Combined Example - A tiled pattern with random centers\n      </Heading>\n      <RandomImageGenerationEighthExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={eighthFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        In this example, the concepts of the pattern example of glowing circles\n        is combined with the concepts of the random tile example to randomize\n        the position of the center of the circles.\n      </p>\n      <p>\n        In this example, instead of taking the standard tile normalized\n        coordinates of the center of the block <Equation text={`(0.5, 0.5)`} />,\n        we generate the tile normalized coordinate of the center randomly\n        instead.\n      </p>\n      <p>\n        We've seen in the previous example on how to generate a random number\n        for each tile. We then use this number to select a value within a range\n        of numbers.\n      </p>\n      <p>\n        In this example, the center will only be placed on the diagonal of the\n        tile that goes from the lower-left corner to the top-right corner, with\n        the range of its X and Y coordinates limited to 0.1 to 0.9. A value is\n        then selected within this range using the random number for the tile.\n      </p>\n      <p>\n        To select a value within the set range using the random number as a\n        factor, we can use a method called linear interpolation. But first,\n        let's see what linear interpolation is.\n      </p>\n      <p>\n        Let's consider a range 0.0 to 1.0. We need to get a number within this\n        range using a certain factor provided to us. From this factor, we figure\n        out how far into this range the number will be present, and return the\n        number at that point.\n      </p>\n      <p>\n        So if this value of this factor provided is 0.3, which is 30% in terms\n        of percentages. So, this factor tells us that we should move 30% across\n        the range of 0.0 - 1.0, starting at 0.0, and the number that is at this\n        30% mark should be returned.\n      </p>\n      <p>\n        The number that is present 30% away from 0.0 and 70% away from 1.0 would\n        be 0.3. Hence, the result of this calculation will be 0.3.\n      </p>\n      <p>\n        This method of generating a value by travelling through a certain range\n        of numbers by a certain factor, and returning the value at that point in\n        the range, is called linear interpolation.\n      </p>\n      <p>\n        The formula for this calculation is simple - given a range{\" \"}\n        <Equation text={`X - Y`} /> and a factor <Equation text={`F`} /> that is\n        within the range <Equation text={`0.0 - 1.0`} />, the formula is:\n      </p>\n      <p className=\"util text-center\">\n        <Equation text={`(X times (1 - F)) + (Y times F)`} />\n      </p>\n      <p>\n        In GLSL, a built-in function <code>mix</code> can perform this\n        calculation, which we use to calculate the value of the tile normalized\n        coordinates for our random center, with the X and Y components being the\n        same.\n      </p>\n      <p>\n        Once the random center is calculated, the rest of the process is similar\n        to the original glowing circle pattern example.\n      </p>\n      <p>\n        In this example, we modified the position of the center of the circle,\n        thereby displacing it from the center within the tile.\n      </p>\n      <p>\n        In the next example, let's look at how the random factor can be used to\n        make \"decisions\" on what should and should not be shown.\n      </p>\n      <Heading type=\"h2\">\n        Combined Example - A tiled pattern with random diagonals\n      </Heading>\n      <RandomImageGenerationNinthExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        In this example, either diagonal needs to be shown based upon the random\n        factor of the tile. First, let's take a look of the tile with diagonals\n        plot again.\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/intermediates/tile-diagonal-plot.png\"\n          alt=\"Tile With Diagonals Graph Plot\"\n          style={{ maxWidth: \"65%\" }}\n        />\n        <br />\n        <a\n          href=\"https://www.transum.org/Maths/Activity/Graph/Desmos.asp\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Image Generation Source\n        </a>\n      </div>\n      <p>\n        Let's name the diagonal starting from the lower-left corner and ending\n        at the upper-right corner <code>diagonal 1</code>, and name the other\n        diagonal <code>diagonal 2</code>.\n      </p>\n      <p>\n        For the initial diagonal example, we were ignoring the sign of the\n        values of the coordinates of the diagonal points, which simplified\n        calculations to see if a point was on either diagonal, or how far away\n        it was from either diagonal.\n      </p>\n      <p>\n        However, in the current example, we need to separately calculate the\n        distance from <code>diagonal 1</code> and <code>diagonal 2</code> and,\n        depending on which diagonal is to be shown, use either result.\n      </p>\n      <p>\n        For <code>diagonal 1</code>, both X and Y components of points on the\n        diagonal increase together. By finding the difference between the X and\n        Y components, we find the distance from <code>diagonal 1</code>, which\n        is similar to the original diagonal pattern example.\n      </p>\n      <p>\n        For <code>diagonal 2</code>, the X and Y components of points on the\n        diagonal progress in opposite directions. The X components increases and\n        the Y component decreases as you go from left to right, with the X\n        component starting at the lowest value, and the Y component starting at\n        the highest value.\n      </p>\n      <p>\n        This also means that the signs of the X and Y components of the points\n        on the diagonal are also always opposite to each other. Looking at the\n        points on <code>diagonal 2</code>, this becomes apparent.\n      </p>\n      <p>\n        The coordinates of the top-left corner the square, which is the one of\n        the ends of <code>diagonal 2</code>, has coordinates{\" \"}\n        <Equation text={`(-0.5, 0.5)`} />. Similarly, the coordinates of the\n        other end of the diagonal at the bottom-right corner are{\" \"}\n        <Equation text={`(0.5, -0.5)`} />.\n      </p>\n      <p>\n        This difference compared to <code>diagonal 1</code> means that the\n        calculation of the distance from <code>diagonal 2</code> has to be done\n        as an addition operation instead of a subtraction operation.\n      </p>\n      <p>\n        This change accounts for these differences and ensures that the result\n        of the calculation doesn't differ from what's expected.\n      </p>\n      <p>\n        Once the distance of the fragment from both diagonals are calculated, we\n        can use a decision factor to determine which one gets applied.\n      </p>\n      <GlslCodeHighlight\n        code={ninthFragmentShaderSource.trim()}\n        type=\"Fragment\"\n      />\n      <p>\n        Looking at the code, you can see the principles we've discussed so far\n        applied. For calculating the distance from <code>diagonal 1</code>, we\n        subtract the X and Y components of the fragment coordinates, same as our\n        initial diagonal pattern example.\n      </p>\n      <p>\n        For <code>diagonal 2</code>, instead of performing a subtraction\n        operation, we perform the addition operation instead, due to the nature\n        of the X and Y components having opposite signs in{\" \"}\n        <code>diagonal 2</code>.\n      </p>\n      <p>\n        Once these two are calculated, we then calculate what the color of the\n        fragment would be respective to each diagonal, which is similar to the\n        original diagonal pattern example. After this, we calculate the random\n        factor for the tile, and then decide which diagonal to show.\n      </p>\n      <p>\n        Let's define a threshold of 0.5 on the random factor. If the random\n        factor is below this threshold, then we'll show only{\" \"}\n        <code>diagonal 2</code>. However, if this is not the case, then{\" \"}\n        <code>diagonal 1</code> will be shown instead.\n      </p>\n      <p>\n        In GLSL, a built-in function called <code>step</code> allows us to\n        achieve this objective. It is provided with the threshold and the value\n        to check as parameters. If the value is below the threshold, it returns\n        0, or else it returns 1.\n      </p>\n      <p>\n        By multiplying this result with the appropriate diagonal color, we\n        cancel out the color value w.r.t diagonal that shouldn't be shown, and\n        only maintain the color value w.r.t the diagonal which should be shown.\n      </p>\n      <p>\n        For <code>diagonal 1</code>, it should only be shown if the random\n        factor exceeds the threshold of 0.5. So for this, the final factor for{\" \"}\n        <code>diagonal 1</code> was calculated by checking whether the random\n        factor was exceeding the threshold using <code>step</code>, and\n        multiplying that result with the color value w.r.t.{\" \"}\n        <code>diagonal 1</code>.\n      </p>\n      <p>\n        If the random factor is less than 0.5, <code>step</code> will return 0,\n        meaning that the effective color factor of <code>diagonal 1</code> is 0.\n      </p>\n      <p>\n        If the factor is above 0.5, <code>step</code> will return 1, which means\n        the effective color factor for <code>diagonal 1</code> will be the\n        calculated color value for it.\n      </p>\n      <p>\n        Similar steps are followed for calculating the effective color factor\n        for <code>diagonal 2</code>, except we use the inverse of the value\n        returned by <code>step</code> (<code>1.0 - step(...)</code>) with the\n        same threshold, using the user-defined function <code>invert_step</code>\n        .\n      </p>\n      <p>\n        Since the factors for both diagonals use the same threshold value, only\n        either one of the diagonals will have a non-zero value, since if{\" \"}\n        <code>step</code> returns 1, then <code>invert_step</code> will return\n        0, and vice-versa.\n      </p>\n      <p>\n        The final diagonal factor of the fragment is chosen as the maximum value\n        between the effective factor of <code>diagonal 1</code> and{\" \"}\n        <code>diagonal 2</code>, since one of them will be 0, and the other will\n        be greater than 0. In GLSL, this can be done using the built-in function{\" \"}\n        <code>max</code>.\n      </p>\n      <p>\n        The final color value of the fragment is set using this final chosen\n        diagonal factor.\n      </p>\n      <p>\n        An additional case can be added where both diagonals can be shown. This\n        can be done by commenting lines 28 and 29, and uncommenting lines 30 and\n        31.\n      </p>\n      <p>\n        The threshold for showing <code>diagonal 1</code> becomes 0.4. If the\n        random factor is more than 0.4, then the diagonal will be shown.\n      </p>\n      <p>\n        Similaryly, the threshold for showing <code>diagonal 2</code> becomes\n        0.6. If the random factor is less than 0.6, then the diagonal will be\n        shown.\n      </p>\n      <p>\n        This results in a range 0.4 to 0.6, where if the random factor of the\n        tile lies within this range, then both diagonals will be shown on the\n        tile.\n      </p>\n      <p>\n        Since now there is a case where the effective color factor of both\n        diagonals can be non-zero at the same time, the final diagonal color\n        factor becomes whichever diagonal color factor is greater.\n      </p>\n      <p>\n        If the color factor of the <code>diagonal 1</code> is greater, this\n        means that the fragment is closer to <code>diagonal 1</code> than{\" \"}\n        <code>diagonal 2</code>, so the fragment should be colored w.r.t.{\" \"}\n        <code>diagonal 1</code>.\n      </p>\n      <p>\n        Similarly, if the color factor of the <code>diagonal 2</code> is\n        greater, this means that the fragment is closer to{\" \"}\n        <code>diagonal 2</code> than <code>diagonal 1</code>, so the fragment\n        should be colored w.r.t. <code>diagonal 2</code>.\n      </p>\n      <p>\n        Since we're already selecting the maximum color value w.r.t.{\" \"}\n        <code>diagonal 1</code> and <code>diagonal 2</code>, this case is\n        already accounted for.\n      </p>\n      <p>\n        The only change required is to change thresholds for either diagonal\n        such that there will be an overlapping range where both diagonals can be\n        shown for a tile.\n      </p>\n      <Heading type=\"h2\">Additional Notes</Heading>\n      <p>\n        The concepts taught so far show the basics of pattern image generation,\n        random noise image generation, and a combination of both.\n      </p>\n      <p>\n        These concepts can be further built upon to generate sub-patterns within\n        patterns, or multiple layers of randomness and patterns combined\n        together.\n      </p>\n      <p>\n        These patterns and randomness can also be animated by including time as\n        a factor as well, which opens up options for dynamic and animated image\n        generation. Time can be used to influence the randomness of an image, or\n        the patterns of an image.\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          Images can be generated without using external data, but just using\n          some algorithmic logic within shaders.\n        </li>\n        <li>\n          Images can be generated using patterns and procedural code, or with\n          random values and noise.\n        </li>\n        <li>\n          Logic from pattern/procedural images and random images can be stacked\n          or combined with each other to create many more types of images.\n        </li>\n      </ul>\n    </Content>\n    <PageChange\n      previous=\"/intermediates/color-2/\"\n      next=\"/intermediates/mapping/\"\n    />\n  </Layout>\n);\n\nexport default ImageGenerationPage;\n"],"names":["eighthVertexShaderSource","vertexShader","eighthFragmentShaderSource","shaderProgramInfo","vertex","attributeLocations","vertexPosition","uniformLocations","fragment","resolution","screenModelPosition","mat4","wrapExample","RandomImageGenerationEighthExample","screen","vertices","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","screenBuffer","updateScreenBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","shouldRender","renderScene","_ref","gl","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","useProgram","uniform2fv","drawArrays","TRIANGLE_STRIP","length","requestAnimationFrame","React","className","style","padding","width","height","ref","fifthVertexShaderSource","fifthFragmentShaderSource","RandomImageGenerationFifthExample","firstVertexShaderSource","firstFragmentShaderSource","RandomImageGenerationFirstExample","fourthVertexShaderSource","fourthFragmentShaderSource","RandomImageGenerationFourthExample","ninthVertexShaderSource","ninthFragmentShaderSource","RandomImageGenerationNinthExample","hninth","secondVertexShaderSource","secondFragmentShaderSource","RandomImageGenerationSecondExample","seventhVertexShaderSource","seventhFragmentShaderSource","RandomImageGenerationSeventhExample","sixthVertexShaderSource","sixthFragmentShaderSource","RandomImageGenerationSixthExample","thirdVertexShaderSource","thirdFragmentShaderSource","RandomImageGenerationThirdExample","location","pathname","Layout","Seo","title","description","keywords","Content","Equation","text","GlslCodeHighlight","code","trim","type","Heading","StaticImage","src","alt","maxWidth","__imageData","require","href","target","rel","Link","to","PageChange","previous","next"],"sourceRoot":""}