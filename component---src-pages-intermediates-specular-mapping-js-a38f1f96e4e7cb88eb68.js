"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[72],{4374:function(e,t,a){a.r(t),a.d(t,{default:function(){return M}});var r=a(4794),n=a(2532),i=a(6540),l=a(9460),o=a(7154),c=a(6042),s=(a(6449),a(3514),a(4796)),u=a(329),m=a(7684),p=a(842),h=a(9498),f=a.p+"static/specular-0e60e34393edfda92e3563725afa6445.png",g=a(2859),v=a(3461),b=a(6417),d=a(782);const x="attribute vec4 vertexPosition;\nattribute vec2 vertexUv;\nattribute vec3 vertexNormal;\nattribute vec3 vertexTangent;\nattribute vec3 vertexBiTangent;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying highp vec2 uv;\nvarying highp mat3 tbnMatrix_viewSpace;\nvarying highp vec4 fragmentPosition_viewSpace;\n\nvoid main() {\n  highp vec4 vertexPosition_worldSpace = modelMatrix * vertexPosition;\n  highp vec4 vertexPosition_viewSpace = viewMatrix * vertexPosition_worldSpace;\n  gl_Position = projectionMatrix * vertexPosition_viewSpace;\n\n  fragmentPosition_viewSpace = vertexPosition_viewSpace;\n  uv = vertexUv;\n\n  highp mat3 modelViewMatrix_3x3 = mat3(viewMatrix * modelMatrix);\n  highp vec3 vertexTangent = normalize(vertexTangent);\n  highp vec3 vertexBiTangent = normalize(vertexBiTangent);\n  highp vec3 vertexNormal = normalize(vertexNormal);\n\n  tbnMatrix_viewSpace = modelViewMatrix_3x3 * mat3(\n    vertexTangent,\n    vertexBiTangent,\n    vertexNormal\n  );\n}",w="varying highp vec2 uv;\nvarying highp mat3 tbnMatrix_viewSpace;\nvarying highp vec4 fragmentPosition_viewSpace;\n\nuniform highp mat4 viewMatrix;\nuniform highp vec4 lightPosition_worldSpace;\n\nuniform highp vec3 lightColor;\nuniform highp float lightIntensity;\n\nuniform highp float specularLobeFactor;\n\nuniform sampler2D diffuseTextureSampler;\nuniform sampler2D normalTextureSampler;\nuniform sampler2D specularTextureSampler;\n\nvoid main() {\n  highp vec4 diffuseColor = texture2D(diffuseTextureSampler, uv);\n  highp vec4 normalColor = texture2D(normalTextureSampler, uv);\n  highp vec4 specularColor = texture2D(specularTextureSampler, uv);\n\n  highp vec3 normal_viewSpace = tbnMatrix_viewSpace * normalize((normalColor.xyz * 2.0) - 1.0);\n\n  highp vec4 lightPosition_viewSpace = viewMatrix * lightPosition_worldSpace;\n  highp vec3 lightDirection_viewSpace = normalize((lightPosition_viewSpace - fragmentPosition_viewSpace).xyz);\n  highp vec3 viewDirection_viewSpace = normalize(fragmentPosition_viewSpace.xyz - vec3(0.0, 0.0, 0.0));\n\n  highp vec3 lightColorIntensity = lightColor * lightIntensity;\n  highp float distanceFromLight = distance(fragmentPosition_viewSpace, lightPosition_viewSpace);\n\n  highp float diffuseStrength = clamp(dot(normal_viewSpace, lightDirection_viewSpace), 0.0, 1.0);\n  highp vec3 diffuseLight = (lightColorIntensity * diffuseStrength) / (distanceFromLight * distanceFromLight);\n\n  highp vec3 lightReflection_viewSpace = reflect(lightDirection_viewSpace, normal_viewSpace);\n\n  highp float specularStrength = clamp(dot(viewDirection_viewSpace, lightReflection_viewSpace), 0.0, 1.0);\n  highp vec3 specularLight = (lightColorIntensity * pow(specularStrength, specularLobeFactor)) / (distanceFromLight * distanceFromLight);\n\n  gl_FragColor.rgb = (diffuseColor.rgb * diffuseLight) + (specularColor.rgb * specularLight);\n  gl_FragColor.a = diffuseColor.a;\n}",S={vertex:{attributeLocations:{vertexPosition:"vec4",vertexUv:"vec2",vertexNormal:"vec3",vertexTangent:"vec3",vertexBiTangent:"vec3"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",lightPosition_worldSpace:"vec4",lightColor:"vec3",lightIntensity:"float",specularLobeFactor:"float"}},fragment:{attributeLocations:{},uniformLocations:{diffuseTextureSampler:"sampler2D",normalTextureSampler:"sampler2D",specularTextureSampler:"sampler2D"}}},T=s.fA(4,0,4,1),E=u.fA(1,1,1),A=m.vt();var y=(0,b.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]],uvs:[[0,1],[0,0],[1,1],[0,0],[1,1],[1,0]],normals:[[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],tangents:[],biTangents:[],indices:[[0,1,2,3,4,5]],texture:g.A,normalTexture:h.A,specularTexture:f,specularLobeFactor:5};for(let i=0;i<e.vertices.length;i+=3){const t=u.o8(e.vertices[i+0]),a=u.o8(e.vertices[i+1]),r=u.o8(e.vertices[i+2]),n=p.o8(e.uvs[i+0]),l=p.o8(e.uvs[i+1]),o=p.o8(e.uvs[i+2]),c=u.Re(u.vt(),a,t),s=u.Re(u.vt(),r,t),m=p.Re(p.vt(),l,n),h=p.Re(p.vt(),o,n),f=1/(m[0]*h[1]-m[1]*h[0]),g=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),c,[h[1],h[1],h[1]]),u.lw(u.vt(),s,[m[1],m[1],m[1]])),[f,f,f])),v=Array.from(u.lw(u.vt(),u.Re(u.vt(),u.lw(u.vt(),s,[m[0],m[0],m[0]]),u.lw(u.vt(),c,[h[0],h[0],h[0]])),[f,f,f]));e.tangents.push(g,g,g),e.biTangents.push(v,v,v)}const{0:t,1:a}=(0,i.useState)(null),{0:r,1:n}=(0,i.useState)(null),{0:l,1:o}=(0,i.useState)(null),{0:c,1:s}=(0,i.useState)({vertices:null,uvs:null,normals:null,tangents:null,biTangents:null,indices:null,texture:null,normalTexture:null,specularTexture:null}),b=(0,i.useRef)();(0,i.useEffect)((()=>{if(null!==b.current){const e=new d.A(b.current,A);return a(e),()=>{a(null),e.destroy()}}}),[b]),(0,i.useEffect)((0,v.sT)(null!==t,(()=>{n(t.createShaderProgram(x,w))})),[t]),(0,i.useEffect)((0,v.sT)(null!==r,(()=>{o(t.getDataLocations(r,S))})),[r]),(0,i.useEffect)((0,v.sT)(null!==l,(()=>{s({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),c.vertices),uvs:t.createStaticDrawArrayBuffer(e.uvs.flat(),c.uvs),normals:t.createStaticDrawArrayBuffer(e.normals.flat(),c.normals),tangents:t.createStaticDrawArrayBuffer(e.tangents.flat(),c.tangents),biTangents:t.createStaticDrawArrayBuffer(e.biTangents.flat(),c.biTangents),indices:t.createElementArrayBuffer(e.indices.flat(),c.indices),texture:t.createImageTexture(e.texture,c.texture),normalTexture:t.createImageTexture(e.normalTexture,c.normalTexture),specularTexture:t.createImageTexture(e.specularTexture,c.specularTexture)})})),[l]),(0,i.useEffect)((0,v.sT)(null!==c.vertices,(()=>{let a=!0;const n=()=>{t.renderScene((t=>{let{gl:i,projectionMatrix:o,viewMatrix:s,modelMatrix:u}=t;if(!a)return;const p=m.vt(),h=30*Math.PI/180;m.Tl(p,u,[0,0,2]),m.Z8(p,p,h),i.bindBuffer(i.ARRAY_BUFFER,c.vertices),i.vertexAttribPointer(l.vertex.attributeLocations.vertexPosition,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(l.vertex.attributeLocations.vertexPosition),i.bindBuffer(i.ARRAY_BUFFER,c.uvs),i.vertexAttribPointer(l.vertex.attributeLocations.vertexUv,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(l.vertex.attributeLocations.vertexUv),i.bindBuffer(i.ARRAY_BUFFER,c.normals),i.vertexAttribPointer(l.vertex.attributeLocations.vertexNormal,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(l.vertex.attributeLocations.vertexNormal),i.bindBuffer(i.ARRAY_BUFFER,c.tangents),i.vertexAttribPointer(l.vertex.attributeLocations.vertexTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(l.vertex.attributeLocations.vertexTangent),i.bindBuffer(i.ARRAY_BUFFER,c.biTangents),i.vertexAttribPointer(l.vertex.attributeLocations.vertexBiTangent,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(l.vertex.attributeLocations.vertexBiTangent),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,c.indices),i.useProgram(r),i.uniformMatrix4fv(l.vertex.uniformLocations.projectionMatrix,!1,o),i.uniformMatrix4fv(l.vertex.uniformLocations.viewMatrix,!1,s),i.uniformMatrix4fv(l.vertex.uniformLocations.modelMatrix,!1,p),i.uniform4fv(l.vertex.uniformLocations.lightPosition_worldSpace,T),i.uniform3fv(l.vertex.uniformLocations.lightColor,E),i.uniform1f(l.vertex.uniformLocations.lightIntensity,50),i.uniform1f(l.vertex.uniformLocations.specularLobeFactor,e.specularLobeFactor),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,c.texture),i.uniform1i(l.fragment.uniformLocations.diffuseTextureSampler,0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,c.normalTexture),i.uniform1i(l.fragment.uniformLocations.normalTextureSampler,1),i.activeTexture(i.TEXTURE2),i.bindTexture(i.TEXTURE_2D,c.specularTexture),i.uniform1i(l.fragment.uniformLocations.specularTextureSampler,2),i.drawElements(i.TRIANGLES,e.indices.length*e.indices[0].length,i.UNSIGNED_SHORT,0),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{a=!1}})),[c]);return i.createElement("div",{className:"util text-center",style:{padding:"1rem"}},i.createElement("canvas",{width:"640",height:"480",ref:b},"Cannot run WebGL examples (not supported)"),i.createElement("pre",{className:"util text-left"},("\nSquare:\n    World Position: "+(0,v.NW)([0,0,0])+"\n    Lighting:\n        Lobe Density: "+e.specularLobeFactor+"\n").trim()),i.createElement("pre",{className:"util text-left"},("\nLight:\n    World Position: "+(0,v.NW)(T)+"\n    Color: "+(0,v.NW)(E,{x:"r",y:"g",z:"b"})+"\n    Intensity: 50\n").trim()))})),_=a(7570),L=a(2007),R=a(2269);var M=e=>{let{location:{pathname:t}}=e;return i.createElement(_.A,null,i.createElement(R.A,{pathname:t,title:"Shader Intermediates - Specular Mapping",description:"A look into the how specular map textures are used to enhance specular lighting detail to objects.",keywords:["specular","mapping","texturing","shader","intermediates"]}),i.createElement(l.A,null,i.createElement("h1",null,"Shader Intermediates - Specular Mapping"),i.createElement("p",null,"Similar to how we've stored information the normal information of a surface in a map (as taught in the"," ",i.createElement(r.Link,{to:"/intermediates/normal-mapping"},"normal mapping chapter"),"), we can also store specular information of a surface in a map as well. Such a map is called a specular map."),i.createElement(c.A,{type:"h2"},"Specular Maps"),i.createElement("p",null,"Like the texture maps used in the"," ",i.createElement(r.Link,{to:"/intermediates/normal-mapping"},"normal mapping chapter"),", the texture maps that will be used to color and light the wall are:"),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/intermediates/texture-2.png",alt:"Stone Wall - Diffuse Map",style:{maxWidth:"65%"},__imageData:a(285)}),i.createElement("br",null),"Diffuse map",i.createElement("br",null),i.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/",target:"_blank",rel:"noopener noreferrer"},"Source")),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/intermediates/normal.png",alt:"Stone Wall - Normal Map",style:{maxWidth:"65%"},__imageData:a(8866)}),i.createElement("br",null),"Normal map",i.createElement("br",null),i.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/",target:"_blank",rel:"noopener noreferrer"},"Source")),i.createElement("div",{className:"image util text-center"},i.createElement(n.S,{src:"../../images/intermediates/specular.png",alt:"Stone Wall - Specular Map",style:{maxWidth:"65%"},__imageData:a(1091)}),i.createElement("br",null),"Specular map",i.createElement("br",null),i.createElement("a",{href:"https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/",target:"_blank",rel:"noopener noreferrer"},"Source")),i.createElement("p",null,"The specular map is an RGB image that contains the following information per pixel:"),i.createElement("ul",null,i.createElement("li",null,"The color value of a pixel describes what is the color of the specular highlight that is reflected from that point. Since the surface of the object can absorb part of the light and reflect the rest of it, this can change the specular reflection color and brightness."),i.createElement("li",null,"The brightness of the color maps into the specular reflectivity of the surface at that point. This means the brighter the color of the pixel, the smoother the surface is at that point and the more light it reflects.")),i.createElement("p",null,"Let's look at the stone wall example with the specular map added in. We'll be performing the lighting calculation in view-space."),i.createElement(c.A,{type:"h2"},"Example - Stone wall"),i.createElement(y,null),i.createElement(o.A,{code:x.trim(),type:"Vertex"}),i.createElement(o.A,{code:w.trim(),type:"Fragment"}),i.createElement("p",null,"At line 20, we grab the specular color value from the specular map, and use that as the specular highlight color + reflectivity value for the specular lighting component."),i.createElement("p",null,"Since the colors stored in the specular map are in RGB (with range 0 - 255, 0.0 - 1.0 in GLSL), the color value tells us what is the color of the specular highlight that is being reflected, and the brightness of the color tells us how much light is reflected."),i.createElement("p",null,"As a result, the specular color retrieved from the map can be used as and multiplied against the specular lighting vector to give us the final specular lighting value for the fragment."),i.createElement(c.A,{type:"h2"},"Summary"),i.createElement("ul",null,i.createElement("li",null,"Similar to normal mapping, specular mapping can be used to map specular highlight color and reflectivity to fragments inside a polygon to make a surface look more reflective and smooth."),i.createElement("li",null,"Specular maps add the appearence of smoothness on the surface of objects, allowing for the surface to reflect more light directly, increasing the specular lighting of the surface."),i.createElement("li",null,"The specular highlight color and reflectivity of each point are stored in the image as a RGB color value."),i.createElement("li",null,"The color values representing the specular highlight color and reflectivity for each fragment are retrieved from the texture and used as is, since the colors are in RGB and can be used directly to calculate how much specular light is actually reflected and the color of that light."))),i.createElement(L.A,{previous:"/intermediates/normal-mapping/"}))}},9498:function(e,t,a){t.A=a.p+"static/normal-3d370ff1c6790eee68b4a59f5ccdc8b9.png"},2859:function(e,t,a){t.A=a.p+"static/texture-2-c11990d4afdf5ed2f0fb3c44636bccd1.png"},1091:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/0b86ba1a964c6a4ba0b797ba99f6bd02/b5658/specular.png","srcSet":"/static/0b86ba1a964c6a4ba0b797ba99f6bd02/acb7c/specular.png 256w,\\n/static/0b86ba1a964c6a4ba0b797ba99f6bd02/ccc41/specular.png 512w,\\n/static/0b86ba1a964c6a4ba0b797ba99f6bd02/b5658/specular.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/0b86ba1a964c6a4ba0b797ba99f6bd02/22bfc/specular.webp 256w,\\n/static/0b86ba1a964c6a4ba0b797ba99f6bd02/d689f/specular.webp 512w,\\n/static/0b86ba1a964c6a4ba0b797ba99f6bd02/67ded/specular.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}')},8866:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#7878f8","images":{"fallback":{"src":"/static/6fe7653c1672859325c6018bb59934b5/b5658/normal.png","srcSet":"/static/6fe7653c1672859325c6018bb59934b5/acb7c/normal.png 256w,\\n/static/6fe7653c1672859325c6018bb59934b5/ccc41/normal.png 512w,\\n/static/6fe7653c1672859325c6018bb59934b5/b5658/normal.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/6fe7653c1672859325c6018bb59934b5/22bfc/normal.webp 256w,\\n/static/6fe7653c1672859325c6018bb59934b5/d689f/normal.webp 512w,\\n/static/6fe7653c1672859325c6018bb59934b5/67ded/normal.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}')},285:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/b5658/texture-2.png","srcSet":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/acb7c/texture-2.png 256w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/ccc41/texture-2.png 512w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/b5658/texture-2.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/22bfc/texture-2.webp 256w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/d689f/texture-2.webp 512w,\\n/static/b9fa7d8a3fdeb6b60ee5fc5a206c2081/67ded/texture-2.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":1024}')}}]);
//# sourceMappingURL=component---src-pages-intermediates-specular-mapping-js-a38f1f96e4e7cb88eb68.js.map