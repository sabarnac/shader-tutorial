"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[328],{517:function(e,t,n){n.r(t),n.d(t,{default:function(){return ce}});var a=n(4794),o=n(2532),r=n(6540),i=n(9460),l=n(7722),s=n(7154),c=n(6042),h=(n(6449),n(3514),n(7684)),m=n(3461),u=n(6417),d=n(782),f="attribute vec4 vertexPosition;\n\nvoid main() {\n  gl_Position = vertexPosition;\n}";const g=f,p="uniform highp vec2 resolution;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\n\n  highp vec2 randomizedBlockCenter = vec2(mix(0.1, 0.9, random(tileCoord / tilingResolution)));\n\n  highp float distanceFromCenter = distance(randomizedBlockCenter, blockCoordinates);\n  highp float centerFactor = 1.0 - distanceFromCenter;\n\n  highp float fragmentColor = pow(centerFactor, 2.0);\n  gl_FragColor = vec4(vec3(fragmentColor), 3);\n}",w={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},v=h.vt();var E=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,v);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(g,p))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,w))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const b=f,x="uniform highp vec2 resolution;\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCenter = vec2(0.5, 0.5);\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n\n  highp float distanceFromCenter = distance(blockCenter, blockCoordinates);\n  highp float centerFactor = 1.0 - distanceFromCenter;\n\n  highp vec2 coordFromCenter = abs(blockCenter - blockCoordinates);\n  highp float distanceFromDiagonals = abs(coordFromCenter.x - coordFromCenter.y);\n  highp float diagonalFactor = 1.0 - distanceFromDiagonals;\n\n  highp float fragmentColor = pow(diagonalFactor * centerFactor, 3.0);\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",y={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},A=h.vt();var T=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,A);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(b,x))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,y))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const F=f,k="uniform highp vec2 resolution;\n\nvoid main() {\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp float fragmentColor = coordinates.x * coordinates.y;\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",L={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},S=h.vt();var C=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,S);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(F,k))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,L))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const R=f,P="uniform highp vec2 resolution;\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCenter = vec2(0.5, 0.5);\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n\n  highp vec2 coordFromCenter = abs(blockCenter - blockCoordinates);\n  highp float distanceFromDiagonals = abs(coordFromCenter.x - coordFromCenter.y);\n  highp float diagonalFactor = 1.0 - distanceFromDiagonals;\n\n  highp float fragmentColor = pow(diagonalFactor, 3.0);\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",I={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},_=h.vt();var z=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,_);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(R,P))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,I))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const G=f,B="uniform highp vec2 resolution;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nhighp float invert_step(highp float edge, highp float x) {\n  return 1.0 - step(edge, x);\n}\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCenter = vec2(0.5, 0.5);\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\n\n  highp vec2 coordFromCenter = blockCenter - blockCoordinates;\n  highp float distanceFromDiagonal1 = abs(coordFromCenter.x - coordFromCenter.y);\n  highp float distanceFromDiagonal2 = abs(coordFromCenter.x + coordFromCenter.y);\n\n  highp float diagonal1Color = (1.0 - distanceFromDiagonal1);\n  highp float diagonal2Color = (1.0 - distanceFromDiagonal2);\n\n  highp float randomFactor = random(tileCoord / tilingResolution);\n\n  highp float diagonal1Factor = step(0.5, randomFactor) * diagonal1Color;\n  highp float diagonal2Factor = invert_step(0.5, randomFactor) * diagonal2Color;\n  // highp float diagonal1Factor = step(0.4, randomFactor) * diagonal1Color;\n  // highp float diagonal2Factor = invert_step(0.6, randomFactor) * diagonal2Color;\n  highp float diagonalFactor = max(diagonal1Factor, diagonal2Factor);\n\n  highp float fragmentColor = pow(diagonalFactor, 3.0);\n  gl_FragColor = vec4(vec3(fragmentColor), 3);\n}",D={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},N=h.vt();var q=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,N);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(G,B))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,D))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",hninth:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const Y=f,W="uniform highp vec2 resolution;\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n\n  highp float fragmentColor = blockCoordinates.x * blockCoordinates.y;\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",H={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},X=h.vt();var O=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,X);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(Y,W))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,H))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const U=f,j="uniform highp vec2 resolution;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 tileCoord = floor(coordinates * tilingResolution);\n\n  highp float fragmentColor = random(tileCoord / tilingResolution);\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",V={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},M=h.vt();var J=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,M);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(U,j))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,V))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const Z=f,K="uniform highp vec2 resolution;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp float fragmentColor = random(coordinates);\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",Q={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},$=h.vt();var ee=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,$);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(Z,K))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,Q))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))}));const te=f,ne="uniform highp vec2 resolution;\n\nvoid main() {\n  highp vec2 tilingResolution = vec2(12.0, 9.0);\n  highp vec2 coordinates = gl_FragCoord.xy / resolution;\n\n  highp vec2 blockCenter = vec2(0.5, 0.5);\n  highp vec2 blockCoordinates = fract(coordinates * tilingResolution);\n\n  highp float distanceFromCenter = distance(blockCenter, blockCoordinates);\n  highp float centerFactor = 1.0 - distanceFromCenter;\n\n  highp float fragmentColor = pow(centerFactor, 3.0);\n  gl_FragColor = vec4(vec3(fragmentColor), 1.0);\n}",ae={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{}},fragment:{attributeLocations:{},uniformLocations:{resolution:"vec2"}}},oe=h.vt();var re=(0,u.A)((()=>{const e={vertices:[[-1,-1,0],[-1,1,0],[1,-1,0],[1,1,0]]},{0:t,1:n}=(0,r.useState)(null),{0:a,1:o}=(0,r.useState)(null),{0:i,1:l}=(0,r.useState)(null),{0:s,1:c}=(0,r.useState)({vertices:null}),h=(0,r.useRef)();return(0,r.useEffect)((()=>{if(null!==h.current){const e=new d.A(h.current,oe);return n(e),()=>{n(null),e.destroy()}}}),[h]),(0,r.useEffect)((0,m.sT)(null!==t,(()=>{o(t.createShaderProgram(te,ne))})),[t]),(0,r.useEffect)((0,m.sT)(null!==a,(()=>{l(t.getDataLocations(a,ae))})),[a]),(0,r.useEffect)((0,m.sT)(null!==i,(()=>{c({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),s.vertices)})})),[i]),(0,r.useEffect)((0,m.sT)(null!==s.vertices,(()=>{let n=!0;const o=()=>{t.renderScene((t=>{let{gl:r,resolution:l}=t;n&&(r.bindBuffer(r.ARRAY_BUFFER,s.vertices),r.vertexAttribPointer(i.vertex.attributeLocations.vertexPosition,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(i.vertex.attributeLocations.vertexPosition),r.useProgram(a),r.uniform2fv(i.fragment.uniformLocations.resolution,l),r.drawArrays(r.TRIANGLE_STRIP,0,e.vertices.length),requestAnimationFrame(o))}))};return requestAnimationFrame(o),()=>{n=!1}})),[s]),r.createElement("div",{className:"util text-center",style:{padding:"1rem"}},r.createElement("canvas",{width:"640",height:"480",ref:h},"Cannot run WebGL examples (not supported)"))})),ie=n(7570),le=n(2007),se=n(2269);var ce=e=>{let{location:{pathname:t}}=e;return r.createElement(ie.A,null,r.createElement(se.A,{pathname:t,title:"Shader Intermediates - Image Generation",description:"A look into the how images can be generated using noise and patterns.",keywords:["image","generation","noise","patterns","shader","intermediates"]}),r.createElement(i.A,null,r.createElement("h1",null,"Shader Intermediates - Image Generation"),r.createElement("p",null,"While images can be generated to render objects passed to a GPU, images can also be generated where the image is drawn over the entire screen, with the help of some logic for what color each pixel should be. Noise can also be added in to the image to change the end result."),r.createElement("p",null,"These generated images can be used as the final image to show to users, or can be stored as a texture for use somewhere else, such as to color the surface of a particular object."),r.createElement("p",null,"Certain applications do generate textures using shaders instead of having raw image files in order to save space or have a dynamic resolution for its textures depending on the system it is running on."),r.createElement("p",null,"Images can also be passed as textures to these shaders, which can then apply filters or effects on such images, such as bluring, pixelating, changing color temperature (warm/cool), etc."),r.createElement("p",null,"Since vertices are still required to be sent to the vertex shader, the vertices passed are:"),r.createElement("p",{className:"util text-center"},r.createElement(l.A,{text:"vertices = ((-1, -1), (-1, 1), (1, 1), (1, -1))"})),r.createElement("p",null,"These four coordinates map to the vertices of the frame, so the vertex shader returns the vertex value as it receives it. No modifications are done to the received vertex since the passed vertices are already in the form of clip-space coordinates."),r.createElement(s.A,{code:F.trim(),type:"Vertex"}),r.createElement(c.A,{type:"h2"},"Example - A coordinate gradient"),r.createElement(C,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement(s.A,{code:k.trim(),type:"Fragment"}),r.createElement("p",null,"This fragment shader generates a gradient that's darkest at one corner and brightest at the opposite corner. The darkest corner will always be at the origin, since that is the point where the coordinates of the pixel will be 0 (or at least nearest to 0)."),r.createElement("p",null,"In GLSL, the coordinates of the current fragment can be accessed through the ",r.createElement("code",null,"gl_FragCoord")," constant. It contains the position of the fragment as the X and Y values, and the depth of the fragment as the Z value."),r.createElement("p",null,"In cases where a single fragment is generated per pixel, the position of this fragment will be the coordinates of the center of the pixel the fragment belongs to."),r.createElement("p",null,"This means that a fragment belonging to the lower-left most pixel, the coordinates of the fragment is ",r.createElement(l.A,{text:"(0.5, 0.5)"}),", when the location of the pixel itself is ",r.createElement(l.A,{text:"(0, 0)"}),"."),r.createElement("p",null,"The coordinates of the fragments range from ",r.createElement(l.A,{text:"(0, 0)"})," ","to the width and height of the frame. In order to normalize these coordinates down to a range from 0 - 1, we can receive the total resolution of the frame from outside the shader (the shader by default has no way of knowing the resolution of the frame)."),r.createElement("p",null,"The fragment coordinates can then be divided by the resolution to get the normalized coordinates of the fragment within the range from 0 - 1, which can make calculations simpler since we now work within a constant range."),r.createElement("p",null,"The color of the fragment is simply set as the product of the normalized X and Y coordinates of the fragment, and in grayscale (since R, G, and B components are all set to the same value)."),r.createElement("p",null,"From this render, we can see that the origin of the X and Y axis is at the lower-left corner. The value of X increases as you move right, and the value of Y increases as you go up."),r.createElement("p",null,"Let's now look at the next example, where we tile the image."),r.createElement(c.A,{type:"h2"},"Example - A tiled coordinate gradient"),r.createElement(O,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement("p",null,"Tiling an image is pretty simple. The image needs to be split into blocks, and then each block can have operations performed on it."),r.createElement("p",null,"As the fragment shader can only work on individual fragments, two values need to be calculated for each of them:"),r.createElement("ul",null,r.createElement("li",null,"The tile the fragment belongs to"),r.createElement("li",null,"The position of the fragment within that tile (in the form of normalized coordinates).")),r.createElement("p",null,"Once these values are known, applying operations on each tile (or block) is simple."),r.createElement("p",null,"In order to understand how the math would work, let's look at the current image that we have."),r.createElement("p",null,"The current image we have is made up of pixels. The position of these pixels can be easily determined. Taking an image of resolution"," ",r.createElement(l.A,{text:"(99, 99)"}),", if we consider the screen as a graph and the lower-left corner pixel as the origin, then the center pixel would be located at ",r.createElement(l.A,{text:"(49, 49)"}),"."),r.createElement("p",null,"Similarly, the coordinates of the top-right corner would"," ",r.createElement(l.A,{text:"(98, 98)"}),", the coordinates of the top-left corner would be ",r.createElement(l.A,{text:"(0, 98)"}),", the coordinates of the bottom-right corner would be ",r.createElement(l.A,{text:"(0, 98)"}),", and the coordinates of the bottom-left corner would be"," ",r.createElement(l.A,{text:"(0, 0)"})," (since that's the origin)."),r.createElement("p",null,"We know that pixels contain multiple fragments. For this current situation, let's consider each pixel only containing one fragment, with its position at the center of the pixel."),r.createElement("p",null,"Our previous explanation assumes that pixels are point sized (they have no area). However, in reality, they do occupy a region of space, just like tiles."),r.createElement("p",null,"This means that the coordinates of the pixels don't exactly represent the position of that pixel, but instead a particular part of that pixel. As is with graphs and plotting, the coordinates of the pixel represents where the lower-left corner of the pixel is positioned."),r.createElement("p",null,"Since fragments belong to a particular pixel, their position is generally determined relative to each pixel."),r.createElement("p",null,"Since the coordinates of each pixel in an image is represented as an integer, the coordinates of the fragments within the pixel can be represented as decimal values of the integer coordinates."),r.createElement("p",null,"For example, with the center pixel in our previous example, the coordinates",r.createElement(l.A,{text:"(49, 49)"})," now represents the lower-left corner of that pixel. As the position of the fragment lies at the center of the pixel, its coordinates would become:"),r.createElement("p",{className:"util text-center"},r.createElement(l.A,{text:'"fragment coordinates" = (49 + 0.5, 49 + 0.5) = (49.5, 49.5)'})),r.createElement("p",null,r.createElement("em",null,"Note: Since the coordinates of two consecutive pixels will have a difference of 1, a fragment within a pixel has to have coordinates within the range of 0 to 1 (excluding 1, including 0). As the fragment in our example is at the centre, its coordinates would be"," ",r.createElement(l.A,{text:'50% "of 1" = 0.5'}),".")),r.createElement("p",null,"Here we notice two interesting properties:"),r.createElement("ul",null,r.createElement("li",null,"The integral part of the coordinates represents the pixel position."),r.createElement("li",null,"The decimal part of the coordinates represents the fragment position within that pixel. They are also considered as normalized coordinates of the fragment w.r.t that pixel (we'll look into that later).")),r.createElement("p",null,"An important note about these coordinates is that they are dependent on the resolution of the image, which is ",r.createElement(l.A,{text:"(99, 99)"}),". This is evident through a simple check."),r.createElement("p",null,"We saw that the coordinates of the center pixel of the image is"," ",r.createElement(l.A,{text:"(49, 49)"}),". However, the coordinates are relative to the size of the image itself. If the size of the image changes, the coordinates of the center pixel would also change."),r.createElement("p",null,'These coordinates need to be converted into a format such that they are no longer dependent on the resolution of the image. By doing so, the coordinates become "normalized", and are independent of any resolution.'),r.createElement("p",null,"The value of the components of normalized coordinates is always within the range of 0 to 1 (excluding 1, including 0)."),r.createElement("p",null,"This can be done through a simple division operation of the pixel coordinates and the resolution of the image. The calculation is:"),r.createElement("p",{className:"util text-center"},r.createElement(l.A,{text:"text(normalized coordinates) = (text(pixel coordinates)_x / text(image resolution)_x, text(pixel coordinates)_y / text(image resolution)_y)"})),r.createElement("p",null,"Once the normalized coordinates of any pixel are known, the coordinates of a pixel relative to any screen resolution can be determined through multiplication:"),r.createElement("p",{className:"util text-center"},r.createElement(l.A,{text:"text(new coordinates) = (text(pixel coordinates)_x / text(new resolution)_x, text(pixel coordinates)_y / text(new resolution)_y)"})),r.createElement("p",null,"Now consider the pixels as tiles. Tiles have area as well, similar to pixels as we've discussed. So this allows us to map the concepts discussed so far into tiles."),r.createElement("p",null,"Tiles also contain a group of points, similar to the concept of pixels, where a fragment is be considered a point, and a pixel is considered a group of fragments, in this case there being only one fragment in the center."),r.createElement("p",null,"By normalizing the coordinates of a fragment, all the fragments from the original image are grouped into an image that is one pixel in size."),r.createElement("p",null,"This is evident by looking at the value of the components of the normalized coordinates. These coordinates will always have the integral component set to 0, which means that they all belong to the same pixel. It is the decimal component that determines where they are located within that pixel."),r.createElement("p",null,"If we took an image of resolution ",r.createElement(l.A,{text:"(100, 100)"})," with one fragment per pixel, when the fragment coordinates are normalized, the fragments are now simply mapped onto an image of resolution"," ",r.createElement(l.A,{text:"(1, 1)"}),"."),r.createElement("p",null,'This means the pixel in this "new image" will contain all the fragments of the original image, which is'," ",r.createElement(l.A,{text:"100 times 100 = 10000"}),". The location of all these fragments within that pixel are determined from the decimal part of the values of the coordinates."),r.createElement("p",null,"By multiplying the normalized coordinates against another resolution, these fragments are again spread across all the pixels in that resolution. This can result in a change in the number of fragments per pixel, depending upon the new resolution."),r.createElement("p",null,"This is also evident from the resultant coordinates. The integral part of the coordinates will indicate which pixel the fragment belongs to, and the decimal part indicates where they are located within that pixel."),r.createElement("p",null,"If the fragments from the example are now spread across an image of resolution ",r.createElement(l.A,{text:"(10, 10)"}),", then each pixel in the new image will contain"," ",r.createElement(l.A,{text:"10000 / (10 times 10) = 10000 / 100 = 100"})," ","fragments."),r.createElement("p",null,"A fragment present within pixel of coordinates"," ",r.createElement(l.A,{text:"(5, 5)"})," will have coordinates"," ",r.createElement(l.A,{text:'("5.x", "5.y")'}),", where ",r.createElement(l.A,{text:'"x"'})," ","and ",r.createElement(l.A,{text:'"y"'})," are the decimal parts that tell the location of the fragment within that pixel."),r.createElement("p",null,"We initially noted that the decimal part of the coordinates are the normalized coordinates of the fragment. The reason for this is simple."),r.createElement("p",null,"We've just discussed how with normalized coordinates, the integral part is always constant, with the decimal part noting the actual location."),r.createElement("p",null,"Similarly, with the fragment coordinates, since the decimal part determines where within a specific pixel the fragment is located, it can be considered as the normalized coordinates relative to the pixel the fragment belongs to."),r.createElement("p",null,"The concept of tiling uses these principles, with a tile representing a pixel. When the coordinates of a fragment is normalized, it is grouped into a single tile."),r.createElement("p",null,'By multiplying this normalized coordinates with the "tiling resolution" (number of tiles across the screen, similar to screen resolution and pixels), the fragment is then placed into the tile that it should belong to.'),r.createElement("p",null,"Using the final coordinates of the fragment (which we'll refer to as the tiling coordinates), we can:"),r.createElement("ul",null,r.createElement("li",null,"Determine the tile the fragment is present in by looking at the integral part of its tiling coordinates (which we'll refer to as tile coordinates)."),r.createElement("li",null,"Determine its location within a tile (normalized coordinates w.r.t the tile) by looking at the decimal part of its tiling coordinates (which we'll refer to as tile normalized coordinates).")),r.createElement(s.A,{code:W.trim(),type:"Fragment"}),r.createElement("p",null,"Looking at our code, we can see the application of the discussed concepts. We set a tiling resolution of (",r.createElement(l.A,{text:"(12.0, 9.0)"}),"). The normalized coordinates of the fragment are then calculated."),r.createElement("p",null,"The tiling coordinates of the fragment w.r.t. the tiling resolution is then calculated through the multiplication operation."),r.createElement("p",null,"However, for the color of the fragment, we only care about its tile normalized coordinates, so we grab the decimal component of the resultant coordinates."),r.createElement("p",null,"In GLSL, this can be done using the built-in function ",r.createElement("code",null,"fract"),"."),r.createElement("p",null,r.createElement("em",null,"Note: In the shader code, any values w.r.t a parent tile will be prefixed with ",r.createElement("code",null,"block"),". Any values w.r.t the all tiles will be prefixed with ",r.createElement("code",null,"tile")),". This is done to differentiate between them."),r.createElement("p",null,"The tile normalized coordinates are then used to calculate the color of the fragment, just like in the first example."),r.createElement("p",null,"Next, let's draw something else within the tiles."),r.createElement(c.A,{type:"h2"},"Pattern Example - A tiled pattern with glowing center"),r.createElement(re,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement("p",null,"Now equipped with the information on how to tile an image, and get the necessary values required to work within a tile, we can start drawing within tiles."),r.createElement("p",null,"The algorithm for drawing a glowing circle that dims as you move towards the edge is simple:"),r.createElement("ul",null,r.createElement("li",null,"Determine the tile normalized coordinates for the center of the circle."),r.createElement("li",null,"Calculate the distance of the current fragments' tile normalized coordinates from the center."),r.createElement("li",null,"The distance from the center determines the brightness of the fragment. The closer a fragment is to the center, the brighter it will be.")),r.createElement(s.A,{code:ne.trim(),type:"Fragment"}),r.createElement("p",null,"First, we need to determine the tile normalized coordinates center of a tile. In a tile, the tile normalized coordinates of the center would be"," ",r.createElement(l.A,{text:"(0.5, 0.5)"}),", since the center would be located at the 50% width and height mark of a tile."),r.createElement("p",null,"We can then calculate the distance between the fragment and the center of the tiles using their normalized coordinates. In GLSL, a built-in function exists that can provide this value, called"," ",r.createElement("code",null,"distance"),"."),r.createElement("p",null,"Since we wish for fragments closer to the center of the tile to be brighter, we calculate the factor for the brightness as 1.0 (which is the maximum possible brightness) minus the distance of the fragment from the center."),r.createElement("p",null,"The result of this factor is stored in a variable called"," ",r.createElement("code",null,"centerFactor"),", since this brightness factor is based around the center of the tile."),r.createElement("p",null,"This brightness factor can now be set as the grayscale color of the fragment. This will result in fragments further away from the center of the tile becoming brighter."),r.createElement("p",null,"One thing to note is that the brightness factor is multiplied to the power of 3 (using the GLSL function ",r.createElement("code",null,"pow"),"), which is then set as the grayscale color of the fragment."),r.createElement("p",null,"There are two reasons this was done, and are also interlinked with each other:"),r.createElement("ul",null,r.createElement("li",null,"It increases the range of brightness values that are possible for the fragments."),r.createElement("li",null,"It increases the dropoff in brightness exponentially with distance.")),r.createElement("p",null,"Without using ",r.createElement("code",null,"pow"),", the possible range for the brightness values of fragments would be 1.0 - 0.3."),r.createElement("ul",null,r.createElement("li",null,"Points at the center would have a distance of 0, their brightness would be 1.0."),r.createElement("li",null,"Points at the edges of a tile would have a maximum distance of 0.7 (the distance of the corners from the center), making their brightness factor go down to 0.3.")),r.createElement("p",null,"By multiplying the factor by the power of 3, this range increases dramatically, to 1.0 - 0.027, since the lowest possible brightness gets cubed."),r.createElement("p",null,"This also means that the dropoff in brightness increases exponentially with distance from the center. Since the edges are now darker, the fragments in between will drop off in brightness a lot more to maintain the transition and range."),r.createElement("p",null,"Use this trick to your advantage if you need to exaggerate color values of your fragments."),r.createElement(c.A,{type:"h2"},"Pattern Example - A tiled pattern with glowing diagonals"),r.createElement(z,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement("p",null,"Drawing a pattern of diagonal lines across a tile may seem complex but, looking at the mathematics, we'll see that it's much more simple than it appears to be."),r.createElement("p",null,"In this pattern, we wish for fragments to grow dimmer the further they are from a either diagonal line. This requires calculating the distance of the fragment from either diagonal."),r.createElement("p",null,"In our image, we are dealing with square tiles, so all our calculations will be respective to that particular shape. For non-square tiles, the calculations may differ slightly, but the same requirement exists."),r.createElement("p",null,"Let's take the center of the tile as the origin of the graph. The tile is a square, and the tile normalized coordinates of the center of the tile is ",r.createElement(l.A,{text:"(0.5, 0.5)"}),". This results in the boundaries of the tile in our graph being 0.5 units away from the origin."),r.createElement("p",null,"The plot for this would be:"),r.createElement("div",{className:"image util text-center"},r.createElement(o.S,{src:"../../images/intermediates/tile-plot.png",alt:"Tile Graph Plot",style:{maxWidth:"65%"},__imageData:n(2788)}),r.createElement("br",null),r.createElement("a",{href:"https://www.transum.org/Maths/Activity/Graph/Desmos.asp",target:"_blank",rel:"noopener noreferrer"},"Image Generation Source")),r.createElement("p",null,"Adding the diagonals of the tile to the graph would result in the plot:"),r.createElement("div",{className:"image util text-center"},r.createElement(o.S,{src:"../../images/intermediates/tile-diagonal-plot.png",alt:"Tile With Diagonals Graph Plot",style:{maxWidth:"65%"},__imageData:n(9178)}),r.createElement("br",null),r.createElement("a",{href:"https://www.transum.org/Maths/Activity/Graph/Desmos.asp",target:"_blank",rel:"noopener noreferrer"},"Image Generation Source")),r.createElement("p",null,"Here, we can notice a peculiar property of diagonals - the absolute values of the X and Y coordinates of points on the diagonal are always equal. This can be easily verified from the plot generated above."),r.createElement("p",null,"So in order to determine if a point is on a diagonal line, we just need to find the difference between the absolute values of its X and Y coordinates. If it's zero, then we know it is on the diagonal."),r.createElement("p",null,"This subtraction calculation also provides us with another info - an approximate distance from the closest diagonal line."),r.createElement("p",null,"Any point that has a difference greater than zero between its X and Y coordinates are known to be present outside the line. This difference provides us with an approximation of how far away the point is."),r.createElement("p",null,"It will, in many cases, not equal to the closest distance between a point and the closest diagonal line, but for our purposes it is a good enough approximation."),r.createElement("p",null,"Now that we can calculate the distance of a fragment from the closest diagonal line, we can apply the same principles we learnt from the previous shader example."),r.createElement(s.A,{code:P.trim(),type:"Fragment"}),r.createElement("p",null,"The first few lines in the shader are similar to the previous shader example. After that, we first determine the tile normalized coordinates of the fragment."),r.createElement("p",null,"This is done through simple subtraction of the tile normalized coordinates of the center of the tile from the tile normalized coordinates of the fragment, thanks to the properties of vector mathematics."),r.createElement("p",null,"Since we don't care about the signs of the X and Y coordinates of the fragment, just their absolute values, we remove the signs from the resulting coordinates calculation. In GLSL, the built-in function"," ",r.createElement("code",null,"abs")," achieves this operation."),r.createElement("p",null,"Next we determine the distance of the point from the diagonal through the subtraction of the X and Y coordinates of the fragment. Only the absolute value of this result matters, hence the use of the"," ",r.createElement("code",null,"abs")," function again."),r.createElement("p",null,"Since the smaller this distance is, the closer the fragment is to the diagonal, this value is subtracted from 1.0 so that points closer to the diagonal are brighter (similar to the previous shader example)."),r.createElement("p",null,"This result is stored in a variable called ",r.createElement("code",null,"diagonalFactor"),", since this brightness factor is based on the distance from the diagonal."),r.createElement("p",null,"From this point onwards, it is again similar to the previous shader - using the brightness value to set the grayscale color of the fragment, and exaggerating the color difference using ",r.createElement("code",null,"pow"),"."),r.createElement("p",null,"Any pattern drawing that depends on tiling works on the same basics as the two patterns shown - splitting the image into tiles, and then operating within a single tile using the tile normalized coordinates."),r.createElement("p",null,"A pattern may not necessarily be created through a completely unique set of rules. Multiple patterns can be combined to form new patterns that produce interesting effects."),r.createElement("p",null,"Let's look at an example where we combine our previous two patterns into one and see the results."),r.createElement(c.A,{type:"h2"},"Pattern Example - A tiled combination pattern"),r.createElement(T,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement(s.A,{code:x.trim(),type:"Fragment"}),r.createElement("p",null,"In this example, we can see that we perform the calculations for the center brightness factor and diagonal brightness factor exactly as shown previously."),r.createElement("p",null,"The results of these two factors are combined (or merged) through a multiplication operation. This results in the image that you see above."),r.createElement("p",null,"Looking at the image, you can see the effects of both factors:"),r.createElement("ul",null,r.createElement("li",null,"The diagonal lines are visible, but are sharpened at the edges due to the effect of the center brightness factor."),r.createElement("li",null,'The brightness decreases closer to the edges of the tiles, but it produces a more "square-ish" shape than a circular one due to the diagonal brightness factor.')),r.createElement("p",null,"Here we see the effects of both the diagonal brightness factor and center brightness factor, but neither dominating over each other. The reason for this is due to the multiplication operation."),r.createElement("p",null,"A question that might be raised is why addition wasn't used instead. Addition is an operation that basically stacks such effects, but doesn't \"combine\" them into one."),r.createElement("p",null,"Here's an analogy to explain the effects of addition and multiplication:"),r.createElement("ul",null,r.createElement("li",null,"Addition is like taking a cake, applying a layer of frosting over it, and then adding a layer of chocolate sprinkles on top.",r.createElement("ul",null,r.createElement("li",null,"The frosting and sprinkles are in visibly separate layers, with the texture properties of both present only in their respective layers."),r.createElement("li",null,"The frosting and sprinkles can be separated with ease."),r.createElement("li",null,"If enough sprinkles are spread evenly enough across the frosting, it can obscure a majority of the frosting from the view."))),r.createElement("li",null,"Multiplication is like taking a bowl, putting in the frosting and chocolate sprinkles, and mixing it together into one mixture, and then layering this mixture on top of the cake.",r.createElement("ul",null,r.createElement("li",null,"The mixture combines the texture of the frosting and the sprinkles."),r.createElement("li",null,"The frosting and sprinkles are relatively much harder to separate."),r.createElement("li",null,"A relatively much larger ratio of sprinkles vs frosting is required to obscure the frosting.")))),r.createElement("p",null,"By performing an addition operation between the two factors, one factor could completely dominate over the other in certain fragments, and appear to stack over each other instead."),r.createElement("p",null,'By contrast, performing a multiplication operation "melds" the two factors together into a result where being able to separate the individual effects is harder to do visually.'),r.createElement("p",null,"In these types of cases, an addition operation stacks effects and factors, whereas a multiplication operation mixes effects and factors into one."),r.createElement("p",null,"The effects of multiplication and addition for combining and stacking effects will be more apparent in the"," ",r.createElement(a.Link,{to:"/intermediates/lighting/"},"lighting and dithering chapter"),"."),r.createElement("p",null,"So far, we've looked into images generated through the use of patterns, specifically tiling and patterns within tiles. Next, let's look at how images can be generated using randomness and noise."),r.createElement(c.A,{type:"h2"},"Randomness Example - Random noise"),r.createElement(ee,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement(s.A,{code:K.trim(),type:"Fragment"}),r.createElement("p",null,"In this example, for each fragment a random number is generated within the range of 0 - 1 (excluding 1, including 0). For this, a user-defined"," ",r.createElement("code",null,"random")," was used to create a number from given 2D coordinates."),r.createElement("p",null,"The function is provided with the normalized coordinates of the fragment as a parameter, and the random number returned is used as the grayscale color value for the fragment."),r.createElement("p",null,"The ",r.createElement("code",null,"random")," function used here will always generate the same random number given the same input, which allows for consistency."),r.createElement("p",null,"However, if it is required to always be unique, modifying the passed 2D coordinates with the current time can be done to make sure a new random value is generated for every render."),r.createElement("p",null,r.createElement("em",null,"Note: The random function code was taken from"," ",r.createElement("a",{href:"https://github.com/PistonDevelopers/shaders/wiki/Some-useful-GLSL-functions",target:"_blank",rel:"noopener noreferrer"},"this GitHub Wiki page"),".")),r.createElement(c.A,{type:"h2"},"Randomness Example - A tiled pattern of random (grayscale) colors"),r.createElement(J,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement(s.A,{code:j.trim(),type:"Fragment"}),r.createElement("p",null,"For setting up a tile of random grayscale colors, we first setup the tiles as learnt in the previous pattern examples, but make certain changes."),r.createElement("p",null,"In the pattern examples, we were only concerned with working within the block itself. So, when we generated the tile normalized coordinates of the fragment (",r.createElement("code",null,"coordinates * tilingResolution"),"), we ignored the integer component and only kept the decimal component using the function ",r.createElement("code",null,"fract"),"."),r.createElement("p",null,"However, in the current situation, we will use the tile coordinates of the fragment to determine what color the tile will be. This requires the integer part of the fragment coordinates to be taken, with the fractional part ignored."),r.createElement("p",null,"In GLSL, by using the built-in function ",r.createElement("code",null,"floor")," to floor a value (round a number to the nearest integer value at or below it), we remove the decimal component of the coordinates."),r.createElement("p",null,"The resultant coordinates are the tile coordinates of the fragment. Next, this tiling coordinates needs to be converted into normalized coordinates, since its value is currently dependent on the tiling resolution."),r.createElement("p",null,"By dividing the tile coordinates by the tiling resolution, we get back the normalized coordinates of the tile itself (to be specific, the lower-left corner of the tile)."),r.createElement("p",null,"These normalized coordinates are then passed to the ",r.createElement("code",null,"random")," ","function, whose returned value is then used as the grayscale color value of the tile."),r.createElement("p",null,"All fragments within a tile will have the same tile coordinates as they all belong to the same tile. This means that they will generate the same random number, ensuring that the entire tile is the same color."),r.createElement(c.A,{type:"h2"},"Combined Example - A tiled pattern with random centers"),r.createElement(E,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement(s.A,{code:p.trim(),type:"Fragment"}),r.createElement("p",null,"In this example, the concepts of the pattern example of glowing circles is combined with the concepts of the random tile example to randomize the position of the center of the circles."),r.createElement("p",null,"In this example, instead of taking the standard tile normalized coordinates of the center of the block ",r.createElement(l.A,{text:"(0.5, 0.5)"}),", we generate the tile normalized coordinate of the center randomly instead."),r.createElement("p",null,"We've seen in the previous example on how to generate a random number for each tile. We then use this number to select a value within a range of numbers."),r.createElement("p",null,"In this example, the center will only be placed on the diagonal of the tile that goes from the lower-left corner to the top-right corner, with the range of its X and Y coordinates limited to 0.1 to 0.9. A value is then selected within this range using the random number for the tile."),r.createElement("p",null,"To select a value within the set range using the random number as a factor, we can use a method called linear interpolation. But first, let's see what linear interpolation is."),r.createElement("p",null,"Let's consider a range 0.0 to 1.0. We need to get a number within this range using a certain factor provided to us. From this factor, we figure out how far into this range the number will be present, and return the number at that point."),r.createElement("p",null,"So if this value of this factor provided is 0.3, which is 30% in terms of percentages. So, this factor tells us that we should move 30% across the range of 0.0 - 1.0, starting at 0.0, and the number that is at this 30% mark should be returned."),r.createElement("p",null,"The number that is present 30% away from 0.0 and 70% away from 1.0 would be 0.3. Hence, the result of this calculation will be 0.3."),r.createElement("p",null,"This method of generating a value by travelling through a certain range of numbers by a certain factor, and returning the value at that point in the range, is called linear interpolation."),r.createElement("p",null,"The formula for this calculation is simple - given a range"," ",r.createElement(l.A,{text:"X - Y"})," and a factor ",r.createElement(l.A,{text:"F"})," that is within the range ",r.createElement(l.A,{text:"0.0 - 1.0"}),", the formula is:"),r.createElement("p",{className:"util text-center"},r.createElement(l.A,{text:"(X times (1 - F)) + (Y times F)"})),r.createElement("p",null,"In GLSL, a built-in function ",r.createElement("code",null,"mix")," can perform this calculation, which we use to calculate the value of the tile normalized coordinates for our random center, with the X and Y components being the same."),r.createElement("p",null,"Once the random center is calculated, the rest of the process is similar to the original glowing circle pattern example."),r.createElement("p",null,"In this example, we modified the position of the center of the circle, thereby displacing it from the center within the tile."),r.createElement("p",null,'In the next example, let\'s look at how the random factor can be used to make "decisions" on what should and should not be shown.'),r.createElement(c.A,{type:"h2"},"Combined Example - A tiled pattern with random diagonals"),r.createElement(q,null),r.createElement(c.A,{type:"h3"},"How it works"),r.createElement("p",null,"In this example, either diagonal needs to be shown based upon the random factor of the tile. First, let's take a look of the tile with diagonals plot again."),r.createElement("div",{className:"image util text-center"},r.createElement(o.S,{src:"../../images/intermediates/tile-diagonal-plot.png",alt:"Tile With Diagonals Graph Plot",style:{maxWidth:"65%"},__imageData:n(9178)}),r.createElement("br",null),r.createElement("a",{href:"https://www.transum.org/Maths/Activity/Graph/Desmos.asp",target:"_blank",rel:"noopener noreferrer"},"Image Generation Source")),r.createElement("p",null,"Let's name the diagonal starting from the lower-left corner and ending at the upper-right corner ",r.createElement("code",null,"diagonal 1"),", and name the other diagonal ",r.createElement("code",null,"diagonal 2"),"."),r.createElement("p",null,"For the initial diagonal example, we were ignoring the sign of the values of the coordinates of the diagonal points, which simplified calculations to see if a point was on either diagonal, or how far away it was from either diagonal."),r.createElement("p",null,"However, in the current example, we need to separately calculate the distance from ",r.createElement("code",null,"diagonal 1")," and ",r.createElement("code",null,"diagonal 2")," and, depending on which diagonal is to be shown, use either result."),r.createElement("p",null,"For ",r.createElement("code",null,"diagonal 1"),", both X and Y components of points on the diagonal increase together. By finding the difference between the X and Y components, we find the distance from ",r.createElement("code",null,"diagonal 1"),", which is similar to the original diagonal pattern example."),r.createElement("p",null,"For ",r.createElement("code",null,"diagonal 2"),", the X and Y components of points on the diagonal progress in opposite directions. The X components increases and the Y component decreases as you go from left to right, with the X component starting at the lowest value, and the Y component starting at the highest value."),r.createElement("p",null,"This also means that the signs of the X and Y components of the points on the diagonal are also always opposite to each other. Looking at the points on ",r.createElement("code",null,"diagonal 2"),", this becomes apparent."),r.createElement("p",null,"The coordinates of the top-left corner the square, which is the one of the ends of ",r.createElement("code",null,"diagonal 2"),", has coordinates"," ",r.createElement(l.A,{text:"(-0.5, 0.5)"}),". Similarly, the coordinates of the other end of the diagonal at the bottom-right corner are"," ",r.createElement(l.A,{text:"(0.5, -0.5)"}),"."),r.createElement("p",null,"This difference compared to ",r.createElement("code",null,"diagonal 1")," means that the calculation of the distance from ",r.createElement("code",null,"diagonal 2")," has to be done as an addition operation instead of a subtraction operation."),r.createElement("p",null,"This change accounts for these differences and ensures that the result of the calculation doesn't differ from what's expected."),r.createElement("p",null,"Once the distance of the fragment from both diagonals are calculated, we can use a decision factor to determine which one gets applied."),r.createElement(s.A,{code:B.trim(),type:"Fragment"}),r.createElement("p",null,"Looking at the code, you can see the principles we've discussed so far applied. For calculating the distance from ",r.createElement("code",null,"diagonal 1"),", we subtract the X and Y components of the fragment coordinates, same as our initial diagonal pattern example."),r.createElement("p",null,"For ",r.createElement("code",null,"diagonal 2"),", instead of performing a subtraction operation, we perform the addition operation instead, due to the nature of the X and Y components having opposite signs in"," ",r.createElement("code",null,"diagonal 2"),"."),r.createElement("p",null,"Once these two are calculated, we then calculate what the color of the fragment would be respective to each diagonal, which is similar to the original diagonal pattern example. After this, we calculate the random factor for the tile, and then decide which diagonal to show."),r.createElement("p",null,"Let's define a threshold of 0.5 on the random factor. If the random factor is below this threshold, then we'll show only"," ",r.createElement("code",null,"diagonal 2"),". However, if this is not the case, then"," ",r.createElement("code",null,"diagonal 1")," will be shown instead."),r.createElement("p",null,"In GLSL, a built-in function called ",r.createElement("code",null,"step")," allows us to achieve this objective. It is provided with the threshold and the value to check as parameters. If the value is below the threshold, it returns 0, or else it returns 1."),r.createElement("p",null,"By multiplying this result with the appropriate diagonal color, we cancel out the color value w.r.t diagonal that shouldn't be shown, and only maintain the color value w.r.t the diagonal which should be shown."),r.createElement("p",null,"For ",r.createElement("code",null,"diagonal 1"),", it should only be shown if the random factor exceeds the threshold of 0.5. So for this, the final factor for"," ",r.createElement("code",null,"diagonal 1")," was calculated by checking whether the random factor was exceeding the threshold using ",r.createElement("code",null,"step"),", and multiplying that result with the color value w.r.t."," ",r.createElement("code",null,"diagonal 1"),"."),r.createElement("p",null,"If the random factor is less than 0.5, ",r.createElement("code",null,"step")," will return 0, meaning that the effective color factor of ",r.createElement("code",null,"diagonal 1")," is 0."),r.createElement("p",null,"If the factor is above 0.5, ",r.createElement("code",null,"step")," will return 1, which means the effective color factor for ",r.createElement("code",null,"diagonal 1")," will be the calculated color value for it."),r.createElement("p",null,"Similar steps are followed for calculating the effective color factor for ",r.createElement("code",null,"diagonal 2"),", except we use the inverse of the value returned by ",r.createElement("code",null,"step")," (",r.createElement("code",null,"1.0 - step(...)"),") with the same threshold, using the user-defined function ",r.createElement("code",null,"invert_step"),"."),r.createElement("p",null,"Since the factors for both diagonals use the same threshold value, only either one of the diagonals will have a non-zero value, since if"," ",r.createElement("code",null,"step")," returns 1, then ",r.createElement("code",null,"invert_step")," will return 0, and vice-versa."),r.createElement("p",null,"The final diagonal factor of the fragment is chosen as the maximum value between the effective factor of ",r.createElement("code",null,"diagonal 1")," and"," ",r.createElement("code",null,"diagonal 2"),", since one of them will be 0, and the other will be greater than 0. In GLSL, this can be done using the built-in function"," ",r.createElement("code",null,"max"),"."),r.createElement("p",null,"The final color value of the fragment is set using this final chosen diagonal factor."),r.createElement("p",null,"An additional case can be added where both diagonals can be shown. This can be done by commenting lines 28 and 29, and uncommenting lines 30 and 31."),r.createElement("p",null,"The threshold for showing ",r.createElement("code",null,"diagonal 1")," becomes 0.4. If the random factor is more than 0.4, then the diagonal will be shown."),r.createElement("p",null,"Similaryly, the threshold for showing ",r.createElement("code",null,"diagonal 2")," becomes 0.6. If the random factor is less than 0.6, then the diagonal will be shown."),r.createElement("p",null,"This results in a range 0.4 to 0.6, where if the random factor of the tile lies within this range, then both diagonals will be shown on the tile."),r.createElement("p",null,"Since now there is a case where the effective color factor of both diagonals can be non-zero at the same time, the final diagonal color factor becomes whichever diagonal color factor is greater."),r.createElement("p",null,"If the color factor of the ",r.createElement("code",null,"diagonal 1")," is greater, this means that the fragment is closer to ",r.createElement("code",null,"diagonal 1")," than"," ",r.createElement("code",null,"diagonal 2"),", so the fragment should be colored w.r.t."," ",r.createElement("code",null,"diagonal 1"),"."),r.createElement("p",null,"Similarly, if the color factor of the ",r.createElement("code",null,"diagonal 2")," is greater, this means that the fragment is closer to"," ",r.createElement("code",null,"diagonal 2")," than ",r.createElement("code",null,"diagonal 1"),", so the fragment should be colored w.r.t. ",r.createElement("code",null,"diagonal 2"),"."),r.createElement("p",null,"Since we're already selecting the maximum color value w.r.t."," ",r.createElement("code",null,"diagonal 1")," and ",r.createElement("code",null,"diagonal 2"),", this case is already accounted for."),r.createElement("p",null,"The only change required is to change thresholds for either diagonal such that there will be an overlapping range where both diagonals can be shown for a tile."),r.createElement(c.A,{type:"h2"},"Additional Notes"),r.createElement("p",null,"The concepts taught so far show the basics of pattern image generation, random noise image generation, and a combination of both."),r.createElement("p",null,"These concepts can be further built upon to generate sub-patterns within patterns, or multiple layers of randomness and patterns combined together."),r.createElement("p",null,"These patterns and randomness can also be animated by including time as a factor as well, which opens up options for dynamic and animated image generation. Time can be used to influence the randomness of an image, or the patterns of an image."),r.createElement(c.A,{type:"h2"},"Summary"),r.createElement("ul",null,r.createElement("li",null,"Images can be generated without using external data, but just using some algorithmic logic within shaders."),r.createElement("li",null,"Images can be generated using patterns and procedural code, or with random values and noise."),r.createElement("li",null,"Logic from pattern/procedural images and random images can be stacked or combined with each other to create many more types of images."))),r.createElement(le.A,{previous:"/intermediates/color-2/",next:"/intermediates/mapping/"}))}},9178:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/126f926f1d17c611c97e82bb883a4e12/4e57b/tile-diagonal-plot.png","srcSet":"/static/126f926f1d17c611c97e82bb883a4e12/0f071/tile-diagonal-plot.png 122w,\\n/static/126f926f1d17c611c97e82bb883a4e12/ca706/tile-diagonal-plot.png 244w,\\n/static/126f926f1d17c611c97e82bb883a4e12/4e57b/tile-diagonal-plot.png 488w","sizes":"(min-width: 488px) 488px, 100vw"},"sources":[{"srcSet":"/static/126f926f1d17c611c97e82bb883a4e12/f5023/tile-diagonal-plot.webp 122w,\\n/static/126f926f1d17c611c97e82bb883a4e12/6db5f/tile-diagonal-plot.webp 244w,\\n/static/126f926f1d17c611c97e82bb883a4e12/4de15/tile-diagonal-plot.webp 488w","type":"image/webp","sizes":"(min-width: 488px) 488px, 100vw"}]},"width":488,"height":535}')},2788:function(e){e.exports=JSON.parse('{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/f4527576a4f483607646805a72b2c225/a5441/tile-plot.png","srcSet":"/static/f4527576a4f483607646805a72b2c225/87d1a/tile-plot.png 123w,\\n/static/f4527576a4f483607646805a72b2c225/b5cd3/tile-plot.png 245w,\\n/static/f4527576a4f483607646805a72b2c225/a5441/tile-plot.png 490w","sizes":"(min-width: 490px) 490px, 100vw"},"sources":[{"srcSet":"/static/f4527576a4f483607646805a72b2c225/0e222/tile-plot.webp 123w,\\n/static/f4527576a4f483607646805a72b2c225/f86ab/tile-plot.webp 245w,\\n/static/f4527576a4f483607646805a72b2c225/5bbb9/tile-plot.webp 490w","type":"image/webp","sizes":"(min-width: 490px) 490px, 100vw"}]},"width":490,"height":538}')}}]);
//# sourceMappingURL=component---src-pages-intermediates-image-generation-js-db9722606bb210aa4aa8.js.map