"use strict";(self.webpackChunkshader_tutorial=self.webpackChunkshader_tutorial||[]).push([[865],{4515:function(e,t,r){r.r(t),r.d(t,{default:function(){return P}});var i=r(4794),a=r(6540),n=(r(6449),r(3514),r(7684)),o=r(3461),l=r(6417),s=r(782),c="void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}";const h="attribute vec4 vertexPosition;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vertexPosition;\n}",m=c,u={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4"}},fragment:{attributeLocations:{},uniformLocations:{}}},d=n.vt();var p=(0,l.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]]},{0:t,1:r}=(0,a.useState)(null),{0:i,1:n}=(0,a.useState)(null),{0:l,1:c}=(0,a.useState)(null),{0:p,1:v}=(0,a.useState)({vertices:null}),f=(0,a.useRef)();return(0,a.useEffect)((()=>{if(null!==f.current){const e=new s.A(f.current,d,!0);return r(e),()=>{r(null),e.destroy()}}}),[f]),(0,a.useEffect)((0,o.sT)(null!==t,(()=>{n(t.createShaderProgram(h,m))})),[t]),(0,a.useEffect)((0,o.sT)(null!==i,(()=>{c(t.getDataLocations(i,u))})),[i]),(0,a.useEffect)((0,o.sT)(null!==l,(()=>{v({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),p.vertices)})})),[l]),(0,a.useEffect)((0,o.sT)(null!==p.vertices,(()=>{let r=!0;const a=()=>{t.renderScene((t=>{let{gl:n,projectionMatrix:o,viewMatrix:s,modelMatrix:c}=t;r&&(n.bindBuffer(n.ARRAY_BUFFER,p.vertices),n.vertexAttribPointer(l.vertex.attributeLocations.vertexPosition,3,n.FLOAT,!1,0,0),n.enableVertexAttribArray(l.vertex.attributeLocations.vertexPosition),n.useProgram(i),n.uniformMatrix4fv(l.vertex.uniformLocations.projectionMatrix,!1,o),n.uniformMatrix4fv(l.vertex.uniformLocations.viewMatrix,!1,s),n.uniformMatrix4fv(l.vertex.uniformLocations.modelMatrix,!1,c),n.drawArrays(n.LINE_LOOP,0,e.vertices.length),requestAnimationFrame(a))}))};return requestAnimationFrame(a),()=>{r=!1}})),[p]),a.createElement("div",{className:"util text-center",style:{padding:"1rem"}},a.createElement("canvas",{width:"640",height:"480",ref:f},"Cannot run WebGL examples (not supported)"),a.createElement("pre",{className:"util text-left"},("\nTriangle Vertices:\n    Vertex 1: "+(0,o.NW)(e.vertices[0])+"\n    Vertex 2: "+(0,o.NW)(e.vertices[1])+"\n    Vertex 3: "+(0,o.NW)(e.vertices[2])+"\n").trim()))}));const v="attribute vec4 vertexPosition;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nmat4 rotateZ(float angle) {\n  mat4 rotationMatrix;\n  rotationMatrix[0] = vec4(cos(angle), sin(angle), 0, 0);\n  rotationMatrix[1] = vec4(-sin(angle), cos(angle), 0, 0);\n  rotationMatrix[2] = vec4(0, 0, 1, 0);\n  rotationMatrix[3] = vec4(0, 0, 0, 1);\n  return rotationMatrix;\n}\n\nvoid main() {\n  float angleRadians = (time / 30.0) * PI / 180.0;\n  mat4 rotatedModelMatrix = rotateZ(angleRadians) * modelMatrix;\n  gl_Position = projectionMatrix * viewMatrix * rotatedModelMatrix * vertexPosition;\n}",f=c,x={vertex:{attributeLocations:{vertexPosition:"vec4"},uniformLocations:{modelMatrix:"mat4",viewMatrix:"mat4",projectionMatrix:"mat4",time:"float"}},fragment:{attributeLocations:{},uniformLocations:{}}},w=n.vt();var E=(0,l.A)((()=>{const e={vertices:[[0,1,0],[-.866,-.5,0],[.866,-.5,0]]},{0:t,1:r}=(0,a.useState)(null),{0:i,1:n}=(0,a.useState)(null),{0:l,1:c}=(0,a.useState)(null),{0:h,1:m}=(0,a.useState)({vertices:null}),{0:u,1:d}=(0,a.useState)("undefined"!=typeof performance?performance.now():0),p=(0,a.useRef)();return(0,a.useEffect)((()=>{if(null!==p.current){const e=new s.A(p.current,w,!0);return r(e),()=>{r(null),e.destroy()}}}),[p]),(0,a.useEffect)((0,o.sT)(null!==t,(()=>{n(t.createShaderProgram(v,f))})),[t]),(0,a.useEffect)((0,o.sT)(null!==i,(()=>{c(t.getDataLocations(i,x))})),[i]),(0,a.useEffect)((0,o.sT)(null!==l,(()=>{m({vertices:t.createStaticDrawArrayBuffer(e.vertices.flat(),h.vertices)})})),[l]),(0,a.useEffect)((0,o.sT)(null!==h.vertices,(()=>{let r=!0,a=parseInt("undefined"!=typeof performance?performance.now():(0).toString());const n=()=>{t.renderScene((t=>{let{gl:o,projectionMatrix:s,viewMatrix:c,modelMatrix:m}=t;if(!r)return;const u=parseInt("undefined"!=typeof performance?performance.now():(0).toString());u-a>100&&(a=u,d(u)),o.bindBuffer(o.ARRAY_BUFFER,h.vertices),o.vertexAttribPointer(l.vertex.attributeLocations.vertexPosition,3,o.FLOAT,!1,0,0),o.enableVertexAttribArray(l.vertex.attributeLocations.vertexPosition),o.useProgram(i),o.uniformMatrix4fv(l.vertex.uniformLocations.projectionMatrix,!1,s),o.uniformMatrix4fv(l.vertex.uniformLocations.viewMatrix,!1,c),o.uniformMatrix4fv(l.vertex.uniformLocations.modelMatrix,!1,m),o.uniform1f(l.vertex.uniformLocations.time,u),o.drawArrays(o.LINE_LOOP,0,e.vertices.length),requestAnimationFrame(n)}))};return requestAnimationFrame(n),()=>{r=!1}})),[h]),a.createElement("div",{className:"util text-center",style:{padding:"1rem"}},a.createElement("canvas",{width:"640",height:"480",ref:p},"Cannot run WebGL examples (not supported)"),a.createElement("pre",{className:"util text-left"},("\nTriangle Vertices:\n    Vertex 1: "+(0,o.NW)(e.vertices[0])+"\n    Vertex 2: "+(0,o.NW)(e.vertices[1])+"\n    Vertex 3: "+(0,o.NW)(e.vertices[2])+"\n").trim()),a.createElement("pre",{className:"util text-left"},"Time: ",u))})),b=r(9460),y=r(7722),g=r(7154),M=r(6042),A=r(7570),T=r(2007),L=r(2269);var P=e=>{let{location:{pathname:t}}=e;return a.createElement(A.A,null,a.createElement(L.A,{pathname:t,title:"Shader Basics - Vertex Shader",description:"A look into the basics of a GPU vertex shader.",keywords:["vertex","shader","basics"]}),a.createElement(b.A,null,a.createElement("h1",null,"Shader Basics - Vertex Shader"),a.createElement(M.A,{type:"h2"},"What is a vertex shader"),a.createElement("p",null,'Vertex shaders process vertices and tells what their coordinates are in "clip-space", which is a space that makes it easy for computers to understand which vertices are visible to the camera and which are not and have to be cut or "clipped" out.'),a.createElement("p",null,"This makes it faster for GPUs during later stages since they have less data to work with."),a.createElement("p",null,"They perform this process by receiving a single vertex from the list of vertices as input, and return a result that determines where the vertex should be present within clip-space,"),a.createElement("p",null,"Since this shader is executed per vertex on all vertices passed to the GPU pipeline, any operation that requires modifications to the vertex can be performed during in this shader, as long as the final output is where the vertex is to be placed in the clip-space."),a.createElement(M.A,{type:"h2"},"An example - A triangle"),a.createElement("p",null,"Below is an example of the work simple vertex shader:"),a.createElement(p,null),a.createElement("p",null,"We can see that, for a provided set of vertex positions, a shape is drawn. The points on the canvas where the vertices are placed is determined by the vertex shader (in part)."),a.createElement(M.A,{type:"h3"},"How it works"),a.createElement("p",null,"Let's look at the code for the vertex shader"),a.createElement(g.A,{code:h.trim(),type:"Vertex"}),a.createElement("p",null,"Even though this is WebGL (which is similar to OpenGL), the concepts applied here can be mapped across other languages as well."),a.createElement("p",null,"The ",a.createElement("code",null,"void main")," function is the primary function that is executed when the vertex shader (and any shader for that matter) is to executed, and should contain the primary shader code to be executed. This is similar to C/C++, where the ",a.createElement("code",null,"main")," function in the primary entry is the one that is executed when starting the application."),a.createElement("p",null,"The ",a.createElement("code",null,"vertexPosition")," attribute is a property that receives the initial coordinates of vertex as it's primary input, the one that it should transform into the final clip-space coordinates."),a.createElement("p",null,'It is defined as an attribute as it is a description of a certain "attribute" of the vertex (in this case, its position), can change based on which vertex is being operated on, and are always read-only.'),a.createElement("p",null,"Do note that the type of it is set to ",a.createElement("code",null,"vec4"),", which means it's a vector of size 4, but vertices passed to the vertex shader need not be limited to just this type, but a ",a.createElement("code",null,"vec4")," type would provide the most detail about the coordinates of a vertex."),a.createElement("p",null,"The ",a.createElement("code",null,"modelMatrix"),", ",a.createElement("code",null,"viewMatrix"),", and"," ",a.createElement("code",null,"projectionMatrix")," uniforms are additional properties passed separately to the vertex shader. Unlike the ",a.createElement("code",null,"vertexPosition")," ","attribute, these values need to be the same for every vertex of the object/primitive operated on, which is why it's defined as uniform (it's uniform/same for every data being operated on by shaders)."),a.createElement("p",null,"Similar to the ",a.createElement("code",null,"vertexPosition")," attribute, the types of these uniforms is ",a.createElement("code",null,"mat4"),", which means a matrix of size 4x4. Again, they need not be limited to this type, and can be a matrix of size upto 4x4, or even a vector of size upto 4."),a.createElement("p",null,"Here's a simple explanation of the uniform variables being used:"),a.createElement("dl",null,a.createElement("dt",null,"1. ",a.createElement("strong",null,"modelMatrix")),a.createElement("dd",null,a.createElement("p",null,"This matrix is used to represent where the vertex exists within the world. It represents the center of the model being drawn by the shader, which has been translated, rotated, and/or scaled into the necessary position in the world."),a.createElement("p",null,"Multiplying the vertex coordinate with this matrix will provide the result of where the vertex exists in the world w.r.t. to the center of the model it belongs to.")),a.createElement("dt",null,"2. ",a.createElement("strong",null,"viewMatrix")),a.createElement("dd",null,a.createElement("p",null,"This matrix is used to represent where the vertex exists relative to your view, or more specifically the cameras view. Once the vertex position is known in the world (by multiplying it with the"," ",a.createElement("code",null,"modelMatrix"),"), it's position relative to the camera can be determined by multiplying it with this matrix.")),a.createElement("dt",null,"3. ",a.createElement("strong",null,"projectionMatrix")),a.createElement("dd",null,a.createElement("p",null,"This matrix is used to represent the perspective of the camera. Things like field-of-view, aspect ratio, and others can distort and affect the way objects look. Likewise, the scale of objects can differ depending on distance, which needs to be accounted for."),a.createElement("p",null,"By multiplying the projection matrix onto the result of the previous calculations, we are able to map the vertex onto the perspective of the camera, taking into account it's aspect ratio, field-of-view, and the farthest and closest it can see."),a.createElement("p",null,"This final calculation provides us the coordinates of the vertex in clip-space."))),a.createElement("p",null,"From the above explanation, it should be more obvious why the operation on line 8 in the vertex shader is performed."),a.createElement("ol",null,a.createElement("li",null,"The vertex position is taken and multiplied with the model matrix to determine where that vertex lies w.r.t the center of the model in the world."),a.createElement("li",null,"The result is then multiplied with the view matrix to determine where the vertex is positioned w.r.t the camera"),a.createElement("li",null,"Finally the result of the second operation is multiplied with the projection matrix to determine where the vertex is located within the perspective of the camera.")),a.createElement("p",null,"This final result is the output of the vertex shader, which, in WebGL, is stored in the special variable ",a.createElement("code",null,"gl_Position"),"."),a.createElement(M.A,{type:"h2"},"Another example - A rotating triangle"),a.createElement("p",null,"Since the vertex shader determines where each vertex is w.r.t the perspective-space of the screen, by passing it the necessary transformations to apply to the vertices, it can move their positions as required."),a.createElement(E,null),a.createElement(M.A,{type:"h3"},"How it works"),a.createElement(g.A,{code:v.trim(),type:"Vertex"}),a.createElement("p",null,"The time elapsed since the start of the animation is passed to the vertex shader. From this, the angle is calculated by dividing the elapsed time by 30, so that a degree turn occurs every 30ms."),a.createElement("p",null,"This angle is calculated in degrees, which needs to be converted to radians, which is done by mulitplying the angle by"," ",a.createElement(y.A,{text:"pi"})," and dividing the product by 180."),a.createElement("p",null,"By keeping the calculations in float, we don't round of the decimals, ensuring that the angle always changes (primarily in the fractional part) with every frame. The function"),a.createElement("p",null,"This angle is then used to create a rotation matrix. The function"," ",a.createElement("code",null,"rotateZ")," creates a rotation matrix that rotates around the Z-axis. The details about this matrix is in the reference link provided in the matrix mathematics section of the"," ",a.createElement(i.Link,{to:"/basics/mathematics/"},"mathematics primer")," chapter."),a.createElement("p",null,"The rotation matrix is multiplied with the model matrix to rotate the entire model according to the time elapsed. Then the same process as with the previous example is followed to calculate the final coordinates of the vertex."),a.createElement(M.A,{type:"h2"},"Additional Notes"),a.createElement("p",null,"This rotation matrix can be more easily created outside the shader since there are utility libraries that provide helper functions for performing such operations (OpenGL has the GLM library for such tasks)."),a.createElement("p",null,"However, for the sake of understanding how the rotation works, it is shown within the shader."),a.createElement("p",null,"We also calculate the multiplication of the model, view, and projection matrix within the vertex shader itself. This is a calculation whose result never changes for any vertex."),a.createElement("p",null,"Since the result of the calculation is a constant, it can be done once outside the GPU and then passed as a ",a.createElement("code",null,"uniform")," to the vertex shader. This optimization will be done in future examples and chapters."),a.createElement("p",null,"This will be visible in vertex shaders where we pass an"," ",a.createElement("code",null,"uniform")," called ",a.createElement("code",null,"mvpMatrix"),", which is the multiplication product of the model, view, and projection matrices. Any additional transformations (like rotations) will also be calculated beforehand and then passed through this uniform."),a.createElement(M.A,{type:"h2"},"Summary"),a.createElement("ul",null,a.createElement("li",null,"The vertex shader receives a vertex from a list of vertices and plots it onto a space known as the clip-space."),a.createElement("li",null,"The vertex shader requires certain values provided to it about the model, view, and projection, in order to be able to determine where the final position of the vertex is."),a.createElement("li",null,"Since the shader determines where the vertex is present within this space, it can manipulate and transform the vertex to be placed wherever required."))),a.createElement(T.A,{previous:"/basics/mathematics/",next:"/basics/color/"}))}}}]);
//# sourceMappingURL=component---src-pages-basics-vertex-shader-js-20b0689037b79db2d450.js.map