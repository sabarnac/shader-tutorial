{"version":3,"file":"component---src-pages-basics-fragment-shader-js-4934d6ef64d93e25c81b.js","mappings":"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","sources":["webpack://shader-tutorial/./src/components/basics/fragment-shader/first-example-shaders.js","webpack://shader-tutorial/./src/components/basics/fragment-shader/first-example/fragment.glsl","webpack://shader-tutorial/./src/components/basics/fragment-shader/first-example.js","webpack://shader-tutorial/./src/components/basics/fragment-shader/first-example/vertex.glsl","webpack://shader-tutorial/./src/components/basics/fragment-shader/common/vertex.glsl","webpack://shader-tutorial/./src/components/basics/fragment-shader/second-example-shaders.js","webpack://shader-tutorial/./src/components/basics/fragment-shader/second-example/fragment.glsl","webpack://shader-tutorial/./src/components/basics/fragment-shader/second-example.js","webpack://shader-tutorial/./src/components/basics/fragment-shader/third-example-shaders.js","webpack://shader-tutorial/./src/components/basics/fragment-shader/third-example/fragment.glsl","webpack://shader-tutorial/./src/components/basics/fragment-shader/third-example.js","webpack://shader-tutorial/./src/pages/basics/fragment-shader.js"],"sourcesContent":["import fragmentShader from \"!raw-loader!./first-example/fragment.glsl\";\nimport vertexShader from \"!raw-loader!./first-example/vertex.glsl\";\n\nexport const firstVertexShaderSource = vertexShader;\nexport const firstFragmentShaderSource = fragmentShader;\n","export default \"void main() {\\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { firstFragmentShaderSource, firstVertexShaderSource } from \"./first-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst triangleModelPosition = mat4.create();\n\nconst FragmentShaderFirstExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [triangleBuffer, updateTriangleBuffer] = useState({ vertices: null });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        triangleModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          firstVertexShaderSource,\n          firstFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateTriangleBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          triangleBuffer.vertices,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(triangleBuffer.vertices !== null, () => {\n      let shouldRender = true;\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n            mat4.multiply(mvpMatrix, projectionMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n\n            gl.drawArrays(gl.TRIANGLES, 0, triangle.vertices.length);\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [triangleBuffer],\n  );\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nTriangle Vertices:\n    Vertex 1: ${coordArrToString(triangle.vertices[0])}\n    Vertex 2: ${coordArrToString(triangle.vertices[1])}\n    Vertex 3: ${coordArrToString(triangle.vertices[2])}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(FragmentShaderFirstExample);\n","export default \"attribute vec4 vertexPosition;\\n\\nuniform mat4 mvpMatrix;\\n\\nvoid main() {\\n  gl_Position = mvpMatrix * vertexPosition;\\n}\";","export default \"attribute vec4 vertexPosition;\\nattribute vec3 vertexColor;\\n\\nuniform mat4 mvpMatrix;\\n\\nvarying highp vec3 color;\\n\\nvoid main() {\\n  gl_Position = mvpMatrix * vertexPosition;\\n  color = vertexColor;\\n}\";","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./second-example/fragment.glsl\";\n\nexport const secondVertexShaderSource = vertexShader;\nexport const secondFragmentShaderSource = fragmentShader;\n","export default \"varying lowp vec3 color;\\n\\nvoid main() {\\n  gl_FragColor = vec4(color, 1);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { secondFragmentShaderSource, secondVertexShaderSource } from \"./second-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexColor: \"vec3\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {},\n  },\n};\n\nconst triangleModelPosition = mat4.create();\n\nconst FragmentShaderSecondExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n    colors: [\n      [1.0, 0.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 0.0, 1.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [triangleBuffer, updateTriangleBuffer] = useState({\n    vertices: null,\n    colors: null,\n  });\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        triangleModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          secondVertexShaderSource,\n          secondFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateTriangleBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          triangleBuffer.vertices,\n        ),\n        colors: webGlRef.createStaticDrawArrayBuffer(\n          triangle.colors.flat(),\n          triangleBuffer.colors,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(\n      triangleBuffer.vertices !== null && triangleBuffer.colors !== null,\n      () => {\n        let shouldRender = true;\n\n        const renderScene = () => {\n          webGlRef.renderScene(\n            ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n              if (!shouldRender) {\n                return;\n              }\n\n              const mvpMatrix = mat4.create();\n              mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n              mat4.multiply(mvpMatrix, projectionMatrix, mvpMatrix);\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.vertices);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexPosition,\n              );\n\n              gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.colors);\n              gl.vertexAttribPointer(\n                shaderInfo.vertex.attributeLocations.vertexColor,\n                3,\n                gl.FLOAT,\n                false,\n                0,\n                0,\n              );\n              gl.enableVertexAttribArray(\n                shaderInfo.vertex.attributeLocations.vertexColor,\n              );\n\n              gl.useProgram(shaderProgram);\n\n              gl.uniformMatrix4fv(\n                shaderInfo.vertex.uniformLocations.mvpMatrix,\n                false,\n                mvpMatrix,\n              );\n\n              gl.drawArrays(gl.TRIANGLES, 0, triangle.vertices.length);\n\n              requestAnimationFrame(renderScene);\n            },\n          );\n        };\n        requestAnimationFrame(renderScene);\n\n        return () => {\n          shouldRender = false;\n        };\n      },\n    ),\n    [triangleBuffer],\n  );\n\n  const colorCoordMap = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nTriangle Vertices:\n    Vertex 1: ${coordArrToString(triangle.vertices[0])}\n    Vertex 2: ${coordArrToString(triangle.vertices[1])}\n    Vertex 3: ${coordArrToString(triangle.vertices[2])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nVertex Colors:\n    Vertex 1: ${coordArrToString(triangle.colors[0], colorCoordMap)}\n    Vertex 2: ${coordArrToString(triangle.colors[1], colorCoordMap)}\n    Vertex 3: ${coordArrToString(triangle.colors[2], colorCoordMap)}\n`.trim()}\n      </pre>\n    </div>\n  );\n};\n\nexport default wrapExample(FragmentShaderSecondExample);\n","import vertexShader from \"!raw-loader!./common/vertex.glsl\";\nimport fragmentShader from \"!raw-loader!./third-example/fragment.glsl\";\n\nexport const thirdVertexShaderSource = vertexShader;\nexport const thirdFragmentShaderSource = fragmentShader;\n","export default \"varying highp vec3 color;\\n\\nuniform highp float time;\\n\\nvoid main() {\\n  highp float colorShift = cos(time / 500.0);\\n  gl_FragColor = vec4(clamp(color - colorShift, 0.0, 1.0), 1.0);\\n}\";","import { mat4 } from \"gl-matrix\"\nimport React, { useEffect, useRef, useState } from \"react\"\n\nimport { coordArrToString, runOnPredicate } from \"../../util\"\nimport wrapExample from \"../../webgl-example-view\"\nimport WebGlWrapper from \"../../webgl-wrapper\"\nimport { thirdFragmentShaderSource, thirdVertexShaderSource } from \"./third-example-shaders\"\n\nconst shaderProgramInfo = {\n  vertex: {\n    attributeLocations: {\n      vertexPosition: \"vec4\",\n      vertexColor: \"vec3\",\n    },\n    uniformLocations: {\n      mvpMatrix: \"mat4\",\n    },\n  },\n  fragment: {\n    attributeLocations: {},\n    uniformLocations: {\n      time: \"float\",\n    },\n  },\n};\n\nconst triangleModelPosition = mat4.create();\n\nconst FragmentShaderThirdExample = () => {\n  const triangle = {\n    vertices: [\n      [0.0, 1.0, 0.0],\n      [-0.866, -0.5, 0.0],\n      [0.866, -0.5, 0.0],\n    ],\n    colors: [\n      [1.0, 0.0, 0.0],\n      [0.0, 1.0, 0.0],\n      [0.0, 0.0, 1.0],\n    ],\n  };\n  const [webGlRef, updateWebGlRef] = useState(null);\n  const [shaderProgram, updateShaderProgram] = useState(null);\n  const [shaderInfo, updateShaderInfo] = useState(null);\n  const [triangleBuffer, updateTriangleBuffer] = useState({\n    vertices: null,\n    colors: null,\n  });\n\n  const [time, updateTime] = useState(\n    typeof performance !== \"undefined\" ? performance.now() : 0.0,\n  );\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    if (canvasRef.current !== null) {\n      const newWebGlRef = new WebGlWrapper(\n        canvasRef.current,\n        triangleModelPosition,\n      );\n      updateWebGlRef(newWebGlRef);\n\n      return () => {\n        updateWebGlRef(null);\n        newWebGlRef.destroy();\n      };\n    }\n  }, [canvasRef]);\n\n  useEffect(\n    runOnPredicate(webGlRef !== null, () => {\n      updateShaderProgram(\n        webGlRef.createShaderProgram(\n          thirdVertexShaderSource,\n          thirdFragmentShaderSource,\n        ),\n      );\n    }),\n    [webGlRef],\n  );\n\n  useEffect(\n    runOnPredicate(shaderProgram !== null, () => {\n      updateShaderInfo(\n        webGlRef.getDataLocations(shaderProgram, shaderProgramInfo),\n      );\n    }),\n    [shaderProgram],\n  );\n\n  useEffect(\n    runOnPredicate(shaderInfo !== null, () => {\n      updateTriangleBuffer({\n        vertices: webGlRef.createStaticDrawArrayBuffer(\n          triangle.vertices.flat(),\n          triangleBuffer.vertices,\n        ),\n        colors: webGlRef.createStaticDrawArrayBuffer(\n          triangle.colors.flat(),\n          triangleBuffer.colors,\n        ),\n      });\n    }),\n    [shaderInfo],\n  );\n\n  useEffect(\n    runOnPredicate(triangleBuffer.vertices !== null, () => {\n      let shouldRender = true;\n      let then = parseInt(\n        typeof performance !== \"undefined\"\n          ? performance.now()\n          : (0.0).toString(),\n      );\n\n      const renderScene = () => {\n        webGlRef.renderScene(\n          ({ gl, projectionMatrix, viewMatrix, modelMatrix }) => {\n            if (!shouldRender) {\n              return;\n            }\n\n            const currentTime = parseInt(\n              typeof performance !== \"undefined\"\n                ? performance.now()\n                : (0.0).toString(),\n            );\n\n            if (currentTime - then > 100) {\n              then = currentTime;\n              updateTime(currentTime);\n            }\n\n            const mvpMatrix = mat4.create();\n            mat4.multiply(mvpMatrix, viewMatrix, modelMatrix);\n            mat4.multiply(mvpMatrix, projectionMatrix, mvpMatrix);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.vertices);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexPosition,\n            );\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer.colors);\n            gl.vertexAttribPointer(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n              3,\n              gl.FLOAT,\n              false,\n              0,\n              0,\n            );\n            gl.enableVertexAttribArray(\n              shaderInfo.vertex.attributeLocations.vertexColor,\n            );\n\n            gl.useProgram(shaderProgram);\n\n            gl.uniformMatrix4fv(\n              shaderInfo.vertex.uniformLocations.mvpMatrix,\n              false,\n              mvpMatrix,\n            );\n            gl.uniform1f(\n              shaderInfo.fragment.uniformLocations.time,\n              currentTime,\n            );\n\n            gl.drawArrays(gl.TRIANGLES, 0, triangle.vertices.length);\n\n            requestAnimationFrame(renderScene);\n          },\n        );\n      };\n      requestAnimationFrame(renderScene);\n\n      return () => {\n        shouldRender = false;\n      };\n    }),\n    [triangleBuffer],\n  );\n\n  const colorCoordMap = { x: \"r\", y: \"g\", z: \"b\" };\n\n  return (\n    <div className=\"util text-center\" style={{ padding: \"1rem\" }}>\n      <canvas width=\"640\" height=\"480\" ref={canvasRef}>\n        Cannot run WebGL examples (not supported)\n      </canvas>\n      <pre className=\"util text-left\">\n        {`\nTriangle Vertices:\n    Vertex 1: ${coordArrToString(triangle.vertices[0])}\n    Vertex 2: ${coordArrToString(triangle.vertices[1])}\n    Vertex 3: ${coordArrToString(triangle.vertices[2])}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">\n        {`\nVertex Colors:\n    Vertex 1: ${coordArrToString(triangle.colors[0], colorCoordMap)}\n    Vertex 2: ${coordArrToString(triangle.colors[1], colorCoordMap)}\n    Vertex 3: ${coordArrToString(triangle.colors[2], colorCoordMap)}\n`.trim()}\n      </pre>\n      <pre className=\"util text-left\">Time: {time}</pre>\n    </div>\n  );\n};\n\nexport default wrapExample(FragmentShaderThirdExample);\n","import { Link } from \"gatsby\";\nimport { StaticImage } from \"gatsby-plugin-image\";\nimport React from \"react\";\n\nimport FragmentShaderFirstExample from \"../../components/basics/fragment-shader/first-example\";\nimport { firstFragmentShaderSource } from \"../../components/basics/fragment-shader/first-example-shaders\";\nimport FragmentShaderSecondExample from \"../../components/basics/fragment-shader/second-example\";\nimport {\n  secondFragmentShaderSource,\n  secondVertexShaderSource,\n} from \"../../components/basics/fragment-shader/second-example-shaders\";\nimport FragmentShaderThirdExample from \"../../components/basics/fragment-shader/third-example\";\nimport { thirdFragmentShaderSource } from \"../../components/basics/fragment-shader/third-example-shaders\";\nimport Content from \"../../components/content\";\nimport GlslCodeHighlight from \"../../components/glsl-code-highlight\";\nimport Heading from \"../../components/heading\";\nimport Layout from \"../../components/layout\";\nimport PageChange from \"../../components/page-change\";\nimport Seo from \"../../components/seo\";\n\nconst FragmentShaderPage = ({ location: { pathname } }) => (\n  <Layout>\n    <Seo\n      pathname={pathname}\n      title=\"Shader Basics - Fragment Shader\"\n      description=\"A look into the basics of a GPU fragment shader.\"\n      keywords={[\"fragment\", \"shader\", \"basics\"]}\n    />\n    <Content>\n      <h1>Shader Basics - Fragment Shader</h1>\n      <Heading type=\"h2\">What is a fragment shader</Heading>\n      <p>\n        Similar to how a vertex shader operates on vertices of an object, a\n        fragment shader operates on a \"fragment\" of an object and tells what the\n        color of that fragment is supposed to be.\n      </p>\n      <p>\n        Since it is executed per fragment on all fragments generated by the GPU\n        pipeline, any operation that requires modification of the color of the\n        fragment (like brightening due to lights or darkening due to shadows)\n        can be done through the fragment shader.\n      </p>\n      <Heading type=\"h2\">What is a fragment</Heading>\n      <p>\n        As previously mentioned in the{\" \"}\n        <Link to=\"/basics/render-pipeline/\">render pipeline overview</Link>, a\n        fragment is a sample of a primitive that contains certain information\n        required for coloring a pixel.\n      </p>\n      <p>\n        A pixel can consist of multiple fragments, because, depending upon what\n        area of the primitive the pixel covers, there can be multiple values\n        present within the pixel, which have to either be combined, or just one\n        selected at random.\n      </p>\n      <p>\n        As an example, take a circle that is to be rendered on a screen of size\n        8x8 pixels (total of 64 pixels), as shown by the image below:\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/basics/fragment-1.png\"\n          alt=\"Fragment Example Part 1\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        After splitting the circle into 16 equal parts, a decision on what the\n        color of each pixel should be needs to be made. For pixels with just a\n        single color, they just adopt that color.\n      </p>\n      <p>\n        However, the other pixels contain two colors, as they contain both the\n        circle and the background. This requires a decision needs to be made as\n        to what the final color of the pixel should be.\n      </p>\n      <p>\n        In order to do this, a sample can be taken from somewhere in the area\n        the pixel covers, and fix that as the final color of the pixel. This\n        sample is what is considered a \"fragment\".\n      </p>\n      <p>\n        If only one \"fragment\" is requuired per pixel, then a sample from the\n        center of each pixel can be taken, resulting in the render below:\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/basics/fragment-2.png\"\n          alt=\"Fragment Example Part 2\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        Instead, if multiple fragments are taken, a final color value for the\n        pixel can be interpolated based on what the color of each fragment is.\n      </p>\n      <p>\n        In the case of the circle, by taking 4 \"fragments\" (one from\n        approximately each corner), the final color would be a reddish-pink,\n        since two of these fragments would have the color red, and the other two\n        would have the color white:\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/basics/fragment-3.png\"\n          alt=\"Fragment Example Part 3\"\n          style={{ maxWidth: \"65%\" }}\n        />\n      </div>\n      <p>\n        While not as accurate as our initial image, it is still closer to\n        reality compared to the first result. If you're not sure how, let's see\n        how these images look at 30px width and height.\n      </p>\n      <div className=\"image util text-center\">\n        <StaticImage\n          src=\"../../images/basics/fragment-2.png\"\n          alt=\"Fragment Example Part 2 Mini\"\n          style={{ maxWidth: \"30px\" }}\n        />\n        <br />\n        <StaticImage\n          src=\"../../images/basics/fragment-3.png\"\n          alt=\"Fragment Example Part 3 Mini\"\n          style={{ maxWidth: \"30px\" }}\n        />\n      </div>\n      <p>\n        At a much smaller scale, the second result looks considerably more like\n        a circle than the first result. This is how certain anti-aliasing\n        methods works.\n      </p>\n      <p>\n        Along with this case, primitives can also overlap other primitives,\n        which means fragments can overlap other fragments. This requires\n        fragments to be discarded if they are covered, or combined with other\n        fragments if some of them are not opaque (a fragment from a translucent\n        glass over an object).\n      </p>\n      <p>\n        Do note that in DirectX, fragments are called pixels (and by extension,\n        fragment shaders are called pixel shaders), but that name isn't\n        technically accurate.\n      </p>\n      <Heading type=\"h2\">An example - The triangle returns</Heading>\n      <p>\n        Let's go back to our standard triangle example. Previously, we only had\n        the edges of the triangle drawn to provide an explanation on how vertex\n        shaders work. This time we'll be coloring the entire triangle.\n      </p>\n      <FragmentShaderFirstExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <GlslCodeHighlight\n        code={firstFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        Looking at the code, you'll see the fragment shader is extremely simple,\n        it just generates a <code>vec4</code> of <code>1.0, 0.0, 0.0, 0.0</code>\n        , which corresponds to R, G, B, and A values respectively. The color is\n        then assigned to the special output variable defined in WebGL called{\" \"}\n        <code>gl_FragColor</code> (WebGL Fragment Color)\n      </p>\n      <p>\n        In the vertex shader examples, WebGL was told that the three vertices\n        provided were part of a line loop, meaning they are coordinates that\n        define a line that loops back around to the start.\n      </p>\n      <p>\n        So when WebGL would call the fragment shader, it would color the\n        fragments of the lines that joined the first and second vertex, then the\n        line connecting the second and third vertex, and (since it was defined\n        to be a loop), the line connecting third and first vertex.\n      </p>\n      <p>\n        In this case, since WebGL is told the vertices belong to a triangle, the\n        3 vertices are taken and used to create a triangle, and that triangle is\n        then split into fragments, with each fragment then colored by the\n        fragment shader.\n      </p>\n      <Heading type=\"h2\">Another example - A triangular color wheel</Heading>\n      <p>\n        What if we wanted to define our own color values that should be used to\n        color the pixels? Just like with the vertex shader, we can pass our own\n        needed values to the fragment shader.\n      </p>\n      <p>\n        These values have to be passed through the vertex shader, meaning that\n        when the vertex shader receives the value, it has to set that value to\n        another variable, which is then received by the fragment shader.\n      </p>\n      <p>\n        One very important note is that you can only define the color values of\n        each vertex, and not each fragment or pixel, since their number is an\n        unknown (you won't know how many fragments may be generated, or pixels\n        that the object may cover).\n      </p>\n      <p>\n        So if we can only define color values for each vertex, how will the\n        fragment shader know what color it should receive for pixels that are\n        inside the triangle not defined by any vertex? Let's take a look at an\n        example.\n      </p>\n      <FragmentShaderSecondExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        As is visible from the result, since we set the colors of each vertex\n        have been set to red, green, and blue, those corners of the triangles\n        have been colored appropriately.\n      </p>\n      <p>\n        However, the rest of the triangle seems to be a color mixture of all\n        these colors in specific ratios. This is done through interpolation.\n      </p>\n      <p>\n        When we set the colors of the vertices, and then the object/primitive is\n        set into fragments, the fragments covering the vertices automatically\n        get the color of that vertex, since that is what that fragment\n        represents.\n      </p>\n      <p>\n        The color of other fragments is determined by checking its position and\n        distance relative to every vertex, and interpolating what its color\n        value should be based upon the distance.\n      </p>\n      <p>\n        So, for example, as a fragment moves further away from vertex 2 and\n        moves closer to vertex 3, the green color component slowly fades away\n        and is slowly overtaken by the blue component.\n      </p>\n      <p>Let's look at the code for the shaders in this example:</p>\n      <GlslCodeHighlight\n        code={secondVertexShaderSource.trim()}\n        type={\"Vertex\"}\n      />\n      <GlslCodeHighlight\n        code={secondFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        We pass the color of the vertices to their respective vertex shader by\n        passing the color values as an attribute (since the color is different\n        per vertex).\n      </p>\n      <p>\n        The vertex shader then passes this on to the fragment shader through the{\" \"}\n        <code>vec3</code> varying named <code>color</code>.\n      </p>\n      <p>\n        The <code>color</code> is defined as a varying is because while it is\n        fixed per vertex, it will need to be interpolated when passed to\n        fragments, depending on their position relative to the vertices.\n      </p>\n      <p>\n        It is also defined as <code>lowp</code> which just means the precision\n        of it's value is low (we can ignore these sorts of qualifiers).\n      </p>\n      <p>\n        As a result, when we pass the color of the vertices down to the fragment\n        shaders, the value is interpolated based on the position of the\n        fragment, and then passed to the fragment.\n      </p>\n      <p>\n        Just as attributes are read-only for the vertex shader and can differ\n        per vertex, varyings are read-only for the fragment shader and can\n        differ per fragment (they are write only for the vertex shader).\n      </p>\n      <Heading type=\"h2\">\n        A final example - A pulsing triangle color wheel\n      </Heading>\n      <FragmentShaderThirdExample />\n      <Heading type=\"h3\">How it works</Heading>\n      <p>\n        Similar to how we did the rotating triangle in the previous chapter, we\n        determine how much to shift the color by relative to the current\n        timestamp.\n      </p>\n      <p>\n        By subtracting the calculated color shift from the interpolated fragment\n        color, we can have the color of the triangle oscillate from pure black,\n        to the standard triangle color wheel, to pure white, and back again.\n      </p>\n      <GlslCodeHighlight\n        code={thirdFragmentShaderSource.trim()}\n        type={\"Fragment\"}\n      />\n      <p>\n        The color shift is calculated in the shader by taking the time elapsed\n        since the start of the animation as an input, dividing it by 500 so that\n        the animation runs slower, and then finding the cosine of the elapsed\n        time.\n      </p>\n      <p>\n        The time is passed in milliseconds, and the <code>cos</code> function in\n        glsl takes time in radians. So the animation depends on every half\n        second passed.\n      </p>\n      <p>\n        Since the division results in a floating point number, this number does\n        change every frame, which results in the color shift value also updating\n        accordingly.\n      </p>\n      <p>\n        <em>\n          <code>clamp</code> is a function that takes a specific value (\n          <code>color - colorShift</code>) and makes sure it doesn't go outside\n          of a certain range (<code>0.0</code> and <code>1.0</code>), \"clamping\"\n          it to either end depending on if it is too large or too small. It also\n          works with both vector (<code>vec2</code>, <code>vec3</code>,{\" \"}\n          <code>vec4</code>) and scalar values (<code>float</code>,{\" \"}\n          <code>int</code>)\n        </em>\n      </p>\n      <Heading type=\"h2\">Summary</Heading>\n      <ul>\n        <li>\n          The fragment shader receives a fragment from a list of fragments and\n          sets the appropriate color value for that fragment.\n        </li>\n        <li>\n          At least one fragment that comes under a pixel is used when\n          determining the color of that pixel.\n        </li>\n        <li>\n          The fragment shader requires certain values in order to determine what\n          the final color of the fragment should be.\n          <ul>\n            <li>\n              If this data is passed through the vertex shader, its actual value\n              will be interpolated by the GPU based on the distance of the\n              fragment from each vertex of the primitive.\n            </li>\n            <li>\n              If the data is passed as a uniform, then the GPU will not\n              interpolate its actual value, since it is supposed to be uniform\n              among all fragments.\n            </li>\n          </ul>\n        </li>\n      </ul>\n    </Content>\n    <PageChange previous=\"/basics/color/\" next=\"/basics/end/\" />\n  </Layout>\n);\n\nexport default FragmentShaderPage;\n"],"names":["firstFragmentShaderSource","shaderProgramInfo","vertex","attributeLocations","vertexPosition","uniformLocations","mvpMatrix","fragment","triangleModelPosition","mat4","wrapExample","FragmentShaderFirstExample","triangle","vertices","webGlRef","updateWebGlRef","useState","shaderProgram","updateShaderProgram","shaderInfo","updateShaderInfo","triangleBuffer","updateTriangleBuffer","canvasRef","useRef","useEffect","current","newWebGlRef","WebGlWrapper","destroy","runOnPredicate","createShaderProgram","getDataLocations","createStaticDrawArrayBuffer","flat","shouldRender","renderScene","_ref","gl","projectionMatrix","viewMatrix","modelMatrix","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","useProgram","uniformMatrix4fv","drawArrays","TRIANGLES","length","requestAnimationFrame","React","className","style","padding","width","height","ref","coordArrToString","trim","secondVertexShaderSource","vertexShader","secondFragmentShaderSource","vertexColor","FragmentShaderSecondExample","colors","colorCoordMap","x","y","z","thirdVertexShaderSource","thirdFragmentShaderSource","time","FragmentShaderThirdExample","updateTime","performance","now","then","parseInt","toString","currentTime","uniform1f","location","pathname","Layout","Seo","title","description","keywords","Content","Heading","type","Link","to","StaticImage","src","alt","maxWidth","__imageData","require","GlslCodeHighlight","code","PageChange","previous","next"],"sourceRoot":""}